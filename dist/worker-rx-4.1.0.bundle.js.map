{"version":3,"sources":["webpack:///dist/worker-rx-4.1.0.bundle.js","webpack:///webpack/bootstrap 299ce472bbf6fc5ab701?38c1*","webpack:///external \"Rx\"?442b*","webpack:///./src/experiment/sample-data.ts","webpack:///./src/instrumentation/rxjs-4.1.0/collector.ts","webpack:///./src/instrumentation/worker-utils.ts","webpack:///./src/instrumentation/rxjs-4.1.0/instrumentation.ts","webpack:///./src/instrumentation/rxjs-4.1.0/worker.ts","webpack:///./~/base64-js/index.js?2add*","webpack:///./~/ieee754/index.js?70fe*","webpack:///./~/isarray/index.js?eabc*","webpack:///./~/node-libs-browser/~/buffer/index.js?7e77*","webpack:///./src/collector/collector.ts?d603*","webpack:///./src/collector/callrecord.ts?e81e","webpack:///./src/utils.ts?55fd*","webpack:///./src/collector/event.ts?a5b4","webpack:///(webpack)/buildin/global.js?3698*","webpack:///./src/oct/oct.ts?f3d9*","webpack:///./src/collector/treePoster.ts","webpack:///./src/collector/logger.ts?4f8b","webpack:///./src/prelude.ts?4065*"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","1","Rx","11","global","scheduler","_","next","ReactiveTest","onNext","complete","onCompleted","experimentProto","TestScheduler","advanceTo","bmi","height$","this","createHotObservable","map","v","concat","weight$","lottery","_this","newYear$","Observable","interval","survey","t","Date","UTC","veryOldServer","date","getTime","Math","pow","throw","Error","msg","winningTicket","round","random","imdb","_this2","inputStream","text","_scheduler","messages","length","shift","push","slice","apply","_movies","findMoviesAsync","term","result","filter","movie","toLowerCase","indexOf","johnsInput$","render","renderSomething","log","showError","noop","eval","experiment","119","_toConsumableArray","arr","Array","isArray","arr2","from","_classCallCheck","instance","Constructor","TypeError","_getScheduler","obs","record","arguments","collector_1","isScheduler","callStackDepth","parent","generate","seed","sequenceUnique","keySelector","list","filtered","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","done","err","return","_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","_typeof","obj","constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","callrecord_1","event_1","logger_1","oct_1","prelude_1","debug","SequenceTicker","last","used","TreeCollector","logger","nextId","eventSequencer","schedulers","collectorId","hash","fn","self","isObservable","subject","replacementLambda","observableWrapper","returned","__original","method","action","state","info","tag","startsWith","justAssigned","parents","callRecordType","tagObservable","isObserver","subscriptionWrapper","tagObserver","flatMap","forEach","sub","observable","SubjectTree","addSink","setObservable","ObservableTree","r","hasTag","id","observer","event","type","events","inflow","timing","getTiming","addEvent","isDisposable","disposableWrapper","input","tree","getScheduler","ObserverTree","getPrototype","console","clock","now","SchedulerInfo","clocks","tick","assign","_this3","traverse","getSink","_ref","_ref2","sink","setSink","_this4","elvis","rec","_ref3","_ref4","how","callRecord","_this5","wasTagged","addMeta","calls","args","formatArguments","source","setSources","_sources","context","outerContext","subscribe","Proxy","__isSubscriptionWrapper","proxy","collector","Event","fromCall","original","__isDisposableWrapper","12","formatError","e","message","stack","toString","scopedEval","code","scope","evalAndRepackageErrors","dummyError","exec","error","index","lastIndexOf","substring","split","join","onWorkerMessage","instrument","data","importScripts","url","postMessage","120","performance","hasRxObservablePrototype","rxAny","isPrototypeOf","matcher","substr","detachedScopeProxy","hashes","__detached","set","rxTweaks","fields","a","prop","__proto__","defaultSubjects","Observable.prototype","ConnectableObservable.prototype","ConnectableObservable","ObservableBase.prototype","ObservableBase","Subject.prototype","Subject","defaultSchedulerFactory","keys","Scheduler","reduce","HASH","IGNORE","Instrumentation","subjects","open","stackTraces","prototypes","by","__originalFunction","isInstrumented","__instrumentedBy","orig","extras","thisArg","argumentsList","setupPrototype","childs","subjectName","time","instanceLogger","before","wrapHigherOrder","bind","end","after","pop","construct","warn","Function","deinstrument","methodName","setupSchedulerMethods","setupSchedulerPrototype","schedule","proto","_newAction","newAction","schedulerPrototype","argArray","newTarget","__dynamicallyInstrumented","methods","prev","default","129","treePoster_1","worker_utils_1","instrumentation_1","onmessage","poster","setup","version","14","placeHoldersCount","b64","len","byteLength","toByteArray","j","tmp","placeHolders","Arr","L","revLookup","charCodeAt","tripletToBase64","num","lookup","encodeChunk","uint8","start","output","fromByteArray","extraBytes","parts","len2","Uint8Array","17","read","buffer","offset","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","NaN","Infinity","write","rt","abs","isNaN","floor","LN2","18","19","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","arg","encodingOrOffset","allocUnsafe","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","checked","string","isEncoding","actual","fromArrayLike","array","byteOffset","isBuffer","copy","isnan","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","b","bidirectionalIndexOf","val","dir","arrayIndexOf","buf","indexSize","readUInt16BE","arrLength","valLength","String","foundIndex","found","hexWrite","Number","remaining","strLen","parsed","parseInt","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","str","stringtrim","replace","INVALID_BASE64_RE","trim","units","leadSurrogate","byteArray","hi","lo","src","dst","INSPECT_MAX_BYTES","foo","subarray","poolSize","_augment","species","allocUnsafeSlow","_isBuffer","compare","x","y","pos","swap16","swap32","swap64","equals","inspect","match","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","25","dispose","item","path","29","3","utoa","btoa","encodeURIComponent","p1","atou","decodeURIComponent","atob","getName","funcNameRegex","results","UUID","30","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","Next","ErrorInstance","Complete","Connect","Subscribe","Dispose","_Event","getPrototypeOf","someError","_Event2","_Event3","_Event4","_Event5","_Event6","4","g","window","5","pad","depth","_inspect","opts","names","addNode","sources","addEdge","label","meta","sinks","addInflow","outer","derivedCtor","baseCtors","baseCtor","getOwnPropertyNames","addScheduler","51","TreePoster","cb","post","location","origin","w","nodes","contract","7","formatObject","levels","padding","_formatArguments","Logger","8","f","endsWith","suffix","head","protoype"],"mappings":"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","file":"./dist/worker-rx-4.1.0.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 129);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 1:\n/***/ (function(module, exports) {\n\nmodule.exports = Rx;\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar scheduler = null;\nvar _ = {\n    get next() {\n        return Rx.ReactiveTest.onNext;\n    },\n    get complete() {\n        return Rx.ReactiveTest.onCompleted;\n    }\n};\nvar experimentProto = {\n    get scheduler() {\n        if (scheduler === null) {\n            scheduler = new Rx.TestScheduler();\n            scheduler.advanceTo(0);\n        }\n        return scheduler;\n    },\n    get bmi() {\n        return {\n            height$: this.scheduler.createHotObservable([1.76, 1.77, 1.78].map(function (v, i) {\n                return _.next(i * 100, v);\n            }).concat([_.complete(400)])),\n            weight$: this.scheduler.createHotObservable([70, 72, 76, 79, 78, 75].map(function (v, i) {\n                return _.next(i * 100, v);\n            }).concat([_.complete(700)]))\n        };\n    },\n    get lottery() {\n        var _this = this;\n\n        var start = 2034;\n        var year = 1000 * 3600 * 24 * 365.25;\n        return {\n            newYear$: Rx.Observable.interval(year, survey.scheduler).map(function (t) {\n                return new Date(Date.UTC(t + start, 0, 1));\n            }),\n            veryOldServer: function veryOldServer(date) {\n                var unix = new Date(date).getTime() / 1000;\n                if (unix > Math.pow(2, 31)) {\n                    return Rx.Observable.throw(new Error(\"Crash!\"), _this.scheduler);\n                } else {\n                    return _this.scheduler.createHotObservable(_.next(0, { msg: \"calculating\" }), _.next(10, { msg: \"Happy new year!\", winningTicket: Math.round(Math.random() * 10) }), _.complete(20));\n                }\n            }\n        };\n    },\n    get imdb() {\n        var _this2 = this;\n\n        var inputStream = function inputStream(text) {\n            var _scheduler;\n\n            var t = 0;\n            var messages = [];\n            // let random = new Array(11).fill(1).map(_ => Math.floor(Math.random() * 100))\n            var random = [21, 37, 69, 35, 8, 48, 99, 75, 32, 51, 52, 96, 55, 19, 14, 61, 89, 70, 44, 69, 21, 19, 87, 64, 52, 96, 12, 41, 33, 69, 28, 35, 23, 82, 94, 73, 79, 24, 15, 19, 22, 21, 48, 25, 64, 52, 59, 23, 8, 63, 97, 74, 18, 86, 97, 21, 64, 8, 66, 33, 0, 40, 53, 70, 72, 62, 54, 13, 88, 43, 94, 70, 96, 6, 91, 60, 77, 58, 12, 98, 8, 64, 96, 9, 28, 86, 45, 65, 94, 28, 55, 39, 34, 46, 2, 93, 17, 84, 3];\n            for (var i = 0; i <= text.length; i++) {\n                t += random.shift();\n                messages.push(_.next(t, text.slice(0, i)));\n            }\n            return (_scheduler = _this2.scheduler).createHotObservable.apply(_scheduler, messages);\n        };\n        return {\n            _movies: [\"Them\", \"Lion King\", \"Belle & The Beast\", \"Avatar\", \"Harry Potter\", \"Guardians of the Galaxy\", \"House of Cards\", \"Spectre\", \"Interstellar\", \"Iron Man\", \"Terminator Genisys\", \"The Titanic\", \"The Avengers\"],\n            findMoviesAsync: function findMoviesAsync(term) {\n                var result = _this2.imdb._movies.filter(function (movie) {\n                    return movie.toLowerCase().indexOf(term.toLowerCase()) >= 0;\n                });\n                var t = 100 * result.length;\n                return _this2.scheduler.createHotObservable(_.next(t, result), _.complete(t + 1));\n            },\n            inputStream: inputStream,\n            johnsInput$: inputStream(\"the titanic\"),\n            render: function render() {}\n        };\n    },\n    get render() {\n        return function () {};\n    },\n    get renderSomething() {\n        return function () {};\n    },\n    get log() {\n        return function () {};\n    },\n    get showError() {\n        return function () {};\n    },\n    get noop() {\n        return function () {};\n    }\n};\neval(\"var experiment = experimentProto\");\nglobal.experiment = experimentProto;\neval(\"var survey = experimentProto\");\nglobal.survey = experimentProto;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n\n/***/ 119:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar callrecord_1 = __webpack_require__(29);\nvar collector_1 = __webpack_require__(25);\nvar event_1 = __webpack_require__(30);\nvar logger_1 = __webpack_require__(7);\nvar oct_1 = __webpack_require__(5);\nvar prelude_1 = __webpack_require__(8);\nvar debug = false;\nfunction _getScheduler(obs, record) {\n    return obs.scheduler || obs._scheduler || record && [].slice.call(record.arguments, -1).filter(collector_1.isScheduler)[0];\n}\n\nvar SequenceTicker = function () {\n    function SequenceTicker() {\n        _classCallCheck(this, SequenceTicker);\n\n        this.last = 0;\n        this.used = false;\n    }\n\n    _createClass(SequenceTicker, [{\n        key: \"next\",\n        value: function next() {\n            if (this.used) {\n                this.used = false;\n                this.last++;\n            }\n        }\n    }, {\n        key: \"get\",\n        value: function get() {\n            this.used = true;\n            return this.last;\n        }\n    }]);\n\n    return SequenceTicker;\n}();\n\nvar TreeCollector = function () {\n    function TreeCollector(logger, Rx) {\n        _classCallCheck(this, TreeCollector);\n\n        this.Rx = Rx;\n        this.nextId = 1;\n        this.eventSequencer = new SequenceTicker();\n        this.schedulers = [];\n        this.collectorId = TreeCollector.collectorId++;\n        this.hash = this.collectorId ? \"__thash\" + this.collectorId : \"__thash\";\n        this.logger = logger;\n    }\n    /**\n     * Used to wrap arguments of higher order functions. Consider:\n     *\n     *   let a = Rx.Observable.just(1)\n     *   a.flatMap((nr) => Rx.Observable.of(nr, nr * 2, nr * 3))\n     *\n     * now wrapHigherOrder is called like this:\n     *\n     *   wrapHigherOrder(a, (nr) => Rx.Observable.of(nr, nr * 2, nr * 3))\n     *\n     * so we can inject a custom function which can link the result of the lambda to `a`.\n     *\n     * @param subject observable to link to\n     * @param fn function (or any other argument) to wrap\n     */\n\n\n    _createClass(TreeCollector, [{\n        key: \"wrapHigherOrder\",\n        value: function wrapHigherOrder(call, fn) {\n            var self = this;\n            if (typeof fn === \"function\" && collector_1.isObservable(call.subject)) {\n                var replacementLambda = function replacementLambda() {\n                    var result = fn.apply(this, arguments);\n                    if ((typeof result === \"undefined\" ? \"undefined\" : _typeof(result)) === \"object\" && collector_1.isObservable(result)) {\n                        return self.observableWrapper(result, call.subject, function () {\n                            return call.returned;\n                        });\n                    }\n                    return result;\n                };\n\n                replacementLambda.__original = fn;\n                return replacementLambda;\n            }\n            return fn;\n        }\n    }, {\n        key: \"schedule\",\n        value: function schedule(scheduler, method, action, state) {\n            var info = this.tag(scheduler);\n            var self = this;\n            if (method.startsWith(\"schedule\") && method !== \"scheduleRequired\") {\n                // tslint:disable-next-line:only-arrow-functions\n                return function () {\n                    var justAssigned = self.scheduler = { scheduler: scheduler, info: info };\n                    self.eventSequencer.next();\n                    var result = action.apply(this, arguments);\n                    if (self.scheduler === justAssigned) {\n                        self.scheduler = undefined;\n                    }\n                    return result;\n                };\n            }\n        }\n    }, {\n        key: \"before\",\n        value: function before(record, parents) {\n            var _this = this;\n\n            switch (callrecord_1.callRecordType(record)) {\n                case \"subscribe\":\n                    var obs = this.tagObservable(record.subject);\n                    [].slice.call(record.arguments, 0, 1).filter(collector_1.isObserver).map(function (s) {\n                        record.arguments[0] = _this.subscriptionWrapper(record.arguments[0], _this.tagObserver(s, record)[0]);\n                        return s;\n                    }).flatMap(function (s) {\n                        return _this.tagObserver(s, record);\n                    }).forEach(function (sub) {\n                        obs.forEach(function (observable) {\n                            if (observable instanceof oct_1.SubjectTree) {\n                                // Special case for subjects\n                                observable.addSink([sub], \" subject\");\n                                sub.setObservable([observable]);\n                            } else if (observable instanceof oct_1.ObservableTree) {\n                                sub.setObservable([observable]);\n                            }\n                        });\n                    });\n                    break;\n                case \"setup\":\n                    this.tagObservable(record.subject);\n                default:\n                    break;\n            }\n            return this;\n        }\n    }, {\n        key: \"getEventReason\",\n        value: function getEventReason(record) {\n            var _this2 = this;\n\n            return [record.parent, record.parent && record.parent.parent].filter(function (r) {\n                return r && collector_1.isObserver(r.subject) && _this2.hasTag(r.subject);\n            }).map(function (r) {\n                return _this2.tag(r.subject).id;\n            })[0];\n        }\n    }, {\n        key: \"addEvent\",\n        value: function addEvent(observer, event, value) {\n            if (typeof event === \"undefined\") {\n                return;\n            }\n            // Enrich higher order events\n            if (event.type === \"next\" && collector_1.isObservable(value)) {\n                event.value = {\n                    id: this.tag(value).id,\n                    type: value.constructor.name\n                };\n            }\n            // Ignore 2nd subscribe (subscribe & _subscribe are instrumented both)\n            if (observer.events.length === 1 && observer.events[0].type === \"subscribe\" && event.type === \"subscribe\") {\n                return;\n            }\n            if (!observer.inflow || observer.inflow.length === 0) {\n                this.eventSequencer.next();\n            }\n            event.timing = this.getTiming();\n            observer.addEvent(event);\n        }\n    }, {\n        key: \"after\",\n        value: function after(record) {\n            switch (callrecord_1.callRecordType(record)) {\n                case \"subscribe\":\n                    if (collector_1.isDisposable(record.returned)) {\n                        record.returned = this.disposableWrapper(record.returned, record.arguments[0]);\n                    }\n                    break;\n                case \"setup\":\n                    this.tagObservable(record.returned, record);\n                default:\n                    break;\n            }\n        }\n    }, {\n        key: \"hasTag\",\n        value: function hasTag(input) {\n            return (typeof input === \"undefined\" ? \"undefined\" : _typeof(input)) === \"object\" && input !== null && typeof input[this.hash] !== \"undefined\";\n        }\n    }, {\n        key: \"tag\",\n        value: function tag(input, record) {\n            var tree = void 0;\n            if (typeof input === \"undefined\") {\n                return undefined;\n            }\n            if (typeof input[this.hash] !== \"undefined\") {\n                return input[this.hash];\n            }\n            if (collector_1.isObserver(input) && collector_1.isObservable(input)) {\n                input[this.hash] = tree = new oct_1.SubjectTree(\"\" + this.nextId++, input.constructor.name, this.logger, this.getScheduler(input));\n                return tree;\n            }\n            if (collector_1.isObservable(input)) {\n                input[this.hash] = tree = new oct_1.ObservableTree(\"\" + this.nextId++, input.constructor.name, this.logger, this.getScheduler(input, record));\n                return tree;\n            }\n            if (collector_1.isObserver(input)) {\n                input[this.hash] = tree = new oct_1.ObserverTree(\"\" + this.nextId++, input.constructor.name, this.logger);\n                return tree;\n            }\n            if (collector_1.isScheduler(input)) {\n                var scheduler = input;\n                var type = void 0;\n                switch (prelude_1.getPrototype(scheduler).constructor.name) {\n                    case \"ImmediateScheduler\":\n                        type = \"immediate\";\n                        break;\n                    case \"DefaultScheduler\":\n                        type = \"timeout\";\n                        break;\n                    case \"CurrentThreadScheduler\":\n                        type = \"recursive\";\n                        break;\n                    case \"TestScheduler\":\n                        type = \"virtual\";\n                        break;\n                    default:\n                        if (debug) {\n                            console.debug(\"unknown scheduler type\", prelude_1.getPrototype(scheduler).constructor.name);\n                        }\n                        type = \"virtual\";\n                        break;\n                }\n                var clock = scheduler.now();\n                var info = new oct_1.SchedulerInfo(\"\" + this.nextId++, prelude_1.getPrototype(scheduler).constructor.name, type, clock, this.logger);\n                input[this.hash] = info;\n                this.schedulers.push({ scheduler: scheduler, info: info });\n                return info;\n            }\n        }\n    }, {\n        key: \"getScheduler\",\n        value: function getScheduler(input, record) {\n            if (collector_1.isObservable(input) && _getScheduler(input, record)) {\n                return this.tag(_getScheduler(input, record));\n            }\n        }\n    }, {\n        key: \"getTiming\",\n        value: function getTiming() {\n            var clocks = { tick: this.eventSequencer.get() };\n            if (this.scheduler) {\n                clocks[this.scheduler.info.id] = this.scheduler.scheduler.now();\n                return Object.assign({\n                    scheduler: this.scheduler.info.id,\n                    clocks: clocks\n                });\n            }\n            return {\n                clocks: clocks,\n                scheduler: \"tick\"\n            };\n        }\n    }, {\n        key: \"tagObserver\",\n        value: function tagObserver(input, record) {\n            var _this3 = this;\n\n            var traverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            if (collector_1.isObserver(input)) {\n                // Rx specific: unfold AutoDetachObserver's, \n                while (traverse && input && input.constructor.name === \"AutoDetachObserver\" && input.observer) {\n                    input = input.observer;\n                }\n                var tree = this.tag(input);\n                // Find sink\n                var sinks = this.getSink(input, record);\n                sinks.forEach(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2),\n                        how = _ref2[0],\n                        sink = _ref2[1];\n\n                    tree.setSink([_this3.tag(sink)]);\n                });\n                return [tree];\n            }\n            return [];\n        }\n    }, {\n        key: \"getSink\",\n        value: function getSink(input, record) {\n            var _this4 = this;\n\n            // Rx specific: InnerObservers have references to their sinks via a AutoDetachObserver\n            var list = collector_1.elvis(input, [\"o\", \"observer\"]) // InnerObservers\n            .concat(collector_1.elvis(input, [\"_o\", \"observer\"])) // InnerObservers\n            .concat(collector_1.elvis(input, [\"parent\"])) // what was this again?\n            .concat(collector_1.elvis(input, [\"_s\", \"o\"])) // ConcatObserver\n            .concat(collector_1.elvis(input, [\"observer\"])) // ConcatObserver\n            .map(function (s) {\n                return [\" via o.observer\", s];\n            });\n            // If no sinks could be found via object attributes, try to find it via the call stack\n            if (record && !list.length && callStackDepth(record) > 2 && !(collector_1.isObservable(input) && collector_1.isObserver(input))) {\n                list.push.apply(list, _toConsumableArray(sequenceUnique(function (_) {\n                    return _.sub;\n                }, generate(record, function (_) {\n                    return _.parent;\n                }).map(function (rec) {\n                    return {\n                        sub: rec.arguments[0]\n                    };\n                }).filter(function (_) {\n                    return collector_1.isObserver(_.sub) && _.sub !== input;\n                })).slice(1, 2).map(function (_) {\n                    return [\" via callstack\", _.sub];\n                })));\n            }\n            return list.slice(0, 1).flatMap(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    how = _ref4[0],\n                    sink = _ref4[1];\n\n                if (sink.constructor.name === \"AutoDetachObserver\") {\n                    return _this4.getSink(sink);\n                } else {\n                    return [[how, sink]];\n                }\n            });\n        }\n    }, {\n        key: \"tagObservable\",\n        value: function tagObservable(input, callRecord) {\n            var _this5 = this;\n\n            if (collector_1.isObservable(input)) {\n                var wasTagged = this.hasTag(input);\n                var tree = this.tag(input, callRecord);\n                if (!wasTagged) {\n                    /* TODO find other way: this is a shortcut to prevent MulticastObservable._fn1 to show up */\n                    if (callRecord && callRecord.method[0] !== \"_\") {\n                        while (callRecord && collector_1.isObservable(callRecord.returned) && callRecord.method[0] !== \"_\") {\n                            tree.addMeta({\n                                calls: {\n                                    subject: \"callRecord.subjectName \" + (this.hasTag(callRecord.subject) && this.tag(callRecord.subject).id),\n                                    args: logger_1.formatArguments(callRecord.arguments),\n                                    method: callRecord.method\n                                }\n                            });\n                            // if (typeof callRecord.parent !== \"undefined\" && isObservable(callRecord.parent.subject)) {\n                            callRecord = callRecord.parent;\n                            // } else {\n                            //   callRecord = undefined\n                            // }\n                        }\n                    }\n                    if (input.source) {\n                        tree.setSources(this.tagObservable(input.source));\n                    } else if (input._sources) {\n                        tree.setSources(input._sources.flatMap(function (s) {\n                            return _this5.tagObservable(s);\n                        }));\n                    }\n                }\n                if (_getScheduler(input)) {\n                    this.tag(_getScheduler(input));\n                }\n                return [tree];\n            }\n            return [];\n        }\n    }, {\n        key: \"observableWrapper\",\n        value: function observableWrapper(target, context, outerContext) {\n            function subscribe() {\n                if (debug) {\n                    console.debug(\"Wrap this higher order subscribe method\\n\", target.constructor.name, context.constructor.name, outerContext().constructor.name);\n                }\n                var result = target.subscribe.apply(target, arguments);\n                return result;\n            }\n            return new Proxy(target, {\n                get: function get(obj, name) {\n                    if (name === \"isScoped\") {\n                        return true;\n                    }\n                    if (name === \"subscribe\" && \"subscribe\" in target) {\n                        return subscribe;\n                    }\n                    return obj[name];\n                }\n            });\n        }\n        // Wrap this around a Subscription to log onNext, onError, onComplete, dispose calls\n\n    }, {\n        key: \"subscriptionWrapper\",\n        value: function subscriptionWrapper(target, tree) {\n            if (target.__isSubscriptionWrapper) {\n                return target;\n            }\n            // Ensure only one single Proxy is attached to the IObserverTree\n            if (tree.proxy) {\n                return target;\n            }\n            var collector = this;\n            var events = [\"onNext\", \"onError\", \"onCompleted\", \"dispose\"];\n            tree.addEvent(event_1.Event.fromCall(\"subscribe\", undefined, this.getTiming()));\n            var proxy = new Proxy(target, {\n                get: function get(obj, name) {\n                    var original = obj[name];\n                    if (name === \"__isSubscriptionWrapper\") {\n                        return true;\n                    }\n                    if (typeof original === \"function\" && events.indexOf(name) >= 0) {\n                        var _proxy = function _proxy() {\n                            collector.addEvent(tree, event_1.Event.fromCall(name, [].slice.call(arguments, 0), undefined), arguments[0]);\n                            return original.apply(this, arguments);\n                        };\n\n                        return _proxy;\n                    }\n                    return original;\n                }\n            });\n            tree.proxy = proxy;\n            return proxy;\n        }\n        // Wrap this around a Disposable to log dispose calls onto the supplied observer\n\n    }, {\n        key: \"disposableWrapper\",\n        value: function disposableWrapper(target, observer) {\n            if (target.__isDisposableWrapper) {\n                return target;\n            }\n            var tree = collector_1.isObserver(observer) ? this.tagObserver(observer) : [];\n            var collector = this;\n            return new Proxy(target, {\n                get: function get(obj, name) {\n                    var original = obj[name];\n                    if (name === \"__isDisposableWrapper\") {\n                        return true;\n                    }\n                    if (typeof original === \"function\" && name === \"dispose\") {\n                        var proxy = function proxy() {\n                            collector.addEvent(tree[0], event_1.Event.fromCall(name, [].slice.call(arguments, 0), undefined));\n                            return original.apply(this, arguments);\n                        };\n\n                        return proxy;\n                    }\n                    return original;\n                }\n            });\n        }\n    }]);\n\n    return TreeCollector;\n}();\n\nTreeCollector.collectorId = 0;\nexports.TreeCollector = TreeCollector;\nfunction callStackDepth(record) {\n    return typeof record.parent === \"undefined\" ? 1 : 1 + callStackDepth(record.parent);\n}\nfunction generate(seed, next) {\n    if (typeof seed === \"undefined\" || seed === null) {\n        return [];\n    } else {\n        return [seed].concat(_toConsumableArray(generate(next(seed), next)));\n    }\n}\nfunction sequenceUnique(keySelector, list) {\n    var filtered = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var v = _step.value;\n\n            if (filtered.length === 0 || keySelector(filtered[filtered.length - 1]) !== keySelector(v)) {\n                filtered.push(v);\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return filtered;\n}\n\n/***/ }),\n\n/***/ 12:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction formatError(e) {\n    return {\n        message: e.message,\n        name: e.name,\n        original: typeof e.original !== \"undefined\" ? formatError(e.original) : undefined,\n        stack: e.stack.toString()\n    };\n}\nvar scope = {};\n/**\n * Have single location for evil eval,\n * so we can infer it's stackTrace beforehand\n * and strip that from the errors coming from it\n */\nfunction scopedEval(code) {\n    // tslint:disable-next-line:only-arrow-functions\n    (function () {\n        // tslint:disable-next-line:no-eval\n        return eval(code);\n    }).call(scope);\n}\nfunction evalAndRepackageErrors(code) {\n    try {\n        return { result: scopedEval(code), type: \"result\" };\n    } catch (e) {\n        // Infer eval location\n        try {\n            scopedEval(\"throw new Error('ERROR')\");\n        } catch (dummyError) {\n            // clean up error stack trace\n            var result = /\\n\\s+at Object.<anonymous> \\((.*)\\)/.exec(dummyError.stack);\n            if (result === null) {\n                return { error: e.stack, type: \"error\" };\n            }\n            var stack = e.stack.toString();\n            var index = stack.lastIndexOf(\"at Object.<anonymous> (\" + result[1] + \")\");\n            stack = stack.substring(0, index);\n            stack = stack.split(\"eval at <anonymous> (\" + result[1] + \"), \").join(\"\");\n            e.stack = stack;\n        }\n        return { error: formatError(e), type: \"error\" };\n    }\n}\nfunction onWorkerMessage(instrument) {\n    return function (e) {\n        var message = e.data;\n        switch (message.type) {\n            case \"importScripts\":\n                importScripts(message.url);\n                instrument();\n                break;\n            case \"run\":\n                // Execute user code\n                var result = evalAndRepackageErrors(message.code);\n                if (result.type === \"error\") {\n                    postMessage({\n                        error: result.error,\n                        type: \"error\"\n                    });\n                }\n                break;\n            default:\n                break;\n        }\n    };\n}\nexports.onWorkerMessage = onWorkerMessage;\nif (typeof postMessage === \"function\") {\n    postMessage(\"ready\");\n}\n\n/***/ }),\n\n/***/ 120:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(3);\nvar Rx = __webpack_require__(1);\nvar rxAny = Rx;\nexports.defaultSubjects = function (rxAny) {\n    return {\n        Observable: Rx.Observable,\n        \"Observable.prototype\": rxAny.Observable.prototype,\n        \"ConnectableObservable.prototype\": rxAny.ConnectableObservable.prototype,\n        \"ObservableBase.prototype\": rxAny.ObservableBase.prototype,\n        // \"AbstractObserver.prototype\": rxAny.internals.AbstractObserver.prototype,\n        // \"AnonymousObserver.prototype\": rxAny.AnonymousObserver.prototype,\n        \"Subject.prototype\": rxAny.Subject.prototype\n    };\n};\nexports.defaultSchedulerFactory = Object.keys(Rx.Scheduler).filter(function (name) {\n    return _typeof(Rx.Scheduler[name]) === \"object\";\n}).filter(function (name) {\n    return Rx.Scheduler[name].__proto__.constructor.name.indexOf(\"Scheduler\") >= 0;\n}).reduce(function (p, name) {\n    p[name] = Rx.Scheduler[name];\n    return p;\n}, {});\nexports.HASH = \"__hash\";\nexports.IGNORE = \"__ignore\";\nfunction now() {\n    return typeof performance !== \"undefined\" ? performance.now() : new Date().getTime();\n}\nfunction hasRxObservablePrototype(input) {\n    return (typeof input === \"undefined\" ? \"undefined\" : _typeof(input)) === \"object\" && rxAny.Observable.prototype.isPrototypeOf(input);\n}\nfunction startsWith(input, matcher) {\n    var r = input.substr(0, matcher.length) === matcher;\n    return r;\n}\nfunction detachedScopeProxy(input) {\n    var hashes = {};\n    if (input.__detached === true) {\n        return input;\n    }\n    return new Proxy(input, {\n        get: function get(target, property) {\n            if (property === \"__detached\") {\n                return true;\n            }\n            if (typeof property === \"string\" && startsWith(property, \"__hash\")) {\n                return hashes[property];\n            }\n            return target[property];\n        },\n        set: function set(target, property, value) {\n            if (typeof property === \"string\" && startsWith(property, \"__hash\")) {\n                hashes[property] = value;\n            }\n            return true;\n        }\n    });\n}\n/**\n * Tweaks specific for RxJS 4\n */\nfunction rxTweaks(call) {\n    // Detach reuse of NeverObservable\n    var fields = [];\n    fields.push([call, \"subject\"], [call, \"returned\"]);\n    fields.push.apply(fields, _toConsumableArray([].map.call(call.arguments, function (a, i) {\n        return [call.arguments, i];\n    })));\n    fields.forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            subject = _ref2[0],\n            prop = _ref2[1];\n\n        if (typeof subject[prop] !== \"undefined\" && subject[prop] !== null && subject[prop].constructor.name === \"NeverObservable\") {\n            subject[prop] = detachedScopeProxy(subject[prop]);\n        }\n    });\n    // Other tweaks here...\n}\n// class Ticker {\n//   private tick: number = 0\n//   private timeout?: Rx.IDisposable\n//   private next: () => void\n//   constructor() {\n//     this.next = this.nextTick.bind(this)\n//   }\n//   public get() {\n//     if (!this.timeout) {\n//       this.timeout = Rx.Scheduler.currentThread.schedule({}, () => { this.next(); return Rx.Disposable.empty })\n//       // this.timeout = setTimeout(this.next, 0)\n//     }\n//     return this.tick\n//   }\n//   private nextTick() {\n//     this.tick++\n//     this.timeout = undefined\n//   }\n// }\n// let ticker = new Ticker()\nfunction getPrototype(input) {\n    return input.prototype || input.__proto__;\n}\nexports.getPrototype = getPrototype;\nvar i = 0;\n\nvar Instrumentation = function () {\n    function Instrumentation() {\n        var subjects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.defaultSubjects;\n        var logger = arguments[1];\n\n        _classCallCheck(this, Instrumentation);\n\n        this.open = [];\n        this.stackTraces = true;\n        this.calls = [];\n        this.prototypes = [];\n        this.subjects = subjects;\n        this.logger = logger;\n        Object.keys(subjects).slice(0, 1).forEach(function (s) {\n            return subjects[s][exports.IGNORE] = true;\n        });\n    }\n\n    _createClass(Instrumentation, [{\n        key: \"isInstrumented\",\n        value: function isInstrumented(fn, by) {\n            if (typeof by === \"undefined\") {\n                return typeof fn.__originalFunction === \"function\" ? 1 + this.isInstrumented(fn.__originalFunction) : 0;\n            }\n            if (fn.__instrumentedBy === by) {\n                return true;\n            }\n            var orig = fn.__originalFunction;\n            return typeof orig === \"function\" && this.isInstrumented(orig, by);\n        }\n        /* tslint:disable:only-arrow-functions */\n        /* tslint:disable:no-string-literal */\n        /* tslint:disable:no-string-literal */\n\n    }, {\n        key: \"instrument\",\n        value: function instrument(fn, extras) {\n            var _this = this;\n\n            var calls = this.calls;\n            var logger = this.logger;\n            var open = this.open;\n            var self = this;\n            var instrumented = new Proxy(fn, {\n                apply: function apply(target, thisArg, argumentsList) {\n                    // console.log(target.caller)\n                    // find more\n                    argumentsList.filter(hasRxObservablePrototype).filter(function (v) {\n                        return !_this.isInstrumented(v);\n                    }).forEach(function (t) {\n                        return _this.setupPrototype(t);\n                    });\n                    var call = {\n                        arguments: [].slice.call(argumentsList, 0),\n                        childs: [],\n                        id: i++,\n                        method: extras[\"methodName\"],\n                        stack: self.stackTraces ? undefined : undefined,\n                        subject: thisArg,\n                        subjectName: extras[\"subjectName\"],\n                        tick: 0,\n                        time: now()\n                    };\n                    // Prepare\n                    calls.push(call);\n                    if (open.length > 0) {\n                        call.parent = open[open.length - 1];\n                        call.parent.childs.push(call);\n                    }\n                    open.push(call);\n                    // Nicen up Rx performance tweaks\n                    rxTweaks(call);\n                    // Actual method\n                    var instanceLogger = logger.before(call, open.slice(0, -1));\n                    var returned = target.apply(call.subject, [].map.call(call.arguments, instanceLogger.wrapHigherOrder.bind(instanceLogger, call)));\n                    var end = call;\n                    end.returned = returned;\n                    // Nicen up Rx performance tweaks\n                    rxTweaks(end);\n                    instanceLogger.after(end);\n                    // find more\n                    [end.returned].filter(hasRxObservablePrototype).filter(function (v) {\n                        return !_this.isInstrumented(v);\n                    }).forEach(function (t) {\n                        return _this.setupPrototype(t);\n                    });\n                    // Cleanup\n                    open.pop();\n                    return end.returned;\n                },\n                construct: function construct(target, args) {\n                    console.warn(\"TODO, instrument constructor\", target, args);\n                    return new (Function.prototype.bind.apply(target, [null].concat(_toConsumableArray(args))))();\n                },\n                get: function get(target, property) {\n                    if (property === \"__instrumentedBy\") {\n                        return self;\n                    }\n                    if (property === \"__originalFunction\") {\n                        return fn;\n                    }\n                    return target[property];\n                }\n            });\n            return instrumented;\n        }\n    }, {\n        key: \"deinstrument\",\n        value: function deinstrument(fn) {\n            return fn.__originalFunction && this.deinstrument(fn.__originalFunction) || fn;\n        }\n        /* tslint:enable:only-arrow-functions */\n        /* tslint:enable:no-string-literal */\n        /* tslint:enable:no-string-literal */\n\n    }, {\n        key: \"setup\",\n        value: function setup() {\n            var _this2 = this;\n\n            // Observables\n            Object.keys(this.subjects).forEach(function (name) {\n                return _this2.setupPrototype(_this2.subjects[name], name);\n            });\n            // Subjects\n            rxAny.Subject = this.instrument(rxAny.Subject, {\n                methodName: \"new\",\n                subjectName: \"Rx.Subject\"\n            });\n            // Schedulers\n            Object.keys(exports.defaultSchedulerFactory).forEach(function (name) {\n                return _this2.setupSchedulerMethods(exports.defaultSchedulerFactory[name], name);\n            });\n            rxAny.TestScheduler = this.setupSchedulerPrototype(rxAny.TestScheduler, \"TestScheduler\");\n            this.prototypes.push(rxAny);\n        }\n        // Swap all methods\n\n    }, {\n        key: \"setupSchedulerMethods\",\n        value: function setupSchedulerMethods(instance, name) {\n            var self = this;\n            this.prototypes.push(instance);\n            this.logger.schedule(instance, name, null, null);\n            var proto = getPrototype(instance);\n            this.prototypes.push(proto);\n            Object.keys(proto).filter(function (key) {\n                return typeof instance[key] === \"function\";\n            }).filter(function (key) {\n                return !self.isInstrumented(instance[key], self);\n            }).forEach(function (key) {\n                // if (self.isInstrumented(instance[key]) as any as number > 0) {\n                //   console.log(\"instrumented already\", self.isInstrumented(instance[key]), \"times\")\n                // }\n                var original = instance[key];\n                // instance[key] = function (state: any, action: any, time: number) {\n                //   self.logger.schedule(instance, key, action, { state, time })\n                //   return original.apply(instance, arguments)\n                // }\n                instance[key] = function (state, action, time) {\n                    var args = [].slice.call(arguments, 0);\n                    if (key === \"scheduleAbsolute\") {\n                        console.log(\"Absolute scheduling\", args);\n                        var _newAction = self.logger.schedule(instance, key, args[2], { state: args[0], time: args[1] }) || action;\n                        if (typeof args[2] === \"function\" && typeof _newAction === \"function\") {\n                            args[2] = _newAction;\n                        }\n                        return original.apply(instance, args);\n                    }\n                    var newAction = self.logger.schedule(instance, key, action, { state: state, time: time }) || action;\n                    if (typeof action === \"function\" && typeof newAction === \"function\") {\n                        args[1] = newAction;\n                    }\n                    return original.apply(instance, args);\n                };\n                instance[key].__instrumentedBy = self;\n                instance[key].__originalFunction = original;\n            });\n        }\n        // Swap constructors\n\n    }, {\n        key: \"setupSchedulerPrototype\",\n        value: function setupSchedulerPrototype(schedulerPrototype, name) {\n            var self = this;\n            if (this.isInstrumented(schedulerPrototype, this)) {\n                return;\n            }\n            return new Proxy(schedulerPrototype, {\n                construct: function construct(target, argArray, newTarget) {\n                    var scheduler = new target(argArray);\n                    self.setupSchedulerMethods(scheduler, name);\n                    return scheduler;\n                },\n                get: function get(target, property) {\n                    if (property === \"__instrumentedBy\") {\n                        return self;\n                    }\n                    if (property === \"__originalFunction\") {\n                        return schedulerPrototype;\n                    }\n                    return target[property];\n                }\n            });\n        }\n    }, {\n        key: \"setupPrototype\",\n        value: function setupPrototype(prototype, name) {\n            var _this3 = this;\n\n            if (typeof name !== \"undefined\") {\n                prototype.__dynamicallyInstrumented = true;\n            }\n            var methods = Object.keys(prototype).filter(function (key) {\n                return typeof prototype[key] === \"function\";\n            });\n            // log, preparing for teardown\n            this.prototypes.push(prototype);\n            methods.forEach(function (key) {\n                prototype[key] = _this3.instrument(prototype[key], {\n                    methodName: key,\n                    subjectName: name || prototype.constructor.name\n                });\n            });\n            // let ctor = prototype.constructor\n            // prototype.constructor = function () {\n            //   console.log(\"ctor\", arguments)\n            //   let r = ctor.call(this, arguments)\n            //   return r\n            // }\n        }\n    }, {\n        key: \"teardown\",\n        value: function teardown() {\n            var _this4 = this;\n\n            rxAny.Subject = this.deinstrument(rxAny.Subject);\n            var properties = this.prototypes.map(function (subject) {\n                return Object.keys(subject).map(function (key) {\n                    return { key: key, subject: subject };\n                });\n            }).reduce(function (prev, next) {\n                return prev.concat(next);\n            }, []);\n            var methods = properties.filter(function (_ref3) {\n                var key = _ref3.key,\n                    subject = _ref3.subject;\n                return typeof subject[key] === \"function\";\n            });\n            // let i = 0\n            methods.forEach(function (_ref4) {\n                var key = _ref4.key,\n                    subject = _ref4.subject;\n\n                // i++\n                subject[key] = _this4.deinstrument(subject[key]);\n            });\n            // let fails = this.prototypes\n            //   .map(subject => Object.keys(subject).map(key => ({ key, subject })))\n            //   .reduce((prev, next) => prev.concat(next), [])\n            //   .filter(({ key, subject }) => typeof subject[key] === \"function\")\n            //   .filter(({ key, subject }) => typeof subject[key].__originalFunction === \"function\").length\n            // console.log(\"Tore down\", i, \"methods, failures: \", fails)\n            this.prototypes = [];\n        }\n    }]);\n\n    return Instrumentation;\n}();\n\nexports.default = Instrumentation;\n\n/***/ }),\n\n/***/ 129:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nimportScripts(\"instrumentation/rxjs-4.1.0/rx.all.js\");\nvar treePoster_1 = __webpack_require__(51);\n__webpack_require__(11);\nvar worker_utils_1 = __webpack_require__(12);\nvar collector_1 = __webpack_require__(119);\nvar instrumentation_1 = __webpack_require__(120);\nonmessage = worker_utils_1.onWorkerMessage(function () {\n    var poster = new treePoster_1.default(function (m) {\n        return postMessage(m);\n    });\n    var collector = new collector_1.TreeCollector(poster, Rx);\n    var instrumentation = new instrumentation_1.default(instrumentation_1.defaultSubjects(Rx), collector);\n    instrumentation.setup();\n    console.info(\"Ready for RxJS 4 instrumentation\");\n    Rx.version = \"4.1.0\";\n});\n\n/***/ }),\n\n/***/ 14:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength;\nexports.toByteArray = toByteArray;\nexports.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction placeHoldersCount(b64) {\n  var len = b64.length;\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n}\n\nfunction byteLength(b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64);\n}\n\nfunction toByteArray(b64) {\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n  placeHolders = placeHoldersCount(b64);\n\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = tmp >> 16 & 0xFF;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  if (placeHolders === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[L++] = tmp & 0xFF;\n  } else if (placeHolders === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n}\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('');\n}\n\nfunction fromByteArray(uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[tmp << 4 & 0x3F];\n    output += '==';\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    output += lookup[tmp >> 10];\n    output += lookup[tmp >> 4 & 0x3F];\n    output += lookup[tmp << 2 & 0x3F];\n    output += '=';\n  }\n\n  parts.push(output);\n\n  return parts.join('');\n}\n\n/***/ }),\n\n/***/ 17:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/***/ }),\n\n/***/ 18:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n/***/ }),\n\n/***/ 19:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(14);\nvar ieee754 = __webpack_require__(17);\nvar isArray = __webpack_require__(18);\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength();\n\nfunction typedArraySupport() {\n  try {\n    var arr = new Uint8Array(1);\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {\n        return 42;\n      } };\n    return arr.foo() === 42 && // typed array instances can be augmented\n    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction kMaxLength() {\n  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n}\n\nfunction createBuffer(that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length');\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length);\n    }\n    that.length = length;\n  }\n\n  return that;\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length);\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error('If encoding is specified then the first argument must be a string');\n    }\n    return allocUnsafe(this, arg);\n  }\n  return from(this, arg, encodingOrOffset, length);\n}\n\nBuffer.poolSize = 8192; // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr;\n};\n\nfunction from(that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length);\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset);\n  }\n\n  return fromObject(that, value);\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length);\n};\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    });\n  }\n}\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number');\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative');\n  }\n}\n\nfunction alloc(that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size);\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n  }\n  return createBuffer(that, size);\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding);\n};\n\nfunction allocUnsafe(that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;\n    }\n  }\n  return that;\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size);\n};\n\nfunction fromString(that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');\n  }\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual);\n  }\n\n  return that;\n}\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;\n  }\n  return that;\n}\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);\n  } else {\n    array = new Uint8Array(array, byteOffset, length);\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array;\n    that.__proto__ = Buffer.prototype;\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array);\n  }\n  return that;\n}\n\nfunction fromObject(that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that;\n    }\n\n    obj.copy(that, 0, 0, len);\n    return that;\n  }\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);\n      }\n      return fromArrayLike(that, obj);\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data);\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n}\n\nfunction checked(length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n  }\n  return length | 0;\n}\n\nfunction SlowBuffer(length) {\n  if (+length != length) {\n    // eslint-disable-line eqeqeq\n    length = 0;\n  }\n  return Buffer.alloc(+length);\n}\n\nBuffer.isBuffer = function isBuffer(b) {\n  return !!(b != null && b._isBuffer);\n};\n\nBuffer.compare = function compare(a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers');\n  }\n\n  if (a === b) return 0;\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n    default:\n      return false;\n  }\n};\n\nBuffer.concat = function concat(list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);\n  }\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\nfunction byteLength(string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length;\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;\n  }\n  if (typeof string !== 'string') {\n    string = '' + string;\n  }\n\n  var len = string.length;\n  if (len === 0) return 0;\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length;\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n      case 'hex':\n        return len >>> 1;\n      case 'base64':\n        return base64ToBytes(string).length;\n      default:\n        if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false;\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0;\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return '';\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length;\n  }\n\n  if (end <= 0) {\n    return '';\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);\n  }\n  return this;\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);\n  }\n  return this;\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);\n  }\n  return this;\n};\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length | 0;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);\n};\n\nBuffer.prototype.equals = function equals(b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;\n};\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';\n  }\n  return '<Buffer ' + str + '>';\n};\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer');\n  }\n\n  if (start === undefined) {\n    start = 0;\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0;\n  }\n  if (thisStart === undefined) {\n    thisStart = 0;\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length;\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;\n  }\n  if (thisStart >= thisEnd) {\n    return -1;\n  }\n  if (start >= end) {\n    return 1;\n  }\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0;\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;\n    }\n  }\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1;\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  byteOffset = +byteOffset; // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else byteOffset = buffer.length - 1;\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else return -1;\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1;\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    val = val & 0xFF; // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n  }\n\n  throw new TypeError('val must be string, number or Buffer');\n}\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;\n      }\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;\n    }\n  }\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];\n    } else {\n      return buf.readUInt16BE(i * indexSize);\n    }\n  }\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;\n        }\n      }\n      if (found) return i;\n    }\n  }\n\n  return -1;\n}\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i;\n    buf[offset + i] = parsed;\n  }\n  return i;\n}\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);\n}\n\nfunction latin1Write(buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length);\n}\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);\n}\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n    // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n  }\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');\n  }\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length);\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  };\n};\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);\n  } else {\n    return base64.fromByteArray(buf.slice(start, end));\n  }\n}\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;\n          }\n          break;\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;\n            }\n          }\n          break;\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;\n    }\n\n    res.push(codePoint);\n    i += bytesPerSequence;\n  }\n\n  return decodeCodePointsArray(res);\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);\n  }\n  return ret;\n}\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);\n  }\n  return ret;\n}\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);\n  }\n  return out;\n}\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n  }\n  return res;\n}\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;\n  } else {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];\n    }\n  }\n\n  return newBuf;\n};\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);\n  }\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;\n  }\n\n  return val;\n};\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;\n};\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];\n};\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;\n  }\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;\n};\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);\n};\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);\n};\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);\n};\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);\n};\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;\n    }\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n  }\n\n  return offset + byteLength;\n};\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;\n};\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n  } else {\n    objectWriteUInt16(this, value, offset, true);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n  } else {\n    objectWriteUInt16(this, value, offset, false);\n  }\n  return offset + 2;\n};\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n  } else {\n    objectWriteUInt32(this, value, offset, true);\n  }\n  return offset + 4;\n};\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n  } else {\n    objectWriteUInt32(this, value, offset, false);\n  }\n  return offset + 4;\n};\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');\n}\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);\n};\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);\n};\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start;\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0;\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n  // Are we oob?\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];\n    }\n  } else {\n    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n  }\n\n  return len;\n};\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');\n  }\n\n  if (end <= start) {\n    return this;\n  }\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];\n    }\n  }\n\n  return this;\n};\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return '';\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str;\n}\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;\n        }\n\n        // valid lead\n        leadSurrogate = codePoint;\n\n        continue;\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n    }\n\n    leadSurrogate = null;\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n\n  return bytes;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n  }\n  return byteArray;\n}\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);\n  }\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));\n}\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];\n  }\n  return i;\n}\n\nfunction isnan(val) {\n  return val !== val; // eslint-disable-line no-self-compare\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n\n/***/ 25:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isObserver(v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && typeof v.onNext === \"function\";\n}\nexports.isObserver = isObserver;\nfunction isDisposable(v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && typeof v.dispose === \"function\";\n}\nexports.isDisposable = isDisposable;\nfunction isObservable(v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && typeof v.subscribe === \"function\";\n}\nexports.isObservable = isObservable;\nfunction isScheduler(v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && typeof v.now === \"function\" && typeof v.schedule === \"function\";\n}\nexports.isScheduler = isScheduler;\nfunction elvis(item, path) {\n    var next = (typeof item === \"undefined\" ? \"undefined\" : _typeof(item)) === \"object\" && path.length && path[0] in item ? item[path[0]] : undefined;\n    if (path.length > 1) {\n        return elvis(next, path.slice(1));\n    } else if (typeof next !== \"undefined\") {\n        return [next];\n    } else {\n        return [];\n    }\n}\nexports.elvis = elvis;\n\n/***/ }),\n\n/***/ 29:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction callRecordType(record) {\n    if (typeof record === \"undefined\" || typeof record.subject === \"undefined\") {\n        return undefined;\n    }\n    if (record.subjectName === \"Observable\" || record.subjectName === \"Observable.prototype\" || record.subjectName === \"ObservableBase.prototype\" || record.subjectName && record.subjectName.indexOf(\"Observable\") >= 0) {\n        if (record.method === \"subscribe\" || record.method === \"_subscribe\" || record.method === \"__subscribe\" || record.method === \"_trySubscribe\") {\n            return \"subscribe\";\n        }\n        return \"setup\";\n    } else {\n        return \"event\";\n    }\n}\nexports.callRecordType = callRecordType;\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n/* tslint:disable:no-namespace */\n/* tslint:disable:interface-name */\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ucs-2 string to base64 encoded ascii\nfunction utoa(str) {\n    return exports.btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p1) {\n        return String.fromCharCode(\"0x\" + p1);\n    }));\n}\nexports.utoa = utoa;\n// base64 encoded ascii to ucs-2 string\nfunction atou(str) {\n    return decodeURIComponent(Array.prototype.map.call(exports.atob(str), function (c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(\"\"));\n}\nexports.atou = atou;\nif (typeof exports.btoa !== \"function\") {\n    exports.btoa = function node_btoa(str) {\n        var buffer = void 0;\n        if (str instanceof Buffer) {\n            buffer = str;\n        } else {\n            buffer = new Buffer(str.toString(), \"binary\");\n        }\n        return buffer.toString(\"base64\");\n    };\n}\nif (typeof exports.atob !== \"function\") {\n    exports.atob = function node_atob(str) {\n        return new Buffer(str, \"base64\").toString(\"binary\");\n    };\n}\n/* Get name of function */\nfunction getName() {\n    var funcNameRegex = /function (.{1,})\\(/;\n    var results = funcNameRegex.exec(this.constructor.toString());\n    return results && results.length > 1 ? results[1] : \"\";\n}\nexports.getName = getName;\nfunction UUID() {\n    /** UUID generator: http://stackoverflow.com/a/2117523/552203 */\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        // tslint:disable:no-bitwise\n        var r = Math.random() * 16 | 0;\n        var v = c === \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n        // tslint:enable:no-bitwise\n    });\n}\nexports.UUID = UUID;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19).Buffer))\n\n/***/ }),\n\n/***/ 30:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar logger_1 = __webpack_require__(7);\n\nvar Event = function () {\n    function Event(type, timing, source) {\n        _classCallCheck(this, Event);\n\n        this.type = type;\n        this.timing = timing;\n        this.source = source;\n    }\n\n    _createClass(Event, null, [{\n        key: \"fromRecord\",\n        value: function fromRecord(record, timing, source) {\n            return Event.fromCall(record.method, record.arguments, timing, source);\n        }\n    }, {\n        key: \"fromCall\",\n        value: function fromCall(method, args, timing, source) {\n            switch (method) {\n                case \"next\":\n                case \"onNext\":\n                    return new Next(timing, args[0], source);\n                case \"error\":\n                case \"onError\":\n                case \"fail\":\n                    return new Error(timing, new ErrorInstance(args[0]), source);\n                case \"complete\":\n                case \"onCompleted\":\n                    return new Complete(timing, source);\n                case \"connect\":\n                    return new Connect(timing, source);\n                case \"subscribe\":\n                case \"_subscribe\":\n                case \"__subscribe\":\n                    return new Subscribe(timing, source);\n                case \"dispose\":\n                case \"unsubscribe\":\n                    return new Dispose(timing, source);\n                default:\n                    break;\n            }\n        }\n    }, {\n        key: \"fromJson\",\n        value: function fromJson(input) {\n            switch (input.type) {\n                case \"next\":\n                    return new Next(input.timing, input.value, input.source);\n                case \"error\":\n                    return new Error(input.timing, input.error, input.source);\n                case \"complete\":\n                    return new Complete(input.timing, input.source);\n                case \"subscribe\":\n                    return new Subscribe(input.timing, input.source);\n                case \"dispose\":\n                    return new Dispose(input.timing, input.source);\n                default:\n                    return null;\n            }\n        }\n    }]);\n\n    return Event;\n}();\n\nexports.Event = Event;\n\nvar Next = function (_Event) {\n    _inherits(Next, _Event);\n\n    function Next(timing, value, source) {\n        _classCallCheck(this, Next);\n\n        var _this = _possibleConstructorReturn(this, (Next.__proto__ || Object.getPrototypeOf(Next)).call(this, \"next\", timing, source));\n\n        _this.value = logger_1.formatArguments([value]);\n        return _this;\n    }\n\n    return Next;\n}(Event);\n\nexports.Next = Next;\n\nvar ErrorInstance = function ErrorInstance(someError) {\n    _classCallCheck(this, ErrorInstance);\n\n    this.name = someError.name;\n    this.message = someError.message;\n    this.stack = someError.stack;\n};\n\nexports.ErrorInstance = ErrorInstance;\n\nvar Error = function (_Event2) {\n    _inherits(Error, _Event2);\n\n    function Error(timing, error, source) {\n        _classCallCheck(this, Error);\n\n        var _this2 = _possibleConstructorReturn(this, (Error.__proto__ || Object.getPrototypeOf(Error)).call(this, \"error\", timing, source));\n\n        _this2.error = error;\n        return _this2;\n    }\n\n    return Error;\n}(Event);\n\nexports.Error = Error;\n\nvar Complete = function (_Event3) {\n    _inherits(Complete, _Event3);\n\n    function Complete(timing, source) {\n        _classCallCheck(this, Complete);\n\n        return _possibleConstructorReturn(this, (Complete.__proto__ || Object.getPrototypeOf(Complete)).call(this, \"complete\", timing, source));\n    }\n\n    return Complete;\n}(Event);\n\nexports.Complete = Complete;\n\nvar Subscribe = function (_Event4) {\n    _inherits(Subscribe, _Event4);\n\n    function Subscribe(timing, source) {\n        _classCallCheck(this, Subscribe);\n\n        return _possibleConstructorReturn(this, (Subscribe.__proto__ || Object.getPrototypeOf(Subscribe)).call(this, \"subscribe\", timing, source));\n    }\n\n    return Subscribe;\n}(Event);\n\nexports.Subscribe = Subscribe;\n\nvar Connect = function (_Event5) {\n    _inherits(Connect, _Event5);\n\n    function Connect(timing, source) {\n        _classCallCheck(this, Connect);\n\n        return _possibleConstructorReturn(this, (Connect.__proto__ || Object.getPrototypeOf(Connect)).call(this, \"connect\", timing, source));\n    }\n\n    return Connect;\n}(Event);\n\nexports.Connect = Connect;\n\nvar Dispose = function (_Event6) {\n    _inherits(Dispose, _Event6);\n\n    function Dispose(timing, source) {\n        _classCallCheck(this, Dispose);\n\n        return _possibleConstructorReturn(this, (Dispose.__proto__ || Object.getPrototypeOf(Dispose)).call(this, \"dispose\", timing, source));\n    }\n\n    return Dispose;\n}(Event);\n\nexports.Dispose = Dispose;\n\n/***/ }),\n\n/***/ 4:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n\n/***/ 5:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar ObservableTree = function () {\n    function ObservableTree(id, name, logger, scheduler) {\n        _classCallCheck(this, ObservableTree);\n\n        this.id = id;\n        this.scheduler = scheduler;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"observable\", scheduler && Object.assign({}, scheduler));\n            logger.addMeta(id, { names: name });\n        }\n    }\n\n    _createClass(ObservableTree, [{\n        key: \"setSources\",\n        value: function setSources(sources) {\n            var _this = this;\n\n            this.sources = sources;\n            if (this.logger) {\n                sources.forEach(function (s) {\n                    return _this.logger.addEdge(s.id, _this.id, \"addSource\", { label: \"source\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(meta) {\n            if (this.logger) {\n                this.logger.addMeta(this.id, meta);\n            }\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth < 100) {\n                return \"ObservableTree(\" + this.id + \", \" + this.names + \", \" + (this.sources || []).map(function (s) {\n                    return pad(_inspect(s, depth + 2, opts), 2);\n                }) + \")\";\n            }\n        }\n    }]);\n\n    return ObservableTree;\n}();\n\nexports.ObservableTree = ObservableTree;\n\nvar ObserverTree = function () {\n    function ObserverTree(id, name, logger) {\n        _classCallCheck(this, ObserverTree);\n\n        this.events = [];\n        this.id = id;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"observer\");\n            logger.addMeta(id, { names: name });\n        }\n    }\n\n    _createClass(ObserverTree, [{\n        key: \"setSink\",\n        value: function setSink(sinks) {\n            var _this2 = this;\n\n            if (this.sink === sinks[0]) {\n                return this;\n            }\n            this.sink = sinks[0];\n            sinks.forEach(function (s) {\n                return s.addInflow(_this2);\n            });\n            if (this.logger) {\n                sinks.forEach(function (s) {\n                    return _this2.logger.addEdge(_this2.id, s.id, \"addObserverDestination\", { label: \"destination\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"setOuter\",\n        value: function setOuter(outer) {\n            this.outer = outer;\n            outer.addInflow(this);\n            if (this.logger) {\n                this.logger.addEdge(this.id, outer.id, \"addObserverOuter\", { label: \"outer\" });\n            }\n            return this;\n        }\n    }, {\n        key: \"addInflow\",\n        value: function addInflow(inflow) {\n            this.inflow = this.inflow || [];\n            if (this.inflow.indexOf(inflow) >= 0) {\n                return this;\n            }\n            this.inflow.push(inflow);\n            return this;\n        }\n    }, {\n        key: \"setObservable\",\n        value: function setObservable(observable) {\n            var _this3 = this;\n\n            if (this.observable) {\n                if (this.observable !== observable[0]) {\n                    console.log(\"Adding second observable to \", this);\n                    console.log(\"becoming\", observable);\n                    console.log(\"was\", this.observable);\n                    console.log(new Error().stack.split(\"\\n\").filter(function (l) {\n                        return l.indexOf(\"instrumentation.ts\") < 0;\n                    }).slice(0, 5).join(\"\\n\"));\n                } else {\n                    return this;\n                }\n            }\n            this.observable = observable[0];\n            if (this.logger) {\n                observable.forEach(function (o) {\n                    return _this3.logger.addEdge(o.id, _this3.id, \"setObserverSource\", { label: \"observable\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"addEvent\",\n        value: function addEvent(event) {\n            if (this.logger) {\n                this.logger.addMeta(this.id, { events: event });\n            }\n            this.events.push(event);\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth > 30) {\n                return \"depth 30 reached\";\n            }\n            if (this.sink) {\n                return \"ObserverTree(\" + this.id + \", \" + this.names + \", \\n\" + pad(_inspect(this.sink, depth + 1, opts), 1) + \"\\n)\";\n            } else {\n                return \"ObserverTree(\" + this.id + \", \" + this.names + \")\";\n            }\n        }\n    }]);\n\n    return ObserverTree;\n}();\n\nexports.ObserverTree = ObserverTree;\nfunction pad(str, depth) {\n    if (depth <= 0 || !str) {\n        return str;\n    }\n    return pad(str.split(\"\\n\").map(function (l) {\n        return \"  \" + l;\n    }).join(\"\\n\"), depth - 1);\n}\nfunction _inspect(i, depth, opts) {\n    if (i && i.inspect) {\n        return i.inspect(depth, opts);\n    } else if (i && i.toString) {\n        return i.toString();\n    } else {\n        return i;\n    }\n}\n\nvar SubjectTree = function () {\n    function SubjectTree(id, name, logger, scheduler) {\n        _classCallCheck(this, SubjectTree);\n\n        this.events = [];\n        this.id = id;\n        this.scheduler = scheduler;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"subject\", scheduler && Object.assign({}, scheduler));\n            logger.addMeta(id, { names: name });\n        }\n        this.observable = this;\n    }\n\n    _createClass(SubjectTree, [{\n        key: \"addSink\",\n        value: function addSink(sinks, name) {\n            var prev = this.sinks || [];\n            this.setSink(sinks, name);\n            this.sinks = prev.concat(sinks);\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth > 30) {\n                return \"Too deep\";\n            }\n            return \"SubjectTree(\" + this.id + \", \" + this.names + \", \\n\" + pad(_inspect(this.sink, depth + 2, opts), 2) + \"\\n)\";\n        }\n    }]);\n\n    return SubjectTree;\n}();\n\nexports.SubjectTree = SubjectTree;\napplyMixins(SubjectTree, [ObservableTree, ObserverTree]);\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {\n            // Only mix non-defined's, causing implemented methods to act as overloads. \n            // Allows mixin to have a specialized constructor for example.\n            if (typeof derivedCtor.prototype[name] === \"undefined\") {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\n\nvar SchedulerInfo = function SchedulerInfo(id, name, type, clock, logger) {\n    _classCallCheck(this, SchedulerInfo);\n\n    this.id = id;\n    this.name = name;\n    this.type = type;\n    this.clock = clock;\n    logger.addScheduler(this.id, this);\n};\n\nexports.SchedulerInfo = SchedulerInfo;\n\n/***/ }),\n\n/***/ 51:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar TreePoster = function () {\n    function TreePoster(cb) {\n        _classCallCheck(this, TreePoster);\n\n        if (typeof cb === \"function\") {\n            this.post = cb;\n        } else if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && window.parent) {\n            this.post = function (m) {\n                return window.parent.postMessage(m, window.location.origin);\n            };\n        } else {\n            this.post = function (m) {};\n            console.error(\"Using Window.postMessage logger in non-browser environment\", new Error());\n        }\n    }\n\n    _createClass(TreePoster, [{\n        key: \"addNode\",\n        value: function addNode(id, type, scheduler) {\n            this.post({ id: id, type: type, scheduler: scheduler });\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(id, meta) {\n            this.post({ id: id, meta: meta });\n        }\n    }, {\n        key: \"addEdge\",\n        value: function addEdge(v, w, type, meta) {\n            this.post({ v: v, w: w, type: type, meta: meta });\n        }\n    }, {\n        key: \"addScheduler\",\n        value: function addScheduler(id, scheduler) {\n            this.post({ id: id, scheduler: scheduler });\n        }\n    }, {\n        key: \"addContraction\",\n        value: function addContraction(id, nodes) {\n            this.post({ id: id, contract: nodes });\n        }\n    }, {\n        key: \"reset\",\n        value: function reset() {\n            this.post(\"reset\");\n        }\n    }]);\n\n    return TreePoster;\n}();\n\nexports.default = TreePoster;\n\n/***/ }),\n\n/***/ 7:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar Logger = function () {\n    // tslint:disable-next-line:no-constructor-vars\n    function Logger(post) {\n        _classCallCheck(this, Logger);\n\n        this.post = post;\n    }\n\n    _createClass(Logger, [{\n        key: \"addNode\",\n        value: function addNode(id, type, scheduler) {\n            this.post({ id: id, type: type, scheduler: scheduler });\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(id, meta) {\n            this.post({ id: id, meta: meta });\n        }\n    }, {\n        key: \"addEdge\",\n        value: function addEdge(v, w, type, meta) {\n            this.post({ v: v, w: w, type: type, meta: meta });\n        }\n    }, {\n        key: \"addScheduler\",\n        value: function addScheduler(id, scheduler) {\n            this.post({ id: id, scheduler: scheduler });\n        }\n    }, {\n        key: \"addContraction\",\n        value: function addContraction(id, nodes) {\n            this.post({ id: id, contract: nodes });\n        }\n    }, {\n        key: \"reset\",\n        value: function reset() {\n            this.post(\"reset\");\n        }\n    }]);\n\n    return Logger;\n}();\n\nexports.default = Logger;\nfunction formatObject(o) {\n    var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (o === null) {\n        return \"null\";\n    }\n    if (levels <= 0) {\n        return (o.constructor && o.constructor.name !== \"Object\" ? \"[\" + o.constructor.name + \"] \" : \"\") + \"{...}\";\n    }\n    var result = (o.constructor.name !== \"Object\" ? \"[\" + o.constructor.name + \"] \" : \"\") + \"{\";\n    var i = 0;\n    for (var key in o) {\n        if (o.hasOwnProperty(key) && key[0] !== \"_\") {\n            if (i > 0) {\n                result += \",\";\n            }\n            i++;\n            var padding = \"\";\n            for (var p = 0; p < depth; p++) {\n                padding += \"  \";\n            }\n            result += \"\\n\" + padding + \"\\\"\" + key + \"\\\": \" + _formatArguments([o[key]], levels - 1, depth + 1);\n        }\n    }\n    result += result[result.length - 1] === \"{\" ? \"}\" : \"\\n}\";\n    return result;\n}\nexports.formatObject = formatObject;\nfunction _formatArguments(args) {\n    var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    return [].map.call(args, function (a) {\n        switch (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) {\n            case \"undefined\":\n                return \"undefined\";\n            case \"object\":\n                if (Array.isArray(a)) {\n                    return \"[\" + _formatArguments(a, levels - 1, depth + 1) + \"]\";\n                } else {\n                    return formatObject(a, levels - 1, depth + 1);\n                }\n            case \"function\":\n                if (typeof a.__original === \"function\") {\n                    return a.__original.toString();\n                }\n                if (typeof a.__originalFunction === \"function\") {\n                    return a.__originalFunction.toString();\n                }\n                return a.toString();\n            case \"string\":\n                return \"\\\"\" + a.substring(0, 512) + \"\\\"\";\n            case \"boolean\":\n                return a.toString();\n            case \"number\":\n                return a;\n            default:\n                throw new TypeError(\"Invalid type \" + (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)));\n        }\n    }).join(\", \");\n}\nfunction formatArguments(args) {\n    return _formatArguments(args);\n}\nexports.formatArguments = formatArguments;\n\n/***/ }),\n\n/***/ 8:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* FlatMap extension of Array prototype */\nfunction flatMap(f) {\n    var _this = this;\n\n    return this.reduce(function (p, n, index) {\n        return p.concat(f(n, index, _this));\n    }, []);\n}\nexports.flatMap = flatMap;\nif (Object.defineProperty) {\n    Object.defineProperty(Array.prototype, \"flatMap\", {\n        configurable: false,\n        enumerable: false,\n        value: flatMap,\n        writable: false\n    });\n} else {\n    // Beware of dragons...\n    Array.prototype.flatMap = flatMap;\n}\n/* random */\nfunction endsWith(self, suffix) {\n    return self.indexOf(suffix, self.length - suffix.length) !== -1;\n}\nexports.endsWith = endsWith;\nfunction last(list) {\n    return list.length >= 1 ? list[list.length - 1] : undefined;\n}\nexports.last = last;\nfunction head(list) {\n    return list.length >= 1 ? list[0] : undefined;\n}\nexports.head = head;\nfunction getPrototype(input) {\n    return input.protoype || input.__proto__;\n}\nexports.getPrototype = getPrototype;\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// dist/worker-rx-4.1.0.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 129);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 299ce472bbf6fc5ab701","module.exports = Rx;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"Rx\"\n// module id = 1\n// module chunks = 0 1 2 3","let scheduler: Rx.TestScheduler = null\n\nlet _ = {\n  get next(): Function {\n    return Rx.ReactiveTest.onNext\n  },\n  get complete(): Function {\n    return Rx.ReactiveTest.onCompleted\n  }\n}\n\nlet experimentProto: any = {\n  get scheduler() {\n    if (scheduler === null) {\n      scheduler = new Rx.TestScheduler()\n      scheduler.advanceTo(0)\n    }\n    return scheduler\n  },\n  get bmi() {\n    return {\n      height$: this.scheduler.createHotObservable([1.76, 1.77, 1.78]\n        .map((v, i) => _.next(i * 100, v)).concat([_.complete(400)])),\n      weight$: this.scheduler.createHotObservable([70, 72, 76, 79, 78, 75]\n        .map((v, i) => _.next(i * 100, v)).concat([_.complete(700)])),\n    }\n  },\n  get lottery() {\n    let start = 2034\n    let year = 1000 * 3600 * 24 * 365.25\n    return {\n      newYear$: Rx.Observable\n        .interval(year, survey.scheduler)\n        .map(t => new Date(Date.UTC(t + start, 0, 1))),\n      veryOldServer: (date: string) => {\n        let unix = new Date(date).getTime() / 1000\n        if (unix > Math.pow(2, 31)) {\n          return Rx.Observable.throw(new Error(\"Crash!\"), this.scheduler)\n        } else {\n          return this.scheduler.createHotObservable(\n            _.next(0, { msg: \"calculating\" }),\n            _.next(10, { msg: \"Happy new year!\", winningTicket: Math.round(Math.random() * 10) }),\n            _.complete(20)\n          )\n        }\n      },\n    }\n  },\n  get imdb() {\n    let inputStream = (text: string) => {\n      let t = 0\n      let messages = []\n      // let random = new Array(11).fill(1).map(_ => Math.floor(Math.random() * 100))\n      let random = [21, 37, 69, 35, 8, 48, 99, 75, 32, 51, 52, 96, 55, 19, 14, 61, 89,\n        70, 44, 69, 21, 19, 87, 64, 52, 96, 12, 41, 33, 69, 28, 35, 23, 82, 94, 73, 79, 24,\n        15, 19, 22, 21, 48, 25, 64, 52, 59, 23, 8, 63, 97, 74, 18, 86, 97, 21, 64, 8, 66, 33,\n        0, 40, 53, 70, 72, 62, 54, 13, 88, 43, 94, 70, 96, 6, 91, 60, 77, 58, 12, 98, 8, 64,\n        96, 9, 28, 86, 45, 65, 94, 28, 55, 39, 34, 46, 2, 93, 17, 84, 3]\n      for (let i = 0; i <= text.length; i++) {\n        t += random.shift()\n        messages.push(_.next(t, text.slice(0, i)))\n      }\n      return this.scheduler.createHotObservable(...messages)\n    }\n    return {\n      _movies: [\n        \"Them\",\n        \"Lion King\",\n        \"Belle & The Beast\",\n        \"Avatar\",\n        \"Harry Potter\",\n        \"Guardians of the Galaxy\",\n        \"House of Cards\",\n        \"Spectre\",\n        \"Interstellar\",\n        \"Iron Man\",\n        \"Terminator Genisys\",\n        \"The Titanic\",\n        \"The Avengers\",\n      ],\n      findMoviesAsync: (term: string) => {\n        let result = this.imdb._movies.filter((movie: string) => movie.toLowerCase().indexOf(term.toLowerCase()) >= 0)\n        let t = 100 * result.length\n        return this.scheduler.createHotObservable(\n          _.next(t, result),\n          _.complete(t + 1)\n        )\n      },\n      inputStream,\n      johnsInput$: inputStream(\"the titanic\"),\n      render: () => { /* would append to DOM here */ },\n    }\n  },\n  get render() {\n    return () => { /* would append to DOM here */ }\n  },\n  get renderSomething() {\n    return () => { /* would append to DOM here */ }\n  },\n  get log() {\n    return () => { /* would write to console */ }\n  },\n  get showError() {\n    return () => { /* would display a warning here */ }\n  },\n  get noop() {\n    return () => { /* no operation */ }\n  },\n}\n\n// Make it global\ndeclare var experiment: any\ndeclare var survey: any\neval(\"var experiment = experimentProto\");\n(global as any).experiment = experimentProto;\neval(\"var survey = experimentProto\");\n(global as any).survey = experimentProto\n\n\n\n// WEBPACK FOOTER //\n// ./src/experiment/sample-data.ts","import { ICallRecord, ICallStart, callRecordType } from \"../../collector/callrecord\"\nimport { RxCollector, elvis, isDisposable, isObservable, isObserver, isScheduler } from \"../../collector/collector\"\nimport { Event, IEvent, Timing } from \"../../collector/event\"\nimport { formatArguments } from \"../../collector/logger\"\nimport {\n  IObservableTree, IObserverTree, ISchedulerInfo, ITreeLogger,\n  ObservableTree, ObserverTree, SchedulerInfo, SubjectTree,\n} from \"../../oct/oct\"\nimport { getPrototype } from \"../../prelude\"\nimport * as Rx from \"rx\"\nimport * as RxType from \"rx\"\n\nlet debug = false\n\nfunction getScheduler<T>(obs: Rx.Observable<T>, record?: ICallStart): Rx.IScheduler | undefined {\n  return (obs as any).scheduler ||\n    (obs as any)._scheduler ||\n    record && [].slice.call(record.arguments, -1).filter(isScheduler)[0]\n}\n\nclass SequenceTicker {\n  public last = 0\n  public used = false\n\n  public next(): void {\n    if (this.used) {\n      this.used = false\n      this.last++\n    }\n  }\n  public get(): number {\n    this.used = true\n    return this.last\n  }\n}\n\nexport class TreeCollector implements RxCollector {\n  public static collectorId = 0\n  public hash: string\n  public collectorId: number\n  public nextId = 1\n  public logger: ITreeLogger\n  private eventSequencer = new SequenceTicker()\n\n  private schedulers: { scheduler: Rx.IScheduler, info: ISchedulerInfo }[] = []\n  private scheduler?: { scheduler: Rx.IScheduler, info: ISchedulerInfo }\n\n  public constructor(logger: ITreeLogger, private Rx: typeof RxType) {\n    this.collectorId = TreeCollector.collectorId++\n    this.hash = this.collectorId ? `__thash${this.collectorId}` : \"__thash\"\n    this.logger = logger\n  }\n\n  /**\n   * Used to wrap arguments of higher order functions. Consider:\n   *   \n   *   let a = Rx.Observable.just(1)\n   *   a.flatMap((nr) => Rx.Observable.of(nr, nr * 2, nr * 3))\n   * \n   * now wrapHigherOrder is called like this:\n   * \n   *   wrapHigherOrder(a, (nr) => Rx.Observable.of(nr, nr * 2, nr * 3))\n   * \n   * so we can inject a custom function which can link the result of the lambda to `a`.\n   * \n   * @param subject observable to link to\n   * @param fn function (or any other argument) to wrap\n   */\n  public wrapHigherOrder(call: ICallRecord, fn: Function | any): Function | any {\n    let self = this\n    if (typeof fn === \"function\" && isObservable(call.subject)) {\n      function replacementLambda() {\n        let result = fn.apply(this, arguments)\n        if (typeof result === \"object\" && isObservable(result)) {\n          return self.observableWrapper(result, call.subject, () => call.returned)\n        }\n        return result\n      }\n      (replacementLambda as any).__original = fn\n      return replacementLambda\n    }\n    return fn\n  }\n\n  public schedule(scheduler: Rx.IScheduler, method: string, action: Function, state: any): Function | undefined {\n    let info = this.tag(scheduler)\n    let self = this\n    if (method.startsWith(\"schedule\") && method !== \"scheduleRequired\") {\n      // tslint:disable-next-line:only-arrow-functions\n      return function () {\n        let justAssigned = self.scheduler = { scheduler, info: info as ISchedulerInfo }\n        self.eventSequencer.next()\n        let result = action.apply(this, arguments)\n        if (self.scheduler === justAssigned) {\n          self.scheduler = undefined\n        }\n        return result\n      }\n    }\n  }\n\n  public before(record: ICallStart, parents?: ICallStart[]): this {\n    switch (callRecordType(record)) {\n      case \"subscribe\":\n        let obs = this.tagObservable(record.subject);\n        [].slice.call(record.arguments, 0, 1)\n          .filter(isObserver)\n          .map((s: Rx.Observer<any>) => {\n            record.arguments[0] = this.subscriptionWrapper(record.arguments[0], this.tagObserver(s, record)[0])\n            return s\n          })\n          .flatMap((s: any) => this.tagObserver(s, record)).forEach((sub: any) => {\n            obs.forEach(observable => {\n              if (observable instanceof SubjectTree) {\n                // Special case for subjects\n                observable.addSink(([sub]), \" subject\")\n                sub.setObservable([observable])\n              } else if (observable instanceof ObservableTree) {\n                sub.setObservable([observable])\n              }\n            })\n          })\n        break\n      case \"setup\":\n        this.tagObservable(record.subject)\n      default: break\n    }\n    return this\n  }\n\n  public getEventReason(record: ICallStart): string | undefined {\n    return [record.parent, record.parent && record.parent.parent]\n      .filter(r => r && isObserver(r.subject) && this.hasTag(r.subject))\n      .map(r => this.tag(r.subject).id)[0]\n  }\n\n  public addEvent(observer: IObserverTree, event: IEvent, value?: any) {\n    if (typeof event === \"undefined\") { return }\n\n    // Enrich higher order events\n    if (event.type === \"next\" && isObservable(value)) {\n      event.value = {\n        id: this.tag(value).id,\n        type: value.constructor.name,\n      } as any as string\n    }\n\n    // Ignore 2nd subscribe (subscribe & _subscribe are instrumented both)\n    if (observer.events.length === 1 && observer.events[0].type === \"subscribe\" && event.type === \"subscribe\") {\n      return\n    }\n\n    if (!observer.inflow || observer.inflow.length === 0) {\n      this.eventSequencer.next()\n    }\n\n    event.timing = this.getTiming()\n    observer.addEvent(event)\n  }\n\n  public after(record: ICallRecord): void {\n    switch (callRecordType(record)) {\n      case \"subscribe\":\n        if (isDisposable(record.returned)) {\n          record.returned = this.disposableWrapper(record.returned, record.arguments[0])\n        }\n        break\n      case \"setup\":\n        this.tagObservable(record.returned, record)\n      default: break\n    }\n  }\n\n  private hasTag(input: any): boolean {\n    return typeof input === \"object\" && input !== null && typeof (input as any)[this.hash] !== \"undefined\"\n  }\n\n  private tag(input: any, record?: ICallStart): IObserverTree | IObservableTree | ISchedulerInfo | undefined {\n    let tree: IObserverTree | IObservableTree\n    if (typeof input === \"undefined\") {\n      return undefined\n    }\n    if (typeof (input as any)[this.hash] !== \"undefined\") {\n      return (input as any)[this.hash]\n    }\n\n    if (isObserver(input) && isObservable(input)) {\n      (input as any)[this.hash] = tree = new SubjectTree(`${this.nextId++}`,\n        input.constructor.name, this.logger, this.getScheduler(input))\n      return tree\n    }\n    if (isObservable(input)) {\n      (input as any)[this.hash] = tree = new ObservableTree(`${this.nextId++}`,\n        input.constructor.name, this.logger, this.getScheduler(input, record)\n      )\n      return tree\n    }\n    if (isObserver(input)) {\n      (input as any)[this.hash] = tree = new ObserverTree(`${this.nextId++}`,\n        input.constructor.name, this.logger)\n      return tree\n    }\n    if (isScheduler(input)) {\n      let scheduler = input as Rx.IScheduler\n      let type: \"immediate\" | \"recursive\" | \"timeout\" | \"virtual\"\n      switch (getPrototype(scheduler).constructor.name) {\n        case \"ImmediateScheduler\":\n          type = \"immediate\"\n          break\n        case \"DefaultScheduler\":\n          type = \"timeout\"\n          break\n        case \"CurrentThreadScheduler\":\n          type = \"recursive\"\n          break\n        case \"TestScheduler\":\n          type = \"virtual\"\n          break\n        default:\n          if (debug) { console.debug(\"unknown scheduler type\", getPrototype(scheduler).constructor.name) }\n          type = \"virtual\"\n          break\n      }\n      let clock = scheduler.now()\n      let info = new SchedulerInfo(\n        `${this.nextId++}`, getPrototype(scheduler).constructor.name,\n        type, clock, this.logger\n      );\n      (input as any)[this.hash] = info\n      this.schedulers.push({ scheduler, info })\n      return info\n    }\n  }\n\n  private getScheduler(input: Rx.Observable<any>, record?: ICallStart): ISchedulerInfo {\n    if (isObservable(input) && getScheduler(input, record)) {\n      return this.tag(getScheduler(input, record)) as ISchedulerInfo\n    }\n  }\n\n  private getTiming(): Timing {\n    let clocks: { [id: string]: number } = { tick: this.eventSequencer.get() }\n    if (this.scheduler) {\n      clocks[this.scheduler.info.id] = this.scheduler.scheduler.now()\n      return Object.assign({\n        scheduler: this.scheduler.info.id,\n        clocks,\n      })\n    }\n    return {\n      clocks,\n      scheduler: \"tick\",\n    }\n  }\n\n  private tagObserver(input: any, record?: ICallStart, traverse: boolean = true): IObserverTree[] {\n    if (isObserver(input)) {\n\n      // Rx specific: unfold AutoDetachObserver's, \n      while (traverse && input && input.constructor.name === \"AutoDetachObserver\" && input.observer) {\n        input = input.observer\n      }\n\n      let tree = this.tag(input) as IObserverTree\n\n      // Find sink\n      let sinks = this.getSink(input, record)\n      sinks.forEach(([how, sink]) => {\n        tree.setSink([this.tag(sink) as IObserverTree])\n      })\n\n      return [tree]\n    }\n    return []\n  }\n\n  private getSink<T>(input: Rx.Observer<T>, record?: ICallStart): [string, Rx.Observer<T>][] {\n    // Rx specific: InnerObservers have references to their sinks via a AutoDetachObserver\n    let list = elvis(input, [\"o\", \"observer\"]) // InnerObservers\n      .concat(elvis(input, [\"_o\", \"observer\"])) // InnerObservers\n      .concat(elvis(input, [\"parent\"])) // what was this again?\n      .concat(elvis(input, [\"_s\", \"o\"])) // ConcatObserver\n      .concat(elvis(input, [\"observer\"])) // ConcatObserver\n      .map(s => [\" via o.observer\", s])\n    // If no sinks could be found via object attributes, try to find it via the call stack\n    if (record && !list.length && callStackDepth(record) > 2 && !(isObservable(input) && isObserver(input))) {\n      list.push(...sequenceUnique(\n        _ => _.sub,\n        generate(record, _ => _.parent)\n          .map(rec => ({\n            sub: rec.arguments[0] as Rx.Observer<T>,\n          }))\n          .filter(_ => isObserver(_.sub) && _.sub !== input)\n      ).slice(1, 2).map(_ => [\" via callstack\", _.sub]))\n    }\n\n    return list.slice(0, 1).flatMap(([how, sink]: [string, Rx.Observer<T>]) => {\n      if (sink.constructor.name === \"AutoDetachObserver\") {\n        return this.getSink(sink)\n      } else {\n        return [[how, sink] as [string, Rx.Observer<T>]]\n      }\n    })\n  }\n\n  private tagObservable(input: any, callRecord?: ICallStart): IObservableTree[] {\n    if (isObservable(input)) {\n      let wasTagged = this.hasTag(input)\n      let tree = this.tag(input, callRecord) as IObservableTree\n      if (!wasTagged) {\n        /* TODO find other way: this is a shortcut to prevent MulticastObservable._fn1 to show up */\n        if (callRecord && callRecord.method[0] !== \"_\") {\n          while (callRecord && isObservable((callRecord as ICallRecord).returned) && callRecord.method[0] !== \"_\") {\n            tree.addMeta({\n              calls: {\n                subject: `callRecord.subjectName ${this.hasTag(callRecord.subject) && this.tag(callRecord.subject).id}`,\n                args: formatArguments(callRecord.arguments),\n                method: callRecord.method,\n              },\n            })\n\n            // if (typeof callRecord.parent !== \"undefined\" && isObservable(callRecord.parent.subject)) {\n            callRecord = callRecord.parent\n            // } else {\n            //   callRecord = undefined\n            // }\n          }\n        }\n        if ((input as any).source) {\n          tree.setSources(this.tagObservable((input as any).source))\n        } else if ((input as any)._sources) {\n          tree.setSources((input as any)._sources.flatMap((s: any) => this.tagObservable(s)))\n        }\n      }\n      if (getScheduler(input)) {\n        this.tag(getScheduler(input))\n      }\n      return [tree]\n    }\n    return []\n  }\n\n  private observableWrapper<T, R>(target: T, context: Rx.Observable<R>, outerContext: () => Rx.Observable<R>): T {\n    function subscribe() {\n      if (debug) {\n        console.debug(\"Wrap this higher order subscribe method\\n\",\n          target.constructor.name,\n          context.constructor.name,\n          outerContext().constructor.name)\n      }\n      let result = (target as any).subscribe.apply(target, arguments)\n      return result\n    }\n    return new Proxy(target, {\n      get: (obj: any, name: string) => {\n        if (name === \"isScoped\") { return true }\n        if (name === \"subscribe\" && \"subscribe\" in target) {\n          return subscribe\n        }\n        return obj[name]\n      },\n    })\n  }\n\n  // Wrap this around a Subscription to log onNext, onError, onComplete, dispose calls\n  private subscriptionWrapper<T>(target: Rx.Observer<T>, tree: IObserverTree) {\n    if ((target as any).__isSubscriptionWrapper) {\n      return target\n    }\n    // Ensure only one single Proxy is attached to the IObserverTree\n    if ((tree as any).proxy) {\n      return target\n    }\n    let collector = this\n    let events = [\"onNext\", \"onError\", \"onCompleted\", \"dispose\"]\n    tree.addEvent(Event.fromCall(\"subscribe\", undefined, this.getTiming()))\n    let proxy = new Proxy(target, {\n      get: (obj: any, name: string) => {\n        let original = obj[name]\n        if (name === \"__isSubscriptionWrapper\") { return true }\n        if (typeof original === \"function\" && events.indexOf(name) >= 0) {\n          function proxy() {\n            collector.addEvent(tree, Event.fromCall(name, [].slice.call(arguments, 0), undefined), arguments[0])\n            return original.apply(this, arguments)\n          }\n          return proxy\n        }\n        return original\n      },\n    });\n    (tree as any).proxy = proxy\n    return proxy\n  }\n\n  // Wrap this around a Disposable to log dispose calls onto the supplied observer\n  private disposableWrapper<T>(target: Rx.Disposable, observer?: any) {\n    if ((target as any).__isDisposableWrapper) {\n      return target\n    }\n    let tree: IObserverTree[] = isObserver(observer) ? this.tagObserver(observer) : []\n    let collector = this\n    return new Proxy(target, {\n      get: (obj: any, name: string) => {\n        let original = obj[name]\n        if (name === \"__isDisposableWrapper\") { return true }\n        if (typeof original === \"function\" && name === \"dispose\") {\n          function proxy() {\n            collector.addEvent(tree[0], Event.fromCall(name, [].slice.call(arguments, 0), undefined))\n            return original.apply(this, arguments)\n          }\n          return proxy\n        }\n        return original\n      },\n    })\n  }\n\n}\n\nfunction callStackDepth(record: ICallStart): number {\n  return typeof record.parent === \"undefined\" ? 1 : 1 + callStackDepth(record.parent)\n}\n\nfunction generate<T>(seed: T, next: (acc: T) => T | undefined | null): T[] {\n  if (typeof seed === \"undefined\" || seed === null) {\n    return []\n  } else {\n    return [seed, ...generate(next(seed), next)]\n  }\n}\n\nfunction sequenceUnique<T, K>(keySelector: (e: T) => K, list: T[]): T[] {\n  let filtered = [] as T[]\n  for (let v of list) {\n    if (filtered.length === 0 || keySelector(filtered[filtered.length - 1]) !== keySelector(v)) {\n      filtered.push(v)\n    }\n  }\n  return filtered\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-4.1.0/collector.ts","export type ToWorkerMessage = { type: \"run\", code: string } | { type: \"importScripts\", url: string }\n\nfunction formatError(e: Error): any {\n  return {\n    message: e.message,\n    name: e.name,\n    original: typeof (e as any).original !== \"undefined\" ? formatError((e as any).original) : undefined,\n    stack: e.stack.toString(),\n  }\n}\n\nlet scope = {}\n\n/** \n * Have single location for evil eval,\n * so we can infer it's stackTrace beforehand \n * and strip that from the errors coming from it \n */\nfunction scopedEval(code: string) {\n  // tslint:disable-next-line:only-arrow-functions\n  (function () {\n    // tslint:disable-next-line:no-eval\n    return eval(code)\n  }).call(scope)\n}\n\nfunction evalAndRepackageErrors(code: string): { type: \"result\", result: any } | { type: \"error\", error: any } {\n  try {\n    return { result: scopedEval(code), type: \"result\" }\n  } catch (e) {\n    // Infer eval location\n    try {\n      scopedEval(\"throw new Error('ERROR')\")\n    } catch (dummyError) {\n      // clean up error stack trace\n      let result = /\\n\\s+at Object.<anonymous> \\((.*)\\)/.exec(dummyError.stack)\n      if (result === null) {\n        return { error: e.stack, type: \"error\" }\n      }\n      let stack: string = e.stack.toString()\n      let index = stack.lastIndexOf(`at Object.<anonymous> (${result[1]})`)\n      stack = stack.substring(0, index)\n      stack = stack.split(`eval at <anonymous> (${result[1]}), `).join(\"\")\n      e.stack = stack\n    }\n    return { error: formatError(e), type: \"error\" }\n  }\n}\n\nexport function onWorkerMessage(instrument: () => void): ((e: MessageEvent) => void) {\n  return (e: MessageEvent) => {\n    let message = e.data as ToWorkerMessage\n    switch (message.type) {\n      case \"importScripts\":\n        importScripts(message.url)\n        instrument()\n        break\n      case \"run\":\n        // Execute user code\n        let result = evalAndRepackageErrors(message.code)\n        if (result.type === \"error\") {\n          (postMessage as (m: any) => void)({\n            error: result.error,\n            type: \"error\",\n          })\n        }\n        break\n      default: break\n    }\n  }\n}\n\nif (typeof postMessage === \"function\") {\n  (postMessage as Function)(\"ready\")\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/worker-utils.ts","import { ICallRecord, ICallStart } from \"../../collector/callrecord\"\nimport { RxCollector } from \"../../collector/collector\"\nimport \"../../utils\"\nimport * as Rx from \"rx\"\n\nconst rxAny: any = Rx as any\n\nexport let defaultSubjects = (rxAny: any) => ({\n  Observable: Rx.Observable,\n  \"Observable.prototype\": rxAny.Observable.prototype,\n  \"ConnectableObservable.prototype\": rxAny.ConnectableObservable.prototype,\n  \"ObservableBase.prototype\": rxAny.ObservableBase.prototype,\n  // \"AbstractObserver.prototype\": rxAny.internals.AbstractObserver.prototype,\n  // \"AnonymousObserver.prototype\": rxAny.AnonymousObserver.prototype,\n  \"Subject.prototype\": rxAny.Subject.prototype,\n})\n\nexport let defaultSchedulerFactory: { [key: string]: any } = Object.keys(Rx.Scheduler)\n  .filter(name => typeof (Rx.Scheduler as any)[name] === \"object\")\n  .filter(name => (Rx.Scheduler as any)[name].__proto__.constructor.name.indexOf(\"Scheduler\") >= 0)\n  .reduce((p, name) => {\n    p[name] = (Rx.Scheduler as any)[name]\n    return p\n  }, {} as any)\n\nexport const HASH = \"__hash\"\nexport const IGNORE = \"__ignore\"\n\nfunction now() {\n  return typeof performance !== \"undefined\" ? performance.now() : new Date().getTime()\n}\n\n/* tslint:disable:interface-name */\nexport interface Function {\n  caller?: Function\n  __originalFunction?: Function | null\n  apply(subject: any, args: any[] | IArguments): any\n}\n\nfunction hasRxObservablePrototype(input: any): boolean {\n  return typeof input === \"object\" && rxAny.Observable.prototype.isPrototypeOf(input)\n}\n\nfunction startsWith(input: string, matcher: string) {\n\n  let r = input.substr(0, matcher.length) === matcher\n  return r\n}\n\nfunction detachedScopeProxy<T>(input: T): T {\n  let hashes: { [id: string]: number } = {}\n  if ((input as any).__detached === true) {\n    return input\n  }\n  return new Proxy(input, {\n    get: (target: any, property: PropertyKey): any => {\n      if (property === \"__detached\") {\n        return true\n      }\n      if (typeof property === \"string\" && startsWith(property, \"__hash\")) {\n        return hashes[property]\n      }\n      return (target as any)[property]\n    },\n    set: (target, property, value): boolean => {\n      if (typeof property === \"string\" && startsWith(property, \"__hash\")) {\n        hashes[property] = value\n      }\n      return true\n    },\n  })\n}\n\n/**\n * Tweaks specific for RxJS 4\n */\nfunction rxTweaks<T>(call: ICallStart): void {\n  // Detach reuse of NeverObservable\n  let fields: [any, PropertyKey][] = []\n  fields.push([call, \"subject\"], [call, \"returned\"])\n  fields.push(...[].map.call(call.arguments, (a: any, i: number) => [call.arguments, i]))\n  fields.forEach(([subject, prop]) => {\n    if (\n      typeof subject[prop] !== \"undefined\" && subject[prop] !== null &&\n      subject[prop].constructor.name === \"NeverObservable\"\n    ) {\n      subject[prop] = detachedScopeProxy(subject[prop])\n    }\n  })\n  // Other tweaks here...\n}\n\n// class Ticker {\n//   private tick: number = 0\n//   private timeout?: Rx.IDisposable\n//   private next: () => void\n//   constructor() {\n//     this.next = this.nextTick.bind(this)\n//   }\n//   public get() {\n//     if (!this.timeout) {\n//       this.timeout = Rx.Scheduler.currentThread.schedule({}, () => { this.next(); return Rx.Disposable.empty })\n//       // this.timeout = setTimeout(this.next, 0)\n//     }\n//     return this.tick\n//   }\n//   private nextTick() {\n//     this.tick++\n//     this.timeout = undefined\n//   }\n// }\n\n// let ticker = new Ticker()\n\nexport function getPrototype(input: any): any {\n  return input.prototype || input.__proto__\n}\n\nlet i = 0\n\nexport default class Instrumentation {\n  public logger: RxCollector\n  public open: any[] = []\n  public stackTraces: boolean = true\n\n  private subjects: { [name: string]: any; }\n  private calls: (ICallStart | ICallRecord)[] = []\n\n  private prototypes: any[] = []\n\n  constructor(subjects: { [name: string]: any; } = defaultSubjects, logger: RxCollector) {\n    this.subjects = subjects\n    this.logger = logger\n    Object.keys(subjects).slice(0, 1).forEach((s: string) => subjects[s][IGNORE] = true)\n  }\n\n  public isInstrumented(fn: Function, by?: Instrumentation): boolean {\n    if (typeof by === \"undefined\") {\n      return ((\n        typeof fn.__originalFunction === \"function\" ?\n          1 + (this.isInstrumented(fn.__originalFunction) as any) as number :\n          0)\n      ) as any as boolean\n    }\n    if ((fn as any).__instrumentedBy === by) { return true }\n    let orig = (fn as any).__originalFunction\n    return typeof orig === \"function\" && this.isInstrumented(orig, by)\n  }\n\n  /* tslint:disable:only-arrow-functions */\n  /* tslint:disable:no-string-literal */\n  /* tslint:disable:no-string-literal */\n  public instrument(fn: Function, extras: { [key: string]: string; }): Function {\n    let calls = this.calls\n    let logger = this.logger\n    let open = this.open\n    let self = this\n\n    let instrumented = new Proxy(fn, {\n      apply: (target: any, thisArg: any, argumentsList: any[]) => {\n        // console.log(target.caller)\n\n        // find more\n        argumentsList\n          .filter(hasRxObservablePrototype)\n          .filter((v: any) => !this.isInstrumented(v))\n          .forEach((t: any) => this.setupPrototype(t))\n\n        let call: ICallStart = {\n          arguments: [].slice.call(argumentsList, 0),\n          childs: [],\n          id: i++,\n          method: extras[\"methodName\"],\n          stack: self.stackTraces ? undefined : undefined, // new Error().stack : undefined,\n          subject: thisArg,\n          subjectName: extras[\"subjectName\"],\n          tick: 0, // ticker.get(),\n          time: now(),\n        }\n\n        // Prepare\n        calls.push(call)\n        if (open.length > 0) {\n          call.parent = open[open.length - 1]\n          call.parent.childs.push(call)\n        }\n        open.push(call)\n\n        // Nicen up Rx performance tweaks\n        rxTweaks(call)\n\n        // Actual method\n        let instanceLogger = logger.before(call, open.slice(0, -1))\n        let returned = target.apply(call.subject, [].map.call(\n          call.arguments,\n          instanceLogger.wrapHigherOrder.bind(instanceLogger, call))\n        )\n\n        let end: ICallRecord = call as ICallRecord\n        end.returned = returned\n\n        // Nicen up Rx performance tweaks\n        rxTweaks(end)\n\n        instanceLogger.after(end);\n\n        // find more\n        ([end.returned])\n          .filter(hasRxObservablePrototype)\n          .filter((v: any) => !this.isInstrumented(v))\n          .forEach((t: any) => this.setupPrototype(t))\n\n        // Cleanup\n        open.pop()\n        return end.returned\n      },\n      construct: (target: { new (...args: any[]): any }, args) => {\n        console.warn(\"TODO, instrument constructor\", target, args)\n        return new target(...args)\n      },\n      get: (target: any, property: PropertyKey): any => {\n        if (property === \"__instrumentedBy\") { return self }\n        if (property === \"__originalFunction\") { return fn }\n        return (target as any)[property]\n      },\n    })\n    return instrumented\n  }\n\n  public deinstrument(fn: Function): Function {\n    return fn.__originalFunction && this.deinstrument(fn.__originalFunction) || fn\n  }\n  /* tslint:enable:only-arrow-functions */\n  /* tslint:enable:no-string-literal */\n  /* tslint:enable:no-string-literal */\n\n  public setup(): void {\n    // Observables\n    Object.keys(this.subjects)\n      .forEach(name => this.setupPrototype(this.subjects[name], name))\n\n    // Subjects\n    rxAny.Subject = this.instrument(rxAny.Subject, {\n      methodName: \"new\",\n      subjectName: \"Rx.Subject\",\n    })\n\n    // Schedulers\n    Object.keys(defaultSchedulerFactory)\n      .forEach(name => this.setupSchedulerMethods(defaultSchedulerFactory[name], name))\n    rxAny.TestScheduler = this.setupSchedulerPrototype(rxAny.TestScheduler, \"TestScheduler\")\n    this.prototypes.push(rxAny)\n  }\n\n  // Swap all methods\n  public setupSchedulerMethods(instance: any, name?: string) {\n    let self = this\n    this.prototypes.push(instance)\n    this.logger.schedule(instance, name, null, null)\n    let proto = getPrototype(instance)\n    this.prototypes.push(proto)\n    Object.keys(proto)\n      .filter(key => typeof instance[key] === \"function\")\n      .filter(key => !self.isInstrumented(instance[key], self))\n      .forEach(key => {\n        // if (self.isInstrumented(instance[key]) as any as number > 0) {\n        //   console.log(\"instrumented already\", self.isInstrumented(instance[key]), \"times\")\n        // }\n        let original = instance[key]\n\n        // instance[key] = function (state: any, action: any, time: number) {\n        //   self.logger.schedule(instance, key, action, { state, time })\n        //   return original.apply(instance, arguments)\n        // }\n\n        instance[key] = function (state: any, action: any, time: number) {\n          let args = [].slice.call(arguments, 0)\n          if (key === \"scheduleAbsolute\") {\n            console.log(\"Absolute scheduling\", args)\n            let newAction = self.logger.schedule(instance, key, args[2], { state: args[0], time: args[1] }) || action\n            if (typeof args[2] === \"function\" && typeof newAction === \"function\") { args[2] = newAction }\n            return original.apply(instance, args)\n          }\n          let newAction = self.logger.schedule(instance, key, action, { state, time }) || action\n          if (typeof action === \"function\" && typeof newAction === \"function\") { args[1] = newAction }\n          return original.apply(instance, args)\n        }\n\n        instance[key].__instrumentedBy = self\n        instance[key].__originalFunction = original\n      })\n  }\n\n  // Swap constructors\n  public setupSchedulerPrototype(schedulerPrototype: any, name?: string) {\n    let self = this\n    if (this.isInstrumented(schedulerPrototype, this)) {\n      return\n    }\n    return new Proxy(schedulerPrototype, {\n      construct: (target, argArray, newTarget) => {\n        let scheduler = new target(argArray)\n        self.setupSchedulerMethods(scheduler, name)\n        return scheduler\n      },\n      get: (target: any, property: PropertyKey): any => {\n        if (property === \"__instrumentedBy\") { return self }\n        if (property === \"__originalFunction\") { return schedulerPrototype }\n        return (target as any)[property]\n      },\n    })\n  }\n\n  public setupPrototype(prototype: any, name?: string) {\n    if (typeof name !== \"undefined\") {\n      prototype.__dynamicallyInstrumented = true\n    }\n    let methods = Object.keys(prototype)\n      .filter((key) => typeof prototype[key] === \"function\")\n\n    // log, preparing for teardown\n    this.prototypes.push(prototype)\n\n    methods.forEach(key => {\n      prototype[key] = this.instrument(prototype[key], {\n        methodName: key,\n        subjectName: name || prototype.constructor.name,\n      })\n    })\n\n    // let ctor = prototype.constructor\n    // prototype.constructor = function () {\n    //   console.log(\"ctor\", arguments)\n    //   let r = ctor.call(this, arguments)\n    //   return r\n    // }\n  }\n\n  public teardown(): void {\n    rxAny.Subject = this.deinstrument(rxAny.Subject)\n\n    let properties: { key: string, subject: any }[] = this.prototypes\n      .map(subject => Object.keys(subject).map(key => ({ key, subject })))\n      .reduce((prev, next) => prev.concat(next), [])\n\n    let methods = properties\n      .filter(({ key, subject }) => typeof subject[key] === \"function\")\n\n    // let i = 0\n    methods.forEach(({ key, subject }) => {\n      // i++\n      subject[key] = this.deinstrument(subject[key])\n    })\n\n    // let fails = this.prototypes\n    //   .map(subject => Object.keys(subject).map(key => ({ key, subject })))\n    //   .reduce((prev, next) => prev.concat(next), [])\n    //   .filter(({ key, subject }) => typeof subject[key] === \"function\")\n    //   .filter(({ key, subject }) => typeof subject[key].__originalFunction === \"function\").length\n\n    // console.log(\"Tore down\", i, \"methods, failures: \", fails)\n\n    this.prototypes = []\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-4.1.0/instrumentation.ts","importScripts(\"instrumentation/rxjs-4.1.0/rx.all.js\")\nimport TreePoster from \"../../collector/treePoster\"\nimport \"../../experiment/sample-data\"\nimport { onWorkerMessage } from \"../worker-utils\"\nimport { TreeCollector } from \"./collector\"\nimport Instrumentation, { defaultSubjects } from \"./instrumentation\"\n\nonmessage = onWorkerMessage(() => {\n  let poster = new TreePoster(m => (postMessage as (m: any) => void)(m))\n  let collector = new TreeCollector(poster, Rx)\n  let instrumentation: Instrumentation = new Instrumentation(defaultSubjects(Rx), collector)\n  instrumentation.setup()\n  console.info(\"Ready for RxJS 4 instrumentation\");\n  (Rx as any).version = \"4.1.0\"\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-4.1.0/worker.ts","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/base64-js/index.js","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/ieee754/index.js","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n// WEBPACK FOOTER //\n// ./~/isarray/index.js","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/node-libs-browser/~/buffer/index.js","import { ICallStart } from \"./callrecord\"\nimport { RxCollector } from \"./ICollector\"\nimport * as Rx from \"rx\"\n\ntype Group = {\n  call: ICallStart\n  id: number\n  used: boolean\n}\n\nexport function isObserver<T>(v: any): v is Rx.Observer<T> & any {\n  return typeof v === \"object\" && v !== null && typeof v.onNext === \"function\"\n}\n\nexport function isDisposable(v: any): v is Rx.Subscription & any {\n  return typeof v === \"object\" && v !== null && typeof v.dispose === \"function\"\n}\n\nexport function isObservable<T>(v: any): v is Rx.Observable<T> {\n  return typeof v === \"object\" && v !== null && typeof v.subscribe === \"function\"\n}\n\nexport function isScheduler(v: any): v is Rx.IScheduler & any {\n  return typeof v === \"object\" && v !== null && typeof v.now === \"function\" && typeof v.schedule === \"function\"\n}\n\nexport function elvis(item: any, path: string[]): any[] {\n  let next = typeof item === \"object\" && path.length && path[0] in item ? item[path[0]] : undefined\n  if (path.length > 1) {\n    return elvis(next, path.slice(1))\n  } else if (typeof next !== \"undefined\") {\n    return [next]\n  } else {\n    return []\n  }\n}\n\nexport { RxCollector }\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/collector.ts","import { StackFrame } from \"./stackframe\"\n\nexport type ICallRecord = ICallStart & ICallEnd\n\nexport interface ICallStart {\n  id: number | string | null\n  subject: any\n  subjectName: string\n  method: string\n  arguments: any[]\n  stack?: StackFrame | string\n  time: number\n  parent?: ICallStart\n  childs: (ICallRecord | ICallStart)[]\n  tick: number\n}\n\nexport interface ICallEnd {\n  returned: any | null\n}\n\ntype CallRecordType = \"setup\" | \"subscribe\" | \"event\"\n\nexport function callRecordType(record: ICallStart) {\n  if (typeof record === \"undefined\" || typeof record.subject === \"undefined\") {\n    return undefined\n  }\n  if (record.subjectName === \"Observable\" ||\n    record.subjectName === \"Observable.prototype\" ||\n    record.subjectName === \"ObservableBase.prototype\" ||\n    record.subjectName &&\n    record.subjectName.indexOf(\"Observable\") >= 0\n  ) {\n    if (record.method === \"subscribe\" ||\n      record.method === \"_subscribe\" ||\n      record.method === \"__subscribe\" ||\n      record.method === \"_trySubscribe\"\n    ) {\n      return \"subscribe\"\n    }\n    return \"setup\"\n  } else {\n    return \"event\"\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/callrecord.ts","/* tslint:disable:no-namespace */\n/* tslint:disable:interface-name */\n\n// ucs-2 string to base64 encoded ascii\nexport function utoa(str: string) {\n  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n    return String.fromCharCode(\"0x\" + p1 as any)\n  }))\n}\n// base64 encoded ascii to ucs-2 string\nexport function atou(str: string) {\n  return decodeURIComponent(Array.prototype.map.call(atob(str), (c: string) => {\n    return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(\"\"))\n}\n\nexport declare let btoa: (inp: string) => string\nif (typeof btoa !== \"function\") {\n  btoa = function node_btoa(str: any) {\n    let buffer\n    if (str instanceof Buffer) {\n      buffer = str\n    } else {\n      buffer = new Buffer(str.toString(), \"binary\")\n    }\n    return buffer.toString(\"base64\")\n  }\n}\n\nexport declare let atob: (inp: string) => string\nif (typeof atob !== \"function\") {\n  atob = function node_atob(str: string) {\n    return new Buffer(str, \"base64\").toString(\"binary\")\n  }\n}\n\n/* Extension of Rx */\ndeclare global {\n  namespace Rx {\n    interface Observable<T> { }\n    interface Observer<T> {\n      source?: Observable<any>\n      o?: Observer<any>\n    }\n    interface ObservableStatic {\n      prototype: any\n    }\n    interface IScheduler { }\n    interface Subscription { }\n  }\n}\n\ninterface ObservableStatic {\n  prototype: any\n}\n\n/* Get name of function */\nexport function getName(this: Function) {\n  let funcNameRegex = /function (.{1,})\\(/\n  let results = (funcNameRegex).exec((this).constructor.toString())\n  return (results && results.length > 1) ? results[1] : \"\"\n}\n\nexport function UUID() {\n  /** UUID generator: http://stackoverflow.com/a/2117523/552203 */\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    // tslint:disable:no-bitwise\n    let r = Math.random() * 16 | 0\n    let v = c === \"x\" ? r : (r & 0x3 | 0x8)\n    return v.toString(16)\n    // tslint:enable:no-bitwise\n  })\n}\n\ndeclare module \"graphlib\" {\n  interface Graph {\n    // new (options: { compound?: boolean, multigraph?: boolean }): Graph\n    // height: number\n    // width: number\n    graph(): {\n      width: number, height: number,\n      ranker: \"network-simplex\" | \"tight-tree\" | \"longest-path\"\n      rankdir: \"TB\" | \"BT\" | \"LR\" | \"RL\"\n    }\n    filterNodes(filter: (node: string) => boolean): Graph\n    setGraph(g: {}): void\n    setDefaultEdgeLabel(callback: () => void): any\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.ts","// tslint:disable:no-constructor-vars\nimport { ICallStart } from \"./callrecord\"\nimport { formatArguments } from \"./logger\"\n\nexport type IEventType = \"next\" | \"error\" | \"complete\" | \"subscribe\" | \"dispose\" | \"connect\"\n\nexport type IEvent = Next<any> | Subscribe | Complete | Error | Dispose | Connect\n\nexport type Timing = {\n  scheduler: string\n  clocks: { [id: string]: number }\n}\n\nexport class Event {\n  public static fromRecord(record: ICallStart, timing: Timing, source?: string): IEvent | null {\n    return Event.fromCall(record.method, record.arguments, timing, source)\n  }\n  public static fromCall(method: string, args: any[], timing: Timing, source?: string): IEvent {\n    switch (method) {\n      case \"next\":\n      case \"onNext\":\n        return new Next(timing, args[0], source)\n      case \"error\":\n      case \"onError\":\n      case \"fail\":\n        return new Error(timing, new ErrorInstance(args[0]), source)\n      case \"complete\":\n      case \"onCompleted\":\n        return new Complete(timing, source)\n      case \"connect\":\n        return new Connect(timing, source)\n      case \"subscribe\":\n      case \"_subscribe\":\n      case \"__subscribe\":\n        return new Subscribe(timing, source)\n      case \"dispose\":\n      case \"unsubscribe\":\n        return new Dispose(timing, source)\n      default: break\n      // console.log(\"Unknown event\", record)\n    }\n  }\n  public static fromJson(input: any): IEvent | null {\n    switch (input.type) {\n      case \"next\": return new Next(input.timing, input.value, input.source)\n      case \"error\": return new Error(input.timing, input.error, input.source)\n      case \"complete\": return new Complete(input.timing, input.source)\n      case \"subscribe\": return new Subscribe(input.timing, input.source)\n      case \"dispose\": return new Dispose(input.timing, input.source)\n      default: return null\n    }\n  }\n  constructor(public type: IEventType, public timing: Timing, public source?: string) { }\n}\n\nexport class Next<T> extends Event {\n  public value: string\n  public type: \"next\"\n  constructor(timing: Timing, value: T, source?: string) {\n    super(\"next\", timing, source)\n    this.value = formatArguments([value])\n  }\n}\n\nexport class ErrorInstance {\n  public name: string\n  public message: string\n  public stack: string\n  public constructor(someError: SyntaxError) {\n    this.name = someError.name\n    this.message = someError.message\n    this.stack = someError.stack\n  }\n}\n\nexport class Error extends Event {\n  public error: ErrorInstance\n  public type: \"error\"\n  constructor(timing: Timing, error: ErrorInstance, source?: string) {\n    super(\"error\", timing, source)\n    this.error = error\n  }\n}\n\nexport class Complete extends Event {\n  public type: \"complete\"\n  constructor(timing: Timing, source?: string) { super(\"complete\", timing, source) }\n}\n\nexport class Subscribe extends Event {\n  public type: \"subscribe\"\n  constructor(timing: Timing, source?: string) { super(\"subscribe\", timing, source) }\n}\n\nexport class Connect extends Event {\n  public type: \"connect\"\n  constructor(timing: Timing, source?: string) { super(\"connect\", timing, source) }\n}\n\nexport class Dispose extends Event {\n  public type: \"dispose\"\n  constructor(timing: Timing, source?: string) { super(\"dispose\", timing, source) }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/event.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","import { IEvent } from \"../collector/event\"\n\nexport type Id = string\n\nexport interface MethodCall {\n  method: string\n  args: IArguments\n}\n\nexport interface IObservableTree {\n  id: Id\n  names?: string[]\n  calls?: MethodCall[]\n  sources?: IObservableTree[]\n  scheduler?: ISchedulerInfo\n  setSources(sources: IObservableTree[]): IObservableTree\n  addMeta(meta: any): IObservableTree\n}\n\nexport interface IObserverTree {\n  id: Id\n  names?: string[]\n  observable: IObservableTree\n  sink?: IObserverTree\n  inflow?: IObserverTree[]\n  events: IEvent[]\n  setOuter(sinks: IObserverTree): IObserverTree\n  setSink(sinks: IObserverTree[]): IObserverTree\n  addInflow(inflow: IObserverTree): IObserverTree\n  setObservable(observable: IObservableTree[]): IObserverTree\n  addEvent(event: IEvent): IObserverTree\n}\n\n//                     O->O *-*    | O->S 1-1            | S->S *-*                \nexport type EdgeType = \"addSource\" | \"setObserverSource\" | \"addObserverDestination\" | \"addObserverOuter\"\nexport type NodeType = \"observable\" | \"subject\" | \"observer\"\n\nexport interface ITreeLogger {\n  addNode(id: Id, type: NodeType, timing?: ISchedulerInfo): void\n  addMeta(id: Id, meta: any): void\n  addEdge(v: Id, w: Id, type: EdgeType, meta?: any): void\n  addScheduler(id: Id, scheduler: ISchedulerInfo): void\n  addContraction(id: Id, nodes: Id[]): void\n}\n\nexport class ObservableTree implements IObservableTree {\n  public id: Id\n  public names?: string[]\n  public calls?: MethodCall[]\n  public sources?: IObservableTree[]\n  public scheduler?: ISchedulerInfo\n\n  public logger?: ITreeLogger\n  constructor(id: string, name?: string, logger?: ITreeLogger, scheduler?: ISchedulerInfo) {\n    this.id = id\n    this.scheduler = scheduler\n    if (name) { this.names = [name] }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"observable\", scheduler && Object.assign({}, scheduler))\n      logger.addMeta(id, { names: name })\n    }\n  }\n\n  public setSources(sources: IObservableTree[]): IObservableTree {\n    this.sources = sources\n    if (this.logger) {\n      sources.forEach(s => this.logger.addEdge(s.id, this.id, \"addSource\", { label: \"source\" }))\n    }\n    return this\n  }\n\n  public addMeta(meta: any): IObservableTree {\n    if (this.logger) {\n      this.logger.addMeta(this.id, meta)\n    }\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth < 100) {\n      return `ObservableTree(${this.id}, ${this.names}, ${\n        (this.sources || []).map(s => pad(inspect(s, depth + 2, opts), 2))\n        })`\n    }\n  }\n}\n\nexport class ObserverTree implements IObserverTree {\n  public id: Id\n  public names?: string[]\n  public observable: IObservableTree\n  public sink?: IObserverTree\n  public outer?: IObserverTree\n  public inflow?: IObserverTree[]\n  public events: IEvent[] = []\n  public scheduler?: ISchedulerInfo\n\n  public logger?: ITreeLogger\n  constructor(id: string, name?: string, logger?: ITreeLogger) {\n    this.id = id\n    if (name) { this.names = [name] }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"observer\")\n      logger.addMeta(id, { names: name })\n    }\n  }\n\n  public setSink(sinks: IObserverTree[]): IObserverTree {\n    if (this.sink === sinks[0]) {\n      return this\n    }\n    this.sink = sinks[0]\n    sinks.forEach(s => s.addInflow(this))\n    if (this.logger) {\n      sinks.forEach(s => this.logger.addEdge(this.id, s.id, \"addObserverDestination\", { label: \"destination\" }))\n    }\n    return this\n  }\n\n  public setOuter(outer: IObserverTree): IObserverTree {\n    this.outer = outer\n    outer.addInflow(this)\n    if (this.logger) {\n      this.logger.addEdge(this.id, outer.id, \"addObserverOuter\", { label: \"outer\" })\n    }\n    return this\n  }\n\n  public addInflow(inflow: IObserverTree) {\n    this.inflow = this.inflow || []\n    if (this.inflow.indexOf(inflow) >= 0) {\n      return this\n    }\n    this.inflow.push(inflow)\n    return this\n  }\n  public setObservable(observable: IObservableTree[]): IObserverTree {\n    if (this.observable) {\n      if (this.observable !== observable[0]) {\n        console.log(\"Adding second observable to \", this)\n        console.log(\"becoming\", observable)\n        console.log(\"was\", this.observable)\n        console.log(new Error().stack.split(\"\\n\").filter(l => l.indexOf(\"instrumentation.ts\") < 0).slice(0, 5).join(\"\\n\"))\n      } else {\n        return this\n      }\n    }\n    this.observable = observable[0]\n    if (this.logger) {\n      observable.forEach(o => this.logger.addEdge(o.id, this.id, \"setObserverSource\", { label: \"observable\" }))\n    }\n    return this\n  }\n\n  public addEvent(event: IEvent): IObserverTree {\n    if (this.logger) {\n      this.logger.addMeta(this.id, { events: event })\n    }\n    this.events.push(event)\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth > 30) {\n      return \"depth 30 reached\"\n    }\n    if (this.sink) {\n      return `ObserverTree(${this.id}, ${this.names}, \\n${pad(inspect(this.sink, depth + 1, opts), 1)}\\n)`\n    } else {\n      return `ObserverTree(${this.id}, ${this.names})`\n    }\n  }\n}\n\nfunction pad(str: string, depth: number): string {\n  if (depth <= 0 || !str) {\n    return str\n  }\n  return pad(str.split(\"\\n\").map(l => \"  \" + l).join(\"\\n\"), depth - 1)\n}\n\nfunction inspect(i: any, depth: number, opts: any): string {\n  if (i && i.inspect) {\n    return i.inspect(depth, opts)\n  } else if (i && i.toString) {\n    return i.toString()\n  } else {\n    return i\n  }\n}\n\nexport class SubjectTree implements ObservableTree, ObserverTree {\n  public id: Id\n  public names?: string[]\n  public args: IArguments\n  public inflow?: IObserverTree[]\n  public calls?: MethodCall[]\n  public sources?: IObservableTree[]\n  public observable: IObservableTree\n  public sink?: IObserverTree\n  public sinks?: IObserverTree[]\n  public events: IEvent[] = []\n  public scheduler?: ISchedulerInfo\n\n  // Mixin Observable & Observer methods\n  public setSink: (sinks: IObserverTree[], name?: string) => this\n  public setOuter: (sinks: IObserverTree) => this\n  public addInflow: (inflow: IObserverTree) => this\n  public setObservable: (observable: IObservableTree[]) => IObserverTree\n  public setSources: (sources: IObservableTree[]) => IObservableTree\n  public addMeta: (meta: any) => this\n  public addEvent: (event: IEvent) => IObserverTree\n  public logger?: ITreeLogger\n\n  constructor(id: string, name?: string, logger?: ITreeLogger, scheduler?: ISchedulerInfo) {\n    this.id = id\n    this.scheduler = scheduler\n    if (name) {\n      this.names = [name]\n    }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"subject\", scheduler && Object.assign({}, scheduler))\n      logger.addMeta(id, { names: name })\n    }\n    this.observable = this\n  }\n\n  public addSink(sinks: IObserverTree[], name?: string) {\n    let prev = this.sinks || []\n    this.setSink(sinks, name)\n    this.sinks = prev.concat(sinks)\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth > 30) {\n      return \"Too deep\"\n    }\n    return `SubjectTree(${this.id}, ${this.names}, \\n${pad(inspect(this.sink, depth + 2, opts), 2)}\\n)`\n  }\n}\n\napplyMixins(SubjectTree, [ObservableTree, ObserverTree])\n\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      // Only mix non-defined's, causing implemented methods to act as overloads. \n      // Allows mixin to have a specialized constructor for example.\n      if (typeof derivedCtor.prototype[name] === \"undefined\") {\n        derivedCtor.prototype[name] = baseCtor.prototype[name]\n      }\n    })\n  })\n}\n\nexport type SchedulerType = \"immediate\" | \"recursive\" | \"timeout\" | \"virtual\"\n\nexport type ISchedulerInfo = {\n  id: string\n  name: string\n  type: SchedulerType\n  clock: number\n}\n\nexport class SchedulerInfo implements ISchedulerInfo {\n  public id: string\n  public name: string\n  public type: SchedulerType\n  public clock: number\n\n  constructor(\n    id: string, name: string,\n    type: SchedulerType,\n    clock: number, logger?: ITreeLogger\n  ) {\n    this.id = id\n    this.name = name\n    this.type = type\n    this.clock = clock\n    logger.addScheduler(this.id, this)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/oct/oct.ts","import { EdgeType, ISchedulerInfo, ITreeLogger, NodeType } from \"../oct/oct\"\n\nexport default class TreePoster implements ITreeLogger {\n  private post: (message: any) => void\n  constructor(cb?: (message: any) => void) {\n    if (typeof cb === \"function\") {\n      this.post = cb\n    } else if (typeof window === \"object\" && window.parent) {\n      this.post = m => window.parent.postMessage(m, window.location.origin)\n    } else {\n      this.post = m => { /* intentionally left blank */ }\n      console.error(\"Using Window.postMessage logger in non-browser environment\", new Error())\n    }\n  }\n  public addNode(id: string, type: NodeType, scheduler?: ISchedulerInfo): void {\n    this.post({ id, type, scheduler })\n  }\n  public addMeta(id: string, meta: any): void {\n    this.post({ id, meta })\n  }\n  public addEdge(v: string, w: string, type: EdgeType, meta?: any): void {\n    this.post({ v, w, type, meta })\n  }\n  public addScheduler(id: string, scheduler: ISchedulerInfo): void {\n    this.post({ id, scheduler })\n  }\n  public addContraction(id: string, nodes: string[]): void {\n    this.post({ id, contract: nodes })\n  }\n\n  public reset() {\n    this.post(\"reset\")\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/treePoster.ts","import { EdgeType, ISchedulerInfo, ITreeLogger, NodeType } from \"../oct/oct\"\nimport { IEvent } from \"./event\"\n\nexport default class Logger implements ITreeLogger {\n  // tslint:disable-next-line:no-constructor-vars\n  constructor(private post: (m: any) => void) {}\n  public addNode(id: string, type: NodeType, scheduler?: ISchedulerInfo): void {\n    this.post({ id, type, scheduler })\n  }\n  public addMeta(id: string, meta: any): void {\n    this.post({ id, meta })\n  }\n  public addEdge(v: string, w: string, type: EdgeType, meta?: any): void {\n    this.post({ v, w, type, meta })\n  }\n  public addScheduler(id: string, scheduler: ISchedulerInfo): void {\n    this.post({ id, scheduler })\n  }\n  public addContraction(id: string, nodes: string[]): void {\n    this.post({ id, contract: nodes })\n  }\n  public reset() {\n    this.post(\"reset\")\n  }\n}\n\nexport function formatObject(o: any, levels: number = 2, depth: number = 0): string {\n  if (o === null) { return \"null\" }\n  if (levels <= 0) {\n    return `${\n      o.constructor && o.constructor.name !== \"Object\" ?\n        `[${o.constructor.name}] ` :\n        \"\"\n      }{...}`\n  }\n\n  let result = `${o.constructor.name !== \"Object\" ? `[${o.constructor.name}] ` : \"\"}{`\n  let i = 0\n  for (let key in o) {\n    if (o.hasOwnProperty(key) && key[0] !== \"_\") {\n      if (i > 0) { result += \",\" }\n      i++\n      let padding = \"\"\n      for (let p = 0; p < depth; p++) { padding += \"  \" }\n      result += `\\n${padding}\"${key}\": ${_formatArguments([o[key]], levels - 1, depth + 1)}`\n    }\n  }\n  result += result[result.length - 1] === \"{\" ? \"}\" : \"\\n}\"\n  return result\n}\n\nfunction _formatArguments(args: IArguments | any[], levels: number = 2, depth: number = 0): string {\n  return [].map.call(args, (a: any) => {\n    switch (typeof a) {\n      case \"undefined\": return \"undefined\"\n      case \"object\":\n        if (Array.isArray(a)) {\n          return `[${_formatArguments(a, levels - 1, depth + 1)}]`\n        } else {\n          return formatObject(a, levels - 1, depth + 1)\n        }\n      case \"function\":\n        if (typeof a.__original === \"function\") {\n          return a.__original.toString()\n        }\n        if (typeof a.__originalFunction === \"function\") {\n          return a.__originalFunction.toString()\n        }\n        return a.toString()\n      case \"string\":\n        return `\"${a.substring(0, 512)}\"`\n      case \"boolean\":\n        return a.toString()\n      case \"number\":\n        return a\n      default: throw new TypeError(`Invalid type ${typeof a}`)\n    }\n  }).join(\", \")\n}\n\nexport function formatArguments(args: IArguments | any[]): string {\n  return _formatArguments(args)\n}\n\nexport type Node = {\n  id: number\n  type: \"node\"\n  node: {\n    name: string\n  }\n}\nexport type Edge = {\n  type: \"edge\"\n  edge: {\n    v: number\n    w: number\n    label: SubscriptionLinkLabel | SubscriptionHigherOrderLinkLabel | ObservableTimingLabel,\n    reason: string\n  }\n  group?: number\n  groups?: number[]\n}\n\nexport type NodeLabel = {\n  group?: number\n  groups?: number[]\n  type: \"label\"\n  label: SubcriptionLabel | ObservableLabel | EventLabel\n  node: number\n}\n\nexport type ObservableTimingLabel = {\n  time: number\n  type: \"observable link\"\n}\n\nexport type SubcriptionLabel = {\n  id: number\n  type: \"subscription\"\n}\n\nexport type SubscriptionLinkLabel = {\n  type: \"subscription sink\"\n  v: number\n  w: number\n}\n\nexport type SubscriptionHigherOrderLinkLabel = {\n  type: \"higherOrderSubscription sink\",\n  id: number\n  parent: number\n}\n\nexport type EventLabel = {\n  event: IEvent\n  subscription: number\n  type: \"event\"\n}\n\nexport type ObservableLabel = {\n  args: any\n  method: string\n  type: \"observable\"\n}\n\nexport type Message = Node | Edge | NodeLabel\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/logger.ts","/* FlatMap extension of Array prototype */\nexport function flatMap<T, R>(this: T[], f: (t: T, index: number, all: T[]) => R[]): R[] {\n  return this.reduce((p: R[], n: T, index: number) => p.concat(f(n, index, this)), [])\n}\n\n// tslint:disable-next-line:no-namespace\ndeclare global {\n  interface Array<T> {\n    flatMap<R>(f: (t: T, index: number, all: T[]) => R[]): Array<R>\n  }\n}\n\nif (Object.defineProperty) {\n  Object.defineProperty(Array.prototype, \"flatMap\", {\n    configurable: false,\n    enumerable: false,\n    value: flatMap,\n    writable: false,\n  })\n} else {\n  // Beware of dragons...\n  Array.prototype.flatMap = flatMap\n}\n\n/* random */\nexport function endsWith(self: string, suffix: string): boolean {\n  return self.indexOf(suffix, self.length - suffix.length) !== -1\n}\n\nexport function last<T>(list: T[]): T {\n  return list.length >= 1 ? list[list.length - 1] : undefined\n}\n\nexport function head<T>(list: T[]): T {\n  return list.length >= 1 ? list[0] : undefined\n}\n\nexport function getPrototype(input: any): any {\n  return input.protoype || input.__proto__\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/prelude.ts"],"sourceRoot":""}