{"version":3,"sources":["webpack:///dist/worker-rx-5.x.x.bundle.js","webpack:///webpack/bootstrap 299ce472bbf6fc5ab701?38c1**","webpack:///external \"Rx\"?442b**","webpack:///./src/experiment/sample-data.ts?d4cc","webpack:///./src/instrumentation/worker-utils.ts?05a5","webpack:///./src/instrumentation/rxjs-5.x.x/worker.ts","webpack:///./src/instrumentation/rxjs-5.x.x/instrumentation.ts?b62b","webpack:///./src/collector/callrecord.ts?e81e*","webpack:///./src/collector/event.ts?a5b4*","webpack:///(webpack)/buildin/global.js?3698**","webpack:///./src/oct/oct.ts?f3d9**","webpack:///./src/collector/treePoster.ts?d48d","webpack:///./src/instrumentation/rxjs-5.x.x/collector.ts?545b","webpack:///./src/collector/logger.ts?4f8b*","webpack:///./src/prelude.ts?4065**"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","1","Rx","11","global","scheduler","_","next","ReactiveTest","onNext","complete","onCompleted","experimentProto","TestScheduler","advanceTo","bmi","height$","this","createHotObservable","map","v","concat","weight$","lottery","_this","newYear$","Observable","interval","survey","t","Date","UTC","veryOldServer","date","getTime","Math","pow","throw","Error","msg","winningTicket","round","random","imdb","_this2","inputStream","text","_scheduler","messages","length","shift","push","slice","apply","_movies","findMoviesAsync","term","result","filter","movie","toLowerCase","indexOf","johnsInput$","render","renderSomething","log","showError","noop","eval","experiment","12","formatError","e","message","original","undefined","stack","toString","scopedEval","code","scope","evalAndRepackageErrors","type","dummyError","exec","error","index","lastIndexOf","substring","split","join","onWorkerMessage","instrument","data","importScripts","url","postMessage","130","treePoster_1","worker_utils_1","collector_1","instrumentation_1","onmessage","poster","default","collector","TreeCollector","setup","console","info","version","24","_toConsumableArray","arr","Array","isArray","arr2","from","_classCallCheck","instance","Constructor","TypeError","now","performance","hasRxObservablePrototype","input","_typeof","isPrototypeOf","isInstrumented","fn","by","__originalFunction","__instrumentedBy","orig","prototypeIsInstrumented","isObservable","subscribe","isSubscription","Subscriber","isObserver","constructor","isSubject","Subject","isScheduler","Symbol","iterator","obj","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","RxType","InstrumentedRx","Instrumentation","prototypes","open","calls","callstacks","ignore","subjects","ObservableStatic","SubjectStatic","Scheduler","async","__proto__","targetName","setupPrototype","keys","forEach","reduce","prev","_ref","_ref2","deinstrument","proto","__dynamicallyInstrumented","originalFn","thisArg","argumentsList","method","subjectName","_this3","arguments","childs","id","subject","tick","time","parent","instanceLogger","before","returned","wrap","bind","end","after","pop","_this4","self","Proxy","construct","args","warn","Function","ownKeys","getOwnPropertyNames","_this5","methods","_this6","schedule","29","callRecordType","record","30","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","logger_1","Event","timing","source","fromCall","Next","ErrorInstance","Complete","Connect","Subscribe","Dispose","_Event","getPrototypeOf","formatArguments","someError","_Event2","_Event3","_Event4","_Event5","_Event6","4","g","window","5","pad","str","depth","_inspect","opts","inspect","ObservableTree","logger","names","addNode","assign","addMeta","sources","addEdge","label","meta","ObserverTree","events","sinks","sink","addInflow","outer","inflow","observable","event","SubjectTree","setSink","derivedCtor","baseCtors","baseCtor","SchedulerInfo","clock","addScheduler","51","TreePoster","cb","post","location","origin","w","nodes","contract","52","_getScheduler","obs","operator","isSource","_sources","hasSource","isFirstOpOntoSubject","schedulerType","VirtualTimeScheduler","asap","animationFrame","queue","callrecord_1","event_1","oct_1","prelude_1","SequenceTicker","last","used","nextId","eventSequencer","wireStarts","wires","otree","stree","schedulers","symbol","subSymbol","action","state","parents","tag","fromRecord","getTiming","observer","addEvent","_event","_observer","linkSources","hasTag","linkSubscribeSource","linkSinks","role","tree","getScheduler","addo","linkSubject","_tree","adds","_isScalar","_tree2","_tree3","getPrototype","clocks","setSources","sinkOpt","destination","setOuter","subjectAsObs","addSink","setObservable","a","b","_len","_key","arg","$ref","formatObject","Wire","to","_depth","r","WireStart","_to","7","levels","padding","_formatArguments","__original","Logger","8","flatMap","f","endsWith","suffix","list","head","protoype"],"mappings":"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","file":"./dist/worker-rx-5.x.x.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 130);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 1:\n/***/ (function(module, exports) {\n\nmodule.exports = Rx;\n\n/***/ }),\n\n/***/ 11:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar scheduler = null;\nvar _ = {\n    get next() {\n        return Rx.ReactiveTest.onNext;\n    },\n    get complete() {\n        return Rx.ReactiveTest.onCompleted;\n    }\n};\nvar experimentProto = {\n    get scheduler() {\n        if (scheduler === null) {\n            scheduler = new Rx.TestScheduler();\n            scheduler.advanceTo(0);\n        }\n        return scheduler;\n    },\n    get bmi() {\n        return {\n            height$: this.scheduler.createHotObservable([1.76, 1.77, 1.78].map(function (v, i) {\n                return _.next(i * 100, v);\n            }).concat([_.complete(400)])),\n            weight$: this.scheduler.createHotObservable([70, 72, 76, 79, 78, 75].map(function (v, i) {\n                return _.next(i * 100, v);\n            }).concat([_.complete(700)]))\n        };\n    },\n    get lottery() {\n        var _this = this;\n\n        var start = 2034;\n        var year = 1000 * 3600 * 24 * 365.25;\n        return {\n            newYear$: Rx.Observable.interval(year, survey.scheduler).map(function (t) {\n                return new Date(Date.UTC(t + start, 0, 1));\n            }),\n            veryOldServer: function veryOldServer(date) {\n                var unix = new Date(date).getTime() / 1000;\n                if (unix > Math.pow(2, 31)) {\n                    return Rx.Observable.throw(new Error(\"Crash!\"), _this.scheduler);\n                } else {\n                    return _this.scheduler.createHotObservable(_.next(0, { msg: \"calculating\" }), _.next(10, { msg: \"Happy new year!\", winningTicket: Math.round(Math.random() * 10) }), _.complete(20));\n                }\n            }\n        };\n    },\n    get imdb() {\n        var _this2 = this;\n\n        var inputStream = function inputStream(text) {\n            var _scheduler;\n\n            var t = 0;\n            var messages = [];\n            // let random = new Array(11).fill(1).map(_ => Math.floor(Math.random() * 100))\n            var random = [21, 37, 69, 35, 8, 48, 99, 75, 32, 51, 52, 96, 55, 19, 14, 61, 89, 70, 44, 69, 21, 19, 87, 64, 52, 96, 12, 41, 33, 69, 28, 35, 23, 82, 94, 73, 79, 24, 15, 19, 22, 21, 48, 25, 64, 52, 59, 23, 8, 63, 97, 74, 18, 86, 97, 21, 64, 8, 66, 33, 0, 40, 53, 70, 72, 62, 54, 13, 88, 43, 94, 70, 96, 6, 91, 60, 77, 58, 12, 98, 8, 64, 96, 9, 28, 86, 45, 65, 94, 28, 55, 39, 34, 46, 2, 93, 17, 84, 3];\n            for (var i = 0; i <= text.length; i++) {\n                t += random.shift();\n                messages.push(_.next(t, text.slice(0, i)));\n            }\n            return (_scheduler = _this2.scheduler).createHotObservable.apply(_scheduler, messages);\n        };\n        return {\n            _movies: [\"Them\", \"Lion King\", \"Belle & The Beast\", \"Avatar\", \"Harry Potter\", \"Guardians of the Galaxy\", \"House of Cards\", \"Spectre\", \"Interstellar\", \"Iron Man\", \"Terminator Genisys\", \"The Titanic\", \"The Avengers\"],\n            findMoviesAsync: function findMoviesAsync(term) {\n                var result = _this2.imdb._movies.filter(function (movie) {\n                    return movie.toLowerCase().indexOf(term.toLowerCase()) >= 0;\n                });\n                var t = 100 * result.length;\n                return _this2.scheduler.createHotObservable(_.next(t, result), _.complete(t + 1));\n            },\n            inputStream: inputStream,\n            johnsInput$: inputStream(\"the titanic\"),\n            render: function render() {}\n        };\n    },\n    get render() {\n        return function () {};\n    },\n    get renderSomething() {\n        return function () {};\n    },\n    get log() {\n        return function () {};\n    },\n    get showError() {\n        return function () {};\n    },\n    get noop() {\n        return function () {};\n    }\n};\neval(\"var experiment = experimentProto\");\nglobal.experiment = experimentProto;\neval(\"var survey = experimentProto\");\nglobal.survey = experimentProto;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n\n/***/ 12:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction formatError(e) {\n    return {\n        message: e.message,\n        name: e.name,\n        original: typeof e.original !== \"undefined\" ? formatError(e.original) : undefined,\n        stack: e.stack.toString()\n    };\n}\nvar scope = {};\n/**\n * Have single location for evil eval,\n * so we can infer it's stackTrace beforehand\n * and strip that from the errors coming from it\n */\nfunction scopedEval(code) {\n    // tslint:disable-next-line:only-arrow-functions\n    (function () {\n        // tslint:disable-next-line:no-eval\n        return eval(code);\n    }).call(scope);\n}\nfunction evalAndRepackageErrors(code) {\n    try {\n        return { result: scopedEval(code), type: \"result\" };\n    } catch (e) {\n        // Infer eval location\n        try {\n            scopedEval(\"throw new Error('ERROR')\");\n        } catch (dummyError) {\n            // clean up error stack trace\n            var result = /\\n\\s+at Object.<anonymous> \\((.*)\\)/.exec(dummyError.stack);\n            if (result === null) {\n                return { error: e.stack, type: \"error\" };\n            }\n            var stack = e.stack.toString();\n            var index = stack.lastIndexOf(\"at Object.<anonymous> (\" + result[1] + \")\");\n            stack = stack.substring(0, index);\n            stack = stack.split(\"eval at <anonymous> (\" + result[1] + \"), \").join(\"\");\n            e.stack = stack;\n        }\n        return { error: formatError(e), type: \"error\" };\n    }\n}\nfunction onWorkerMessage(instrument) {\n    return function (e) {\n        var message = e.data;\n        switch (message.type) {\n            case \"importScripts\":\n                importScripts(message.url);\n                instrument();\n                break;\n            case \"run\":\n                // Execute user code\n                var result = evalAndRepackageErrors(message.code);\n                if (result.type === \"error\") {\n                    postMessage({\n                        error: result.error,\n                        type: \"error\"\n                    });\n                }\n                break;\n            default:\n                break;\n        }\n    };\n}\nexports.onWorkerMessage = onWorkerMessage;\nif (typeof postMessage === \"function\") {\n    postMessage(\"ready\");\n}\n\n/***/ }),\n\n/***/ 130:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nimportScripts(\"instrumentation/rxjs-5.x.x/Rx.js\");\nvar treePoster_1 = __webpack_require__(51);\n__webpack_require__(11);\nvar worker_utils_1 = __webpack_require__(12);\nvar collector_1 = __webpack_require__(52);\nvar instrumentation_1 = __webpack_require__(24);\nonmessage = worker_utils_1.onWorkerMessage(function () {\n    var poster = new treePoster_1.default(function (m) {\n        return postMessage(m);\n    });\n    var collector = new collector_1.TreeCollector(poster, Rx);\n    var instrumentation = new instrumentation_1.default(collector, Rx);\n    instrumentation.setup();\n    console.info(\"Ready for RxJS 5 instrumentation\");\n    Rx.version = \"5.3.0\";\n});\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Allow either external scoped Rx or local imported Rx to be used\nvar RxType = __webpack_require__(1);\nexports.InstrumentedRx = typeof Rx === \"undefined\" ? RxType : Rx;\nvar i = 0;\n\nvar Instrumentation = function () {\n    function Instrumentation(collector, Rx) {\n        _classCallCheck(this, Instrumentation);\n\n        this.collector = collector;\n        this.Rx = Rx;\n        this.prototypes = [];\n        this.open = [];\n        this.calls = [];\n        this.callstacks = [];\n        this.ignore = false;\n        this.collector = collector;\n        this.subjects = {\n            \"Observable\": Rx.Observable.prototype,\n            \"Subscriber\": Rx.Subscriber.prototype,\n            \"ObservableStatic\": Rx.Observable,\n            \"SubjectStatic\": Rx.Subject,\n            \"Subject\": Rx.Subject.prototype,\n            \"Scheduler\": Rx.Scheduler.async.__proto__.__proto__\n        };\n    }\n\n    _createClass(Instrumentation, [{\n        key: \"setup\",\n        value: function setup(target, targetName) {\n            var _this = this;\n\n            if (typeof target !== \"undefined\") {\n                this.setupPrototype(target, targetName);\n            } else {\n                Object.keys(this.subjects).filter(function (name) {\n                    return typeof _this.subjects[name] !== \"undefined\";\n                }).forEach(function (name) {\n                    return _this.setup(_this.subjects[name], name);\n                });\n            }\n            /* TODO:\n             - schedulers\n             - constructors\n            */\n        }\n    }, {\n        key: \"teardown\",\n        value: function teardown() {\n            var _this2 = this;\n\n            var properties = this.prototypes.map(function (target) {\n                return Object.keys(target).map(function (key) {\n                    return { key: key, target: target };\n                });\n            }).reduce(function (prev, next) {\n                return prev.concat(next);\n            }, []);\n            // Methods\n            properties.filter(function (_ref) {\n                var key = _ref.key,\n                    target = _ref.target;\n                return typeof target[key] === \"function\";\n            }).forEach(function (_ref2) {\n                var key = _ref2.key,\n                    target = _ref2.target;\n\n                target[key] = _this2.deinstrument(target[key]);\n            });\n            // Prototypes\n            this.prototypes.filter(function (proto) {\n                return \"__dynamicallyInstrumented\" in proto;\n            }).forEach(function (proto) {\n                return delete proto.__dynamicallyInstrumented;\n            });\n            this.prototypes = [];\n        }\n        /* tslint:disable:only-arrow-functions */\n        /* tslint:disable:no-string-literal */\n        /* tslint:disable:no-string-literal */\n\n    }, {\n        key: \"apply\",\n        value: function apply(originalFn, target, thisArg, argumentsList, method, subjectName) {\n            var _this3 = this;\n\n            if (this.ignore) {\n                return originalFn.apply(target, argumentsList);\n            }\n            // find more\n            argumentsList.filter(hasRxObservablePrototype).filter(function (v) {\n                return !isInstrumented(v);\n            }).forEach(function (t) {\n                return _this3.setupPrototype(t);\n            });\n            var call = {\n                arguments: [].slice.call(argumentsList, 0),\n                childs: [],\n                id: i++,\n                method: method,\n                subject: thisArg,\n                subjectName: subjectName,\n                tick: 0,\n                time: now()\n            };\n            // Prepare\n            this.calls.push(call);\n            if (this.open.length > 0) {\n                call.parent = this.open[this.open.length - 1];\n                call.parent.childs.push(call);\n            }\n            this.open.push(call);\n            this.callstacks.push(this.open.slice(0));\n            // Actual method\n            this.ignore = true;\n            var instanceLogger = this.collector.before(call, this.open.slice(0, -1));\n            this.ignore = false;\n            var returned = target.apply(call.subject, [].map.call(call.arguments, this.wrap.bind(this)));\n            var end = call;\n            end.returned = returned;\n            this.ignore = true;\n            instanceLogger.after(end);\n            this.ignore = false;\n            // find more\n            [end.returned].filter(hasRxObservablePrototype).filter(function (v) {\n                return !isInstrumented(v);\n            }).forEach(function (t) {\n                return _this3.setupPrototype(t);\n            });\n            // Cleanup\n            this.open.pop();\n            return end.returned;\n        }\n        /* tslint:disable:only-arrow-functions */\n        /* tslint:disable:no-string-literal */\n        /* tslint:disable:no-string-literal */\n\n    }, {\n        key: \"instrument\",\n        value: function instrument(fn, method, subjectName) {\n            var _this4 = this;\n\n            var self = this;\n            var instrumented = new Proxy(fn, {\n                apply: function apply(target, thisArg, argumentsList) {\n                    return _this4.apply(fn, target, thisArg, argumentsList, method, subjectName);\n                },\n                construct: function construct(target, args) {\n                    console.warn(\"TODO, instrument constructor\", target, args);\n                    return new (Function.prototype.bind.apply(target, [null].concat(_toConsumableArray(args))))();\n                },\n                get: function get(target, property) {\n                    if (property === \"__instrumentedBy\") {\n                        return self;\n                    }\n                    if (property === \"__originalFunction\") {\n                        return fn;\n                    }\n                    return target[property];\n                },\n                ownKeys: function ownKeys(target) {\n                    return Object.getOwnPropertyNames(target).concat([\"__instrumentedBy\", \"__originalFunction\"]);\n                }\n            });\n            return instrumented;\n        }\n    }, {\n        key: \"deinstrument\",\n        value: function deinstrument(fn) {\n            return fn.__originalFunction && this.deinstrument(fn.__originalFunction) || fn;\n        }\n    }, {\n        key: \"setupPrototype\",\n        value: function setupPrototype(prototype, name) {\n            var _this5 = this;\n\n            if (typeof prototype === \"undefined\") {\n                return;\n            }\n            prototype.__dynamicallyInstrumented = true;\n            var methods = Object.keys(prototype).filter(function (key) {\n                return typeof prototype[key] === \"function\";\n            }).filter(function (key) {\n                return !isInstrumented(prototype[key], _this5);\n            });\n            if (methods.length) {\n                // store, preparing for teardown\n                this.prototypes.push(prototype);\n                methods.forEach(function (key) {\n                    prototype[key] = _this5.instrument(prototype[key], key, name || prototype.constructor.name);\n                });\n            }\n        }\n    }, {\n        key: \"wrap\",\n        value: function wrap(input) {\n            var _this6 = this;\n\n            if (isObservable(this.Rx, input) && !prototypeIsInstrumented(input.prototype)) {\n                this.setupPrototype(input.prototype, input.constructor.name);\n                return input;\n            }\n            if (isScheduler(this.Rx, input) && !isInstrumented(input.schedule) || isObserver(this.Rx, input) && !isInstrumented(input.next)) {\n                return new Proxy(input, {\n                    get: function get(thisArg, name) {\n                        var original = thisArg[name];\n                        if (name === \"__isInstrumentationWrapper\") {\n                            return true;\n                        }\n                        if (name === \"hasOwnProperty\") {\n                            return original;\n                        }\n                        if (typeof original === \"function\") {\n                            return _this6.instrument(original, name, input.constructor.name);\n                        }\n                        return original;\n                    },\n                    ownKeys: function ownKeys(target) {\n                        return Object.getOwnPropertyNames(target).concat([\"__isInstrumentationWrapper\"]);\n                    }\n                });\n            }\n            if (typeof input === \"function\" && !isInstrumented(input, this)) {\n                return this.instrument(input, input.name || \"lambda\", input.name || \"lambda\");\n            }\n            return input;\n        }\n    }]);\n\n    return Instrumentation;\n}();\n\nexports.default = Instrumentation;\nfunction now() {\n    return typeof performance !== \"undefined\" ? performance.now() : Date.now();\n}\nfunction hasRxObservablePrototype(Rx, input) {\n    return (typeof input === \"undefined\" ? \"undefined\" : _typeof(input)) === \"object\" && Rx.Observable.prototype.isPrototypeOf(input);\n}\nfunction isInstrumented(fn, by) {\n    if (typeof by === \"undefined\") {\n        return typeof fn.__originalFunction === \"function\" ? 1 + isInstrumented(fn.__originalFunction) : 0;\n    }\n    if (fn.__instrumentedBy === by) {\n        return true;\n    }\n    var orig = fn.__originalFunction;\n    return typeof orig === \"function\" && isInstrumented(orig, by);\n}\nexports.isInstrumented = isInstrumented;\nfunction prototypeIsInstrumented(input) {\n    return (typeof input === \"undefined\" ? \"undefined\" : _typeof(input)) === \"object\" && input !== null && input.hasOwnProperty(\"__dynamicallyInstrumented\");\n}\nfunction isObservable(Rx, v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && (v instanceof Rx.Observable || v !== null && typeof v.subscribe === \"function\");\n}\nexports.isObservable = isObservable;\nfunction isSubscription(Rx, v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v instanceof Rx.Subscriber;\n}\nexports.isSubscription = isSubscription;\nfunction isObserver(Rx, v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && (v instanceof Rx.Subscriber || v !== null && typeof v.next === \"function\") &&\n    /* Prevent emptyObserver as a subscriber\n     * (since it is statically used everywhere,  effectively linking all streams...)\n     */\n    v.constructor !== Object;\n}\nexports.isObserver = isObserver;\nfunction isSubject(Rx, v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && (v instanceof Rx.Subject || v !== null && typeof v.next === \"function\" && typeof v.subscribe === \"function\");\n}\nexports.isSubject = isSubject;\nfunction isScheduler(Rx, v) {\n    return (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && v !== null && \"now\" in v && \"schedule\" in v;\n}\nexports.isScheduler = isScheduler;\n\n/***/ }),\n\n/***/ 29:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction callRecordType(record) {\n    if (typeof record === \"undefined\" || typeof record.subject === \"undefined\") {\n        return undefined;\n    }\n    if (record.subjectName === \"Observable\" || record.subjectName === \"Observable.prototype\" || record.subjectName === \"ObservableBase.prototype\" || record.subjectName && record.subjectName.indexOf(\"Observable\") >= 0) {\n        if (record.method === \"subscribe\" || record.method === \"_subscribe\" || record.method === \"__subscribe\" || record.method === \"_trySubscribe\") {\n            return \"subscribe\";\n        }\n        return \"setup\";\n    } else {\n        return \"event\";\n    }\n}\nexports.callRecordType = callRecordType;\n\n/***/ }),\n\n/***/ 30:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar logger_1 = __webpack_require__(7);\n\nvar Event = function () {\n    function Event(type, timing, source) {\n        _classCallCheck(this, Event);\n\n        this.type = type;\n        this.timing = timing;\n        this.source = source;\n    }\n\n    _createClass(Event, null, [{\n        key: \"fromRecord\",\n        value: function fromRecord(record, timing, source) {\n            return Event.fromCall(record.method, record.arguments, timing, source);\n        }\n    }, {\n        key: \"fromCall\",\n        value: function fromCall(method, args, timing, source) {\n            switch (method) {\n                case \"next\":\n                case \"onNext\":\n                    return new Next(timing, args[0], source);\n                case \"error\":\n                case \"onError\":\n                case \"fail\":\n                    return new Error(timing, new ErrorInstance(args[0]), source);\n                case \"complete\":\n                case \"onCompleted\":\n                    return new Complete(timing, source);\n                case \"connect\":\n                    return new Connect(timing, source);\n                case \"subscribe\":\n                case \"_subscribe\":\n                case \"__subscribe\":\n                    return new Subscribe(timing, source);\n                case \"dispose\":\n                case \"unsubscribe\":\n                    return new Dispose(timing, source);\n                default:\n                    break;\n            }\n        }\n    }, {\n        key: \"fromJson\",\n        value: function fromJson(input) {\n            switch (input.type) {\n                case \"next\":\n                    return new Next(input.timing, input.value, input.source);\n                case \"error\":\n                    return new Error(input.timing, input.error, input.source);\n                case \"complete\":\n                    return new Complete(input.timing, input.source);\n                case \"subscribe\":\n                    return new Subscribe(input.timing, input.source);\n                case \"dispose\":\n                    return new Dispose(input.timing, input.source);\n                default:\n                    return null;\n            }\n        }\n    }]);\n\n    return Event;\n}();\n\nexports.Event = Event;\n\nvar Next = function (_Event) {\n    _inherits(Next, _Event);\n\n    function Next(timing, value, source) {\n        _classCallCheck(this, Next);\n\n        var _this = _possibleConstructorReturn(this, (Next.__proto__ || Object.getPrototypeOf(Next)).call(this, \"next\", timing, source));\n\n        _this.value = logger_1.formatArguments([value]);\n        return _this;\n    }\n\n    return Next;\n}(Event);\n\nexports.Next = Next;\n\nvar ErrorInstance = function ErrorInstance(someError) {\n    _classCallCheck(this, ErrorInstance);\n\n    this.name = someError.name;\n    this.message = someError.message;\n    this.stack = someError.stack;\n};\n\nexports.ErrorInstance = ErrorInstance;\n\nvar Error = function (_Event2) {\n    _inherits(Error, _Event2);\n\n    function Error(timing, error, source) {\n        _classCallCheck(this, Error);\n\n        var _this2 = _possibleConstructorReturn(this, (Error.__proto__ || Object.getPrototypeOf(Error)).call(this, \"error\", timing, source));\n\n        _this2.error = error;\n        return _this2;\n    }\n\n    return Error;\n}(Event);\n\nexports.Error = Error;\n\nvar Complete = function (_Event3) {\n    _inherits(Complete, _Event3);\n\n    function Complete(timing, source) {\n        _classCallCheck(this, Complete);\n\n        return _possibleConstructorReturn(this, (Complete.__proto__ || Object.getPrototypeOf(Complete)).call(this, \"complete\", timing, source));\n    }\n\n    return Complete;\n}(Event);\n\nexports.Complete = Complete;\n\nvar Subscribe = function (_Event4) {\n    _inherits(Subscribe, _Event4);\n\n    function Subscribe(timing, source) {\n        _classCallCheck(this, Subscribe);\n\n        return _possibleConstructorReturn(this, (Subscribe.__proto__ || Object.getPrototypeOf(Subscribe)).call(this, \"subscribe\", timing, source));\n    }\n\n    return Subscribe;\n}(Event);\n\nexports.Subscribe = Subscribe;\n\nvar Connect = function (_Event5) {\n    _inherits(Connect, _Event5);\n\n    function Connect(timing, source) {\n        _classCallCheck(this, Connect);\n\n        return _possibleConstructorReturn(this, (Connect.__proto__ || Object.getPrototypeOf(Connect)).call(this, \"connect\", timing, source));\n    }\n\n    return Connect;\n}(Event);\n\nexports.Connect = Connect;\n\nvar Dispose = function (_Event6) {\n    _inherits(Dispose, _Event6);\n\n    function Dispose(timing, source) {\n        _classCallCheck(this, Dispose);\n\n        return _possibleConstructorReturn(this, (Dispose.__proto__ || Object.getPrototypeOf(Dispose)).call(this, \"dispose\", timing, source));\n    }\n\n    return Dispose;\n}(Event);\n\nexports.Dispose = Dispose;\n\n/***/ }),\n\n/***/ 4:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n\n/***/ 5:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar ObservableTree = function () {\n    function ObservableTree(id, name, logger, scheduler) {\n        _classCallCheck(this, ObservableTree);\n\n        this.id = id;\n        this.scheduler = scheduler;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"observable\", scheduler && Object.assign({}, scheduler));\n            logger.addMeta(id, { names: name });\n        }\n    }\n\n    _createClass(ObservableTree, [{\n        key: \"setSources\",\n        value: function setSources(sources) {\n            var _this = this;\n\n            this.sources = sources;\n            if (this.logger) {\n                sources.forEach(function (s) {\n                    return _this.logger.addEdge(s.id, _this.id, \"addSource\", { label: \"source\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(meta) {\n            if (this.logger) {\n                this.logger.addMeta(this.id, meta);\n            }\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth < 100) {\n                return \"ObservableTree(\" + this.id + \", \" + this.names + \", \" + (this.sources || []).map(function (s) {\n                    return pad(_inspect(s, depth + 2, opts), 2);\n                }) + \")\";\n            }\n        }\n    }]);\n\n    return ObservableTree;\n}();\n\nexports.ObservableTree = ObservableTree;\n\nvar ObserverTree = function () {\n    function ObserverTree(id, name, logger) {\n        _classCallCheck(this, ObserverTree);\n\n        this.events = [];\n        this.id = id;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"observer\");\n            logger.addMeta(id, { names: name });\n        }\n    }\n\n    _createClass(ObserverTree, [{\n        key: \"setSink\",\n        value: function setSink(sinks) {\n            var _this2 = this;\n\n            if (this.sink === sinks[0]) {\n                return this;\n            }\n            this.sink = sinks[0];\n            sinks.forEach(function (s) {\n                return s.addInflow(_this2);\n            });\n            if (this.logger) {\n                sinks.forEach(function (s) {\n                    return _this2.logger.addEdge(_this2.id, s.id, \"addObserverDestination\", { label: \"destination\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"setOuter\",\n        value: function setOuter(outer) {\n            this.outer = outer;\n            outer.addInflow(this);\n            if (this.logger) {\n                this.logger.addEdge(this.id, outer.id, \"addObserverOuter\", { label: \"outer\" });\n            }\n            return this;\n        }\n    }, {\n        key: \"addInflow\",\n        value: function addInflow(inflow) {\n            this.inflow = this.inflow || [];\n            if (this.inflow.indexOf(inflow) >= 0) {\n                return this;\n            }\n            this.inflow.push(inflow);\n            return this;\n        }\n    }, {\n        key: \"setObservable\",\n        value: function setObservable(observable) {\n            var _this3 = this;\n\n            if (this.observable) {\n                if (this.observable !== observable[0]) {\n                    console.log(\"Adding second observable to \", this);\n                    console.log(\"becoming\", observable);\n                    console.log(\"was\", this.observable);\n                    console.log(new Error().stack.split(\"\\n\").filter(function (l) {\n                        return l.indexOf(\"instrumentation.ts\") < 0;\n                    }).slice(0, 5).join(\"\\n\"));\n                } else {\n                    return this;\n                }\n            }\n            this.observable = observable[0];\n            if (this.logger) {\n                observable.forEach(function (o) {\n                    return _this3.logger.addEdge(o.id, _this3.id, \"setObserverSource\", { label: \"observable\" });\n                });\n            }\n            return this;\n        }\n    }, {\n        key: \"addEvent\",\n        value: function addEvent(event) {\n            if (this.logger) {\n                this.logger.addMeta(this.id, { events: event });\n            }\n            this.events.push(event);\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth > 30) {\n                return \"depth 30 reached\";\n            }\n            if (this.sink) {\n                return \"ObserverTree(\" + this.id + \", \" + this.names + \", \\n\" + pad(_inspect(this.sink, depth + 1, opts), 1) + \"\\n)\";\n            } else {\n                return \"ObserverTree(\" + this.id + \", \" + this.names + \")\";\n            }\n        }\n    }]);\n\n    return ObserverTree;\n}();\n\nexports.ObserverTree = ObserverTree;\nfunction pad(str, depth) {\n    if (depth <= 0 || !str) {\n        return str;\n    }\n    return pad(str.split(\"\\n\").map(function (l) {\n        return \"  \" + l;\n    }).join(\"\\n\"), depth - 1);\n}\nfunction _inspect(i, depth, opts) {\n    if (i && i.inspect) {\n        return i.inspect(depth, opts);\n    } else if (i && i.toString) {\n        return i.toString();\n    } else {\n        return i;\n    }\n}\n\nvar SubjectTree = function () {\n    function SubjectTree(id, name, logger, scheduler) {\n        _classCallCheck(this, SubjectTree);\n\n        this.events = [];\n        this.id = id;\n        this.scheduler = scheduler;\n        if (name) {\n            this.names = [name];\n        }\n        if (logger) {\n            this.logger = logger;\n            logger.addNode(id, \"subject\", scheduler && Object.assign({}, scheduler));\n            logger.addMeta(id, { names: name });\n        }\n        this.observable = this;\n    }\n\n    _createClass(SubjectTree, [{\n        key: \"addSink\",\n        value: function addSink(sinks, name) {\n            var prev = this.sinks || [];\n            this.setSink(sinks, name);\n            this.sinks = prev.concat(sinks);\n            return this;\n        }\n    }, {\n        key: \"inspect\",\n        value: function inspect(depth, opts) {\n            if (depth > 30) {\n                return \"Too deep\";\n            }\n            return \"SubjectTree(\" + this.id + \", \" + this.names + \", \\n\" + pad(_inspect(this.sink, depth + 2, opts), 2) + \"\\n)\";\n        }\n    }]);\n\n    return SubjectTree;\n}();\n\nexports.SubjectTree = SubjectTree;\napplyMixins(SubjectTree, [ObservableTree, ObserverTree]);\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach(function (baseCtor) {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {\n            // Only mix non-defined's, causing implemented methods to act as overloads. \n            // Allows mixin to have a specialized constructor for example.\n            if (typeof derivedCtor.prototype[name] === \"undefined\") {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\n\nvar SchedulerInfo = function SchedulerInfo(id, name, type, clock, logger) {\n    _classCallCheck(this, SchedulerInfo);\n\n    this.id = id;\n    this.name = name;\n    this.type = type;\n    this.clock = clock;\n    logger.addScheduler(this.id, this);\n};\n\nexports.SchedulerInfo = SchedulerInfo;\n\n/***/ }),\n\n/***/ 51:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar TreePoster = function () {\n    function TreePoster(cb) {\n        _classCallCheck(this, TreePoster);\n\n        if (typeof cb === \"function\") {\n            this.post = cb;\n        } else if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && window.parent) {\n            this.post = function (m) {\n                return window.parent.postMessage(m, window.location.origin);\n            };\n        } else {\n            this.post = function (m) {};\n            console.error(\"Using Window.postMessage logger in non-browser environment\", new Error());\n        }\n    }\n\n    _createClass(TreePoster, [{\n        key: \"addNode\",\n        value: function addNode(id, type, scheduler) {\n            this.post({ id: id, type: type, scheduler: scheduler });\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(id, meta) {\n            this.post({ id: id, meta: meta });\n        }\n    }, {\n        key: \"addEdge\",\n        value: function addEdge(v, w, type, meta) {\n            this.post({ v: v, w: w, type: type, meta: meta });\n        }\n    }, {\n        key: \"addScheduler\",\n        value: function addScheduler(id, scheduler) {\n            this.post({ id: id, scheduler: scheduler });\n        }\n    }, {\n        key: \"addContraction\",\n        value: function addContraction(id, nodes) {\n            this.post({ id: id, contract: nodes });\n        }\n    }, {\n        key: \"reset\",\n        value: function reset() {\n            this.post(\"reset\");\n        }\n    }]);\n\n    return TreePoster;\n}();\n\nexports.default = TreePoster;\n\n/***/ }),\n\n/***/ 52:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar callrecord_1 = __webpack_require__(29);\nvar event_1 = __webpack_require__(30);\nvar logger_1 = __webpack_require__(7);\nvar oct_1 = __webpack_require__(5);\nvar prelude_1 = __webpack_require__(8);\nvar instrumentation_1 = __webpack_require__(24);\nvar debug = false;\nfunction _getScheduler(obs, record) {\n    return obs.scheduler || obs._scheduler || obs.operator && obs.operator.scheduler || record && [].filter.call(record.arguments || [], instrumentation_1.isScheduler)[0];\n}\n\nvar SequenceTicker = function () {\n    function SequenceTicker() {\n        _classCallCheck(this, SequenceTicker);\n\n        this.last = 0;\n        this.used = false;\n    }\n\n    _createClass(SequenceTicker, [{\n        key: \"next\",\n        value: function next() {\n            if (this.used) {\n                this.used = false;\n                this.last++;\n            }\n        }\n    }, {\n        key: \"get\",\n        value: function get() {\n            this.used = true;\n            return this.last;\n        }\n    }]);\n\n    return SequenceTicker;\n}();\n\nvar TreeCollector = function () {\n    function TreeCollector(logger, Rx) {\n        _classCallCheck(this, TreeCollector);\n\n        this.Rx = Rx;\n        this.nextId = 1;\n        this.eventSequencer = new SequenceTicker();\n        this.wireStarts = [];\n        this.wires = [];\n        this.otree = [];\n        this.stree = [];\n        this.schedulers = [];\n        this.logger = logger;\n        this.symbol = Symbol(\"tree\");\n        this.subSymbol = Symbol(\"tree2\");\n    }\n\n    _createClass(TreeCollector, [{\n        key: \"schedule\",\n        value: function schedule(scheduler, method, action, state) {\n            this.eventSequencer.next();\n        }\n    }, {\n        key: \"before\",\n        value: function before(record, parents) {\n            // tag all encountered Observables & Subscribers\n            [record.subject].concat(_toConsumableArray(record.arguments)).forEach(this.tag.bind(this, undefined));\n            if (record.method === \"schedule\") {\n                this.schedule(record.subject, record.method, undefined, undefined);\n            }\n            // Record next/error/complete/dispose events\n            if (callrecord_1.callRecordType(record) === \"event\" && instrumentation_1.isObserver(this.Rx, record.subject)) {\n                var event = event_1.Event.fromRecord(record, this.getTiming());\n                if (event) {\n                    var observer = this.tag(\"observer\", record.subject);\n                    this.addEvent(observer, event, record.arguments[0]);\n                }\n            }\n            // Record subscribe-event\n            if (callrecord_1.callRecordType(record) === \"subscribe\" && instrumentation_1.isObservable(this.Rx, record.subject) && instrumentation_1.isObserver(this.Rx, record.arguments[0])) {\n                var _event = event_1.Event.fromRecord(record, this.getTiming());\n                if (_event) {\n                    var _observer = this.tag(\"observer\", record.arguments[0], record);\n                    this.addEvent(_observer, _event);\n                }\n            }\n            return this;\n        }\n    }, {\n        key: \"after\",\n        value: function after(record) {\n            var _this = this;\n\n            this.call = record;\n            // tag all encountered Observables & Subscribers\n            [record.returned].forEach(function (t) {\n                return _this.tag(undefined, t, record);\n            });\n            if (instrumentation_1.isObservable(this.Rx, record.returned)) {\n                this.linkSources(record.returned);\n                var shouldName = isFirstOpOntoSubject(record) && (\n                // b = a.map(lambda) => linked by source property\n                isSource(record.subject, record.returned) ||\n                // Observable.of() has record.subject == static Observable\n                !instrumentation_1.isObservable(this.Rx, record.subject) && !hasSource(record.returned));\n                if (shouldName) {\n                    var tree = this.tag(\"observable\", record.returned);\n                    tree.addMeta({\n                        calls: {\n                            args: this.formatArguments.apply(this, _toConsumableArray(record.arguments)),\n                            method: record.method,\n                            subject: \"callRecord.subjectName \" + (this.hasTag(record.subject) && this.tag(\"observable\", record.subject).id)\n                        }\n                    });\n                }\n            }\n            if (callrecord_1.callRecordType(record) === \"subscribe\") {\n                if (instrumentation_1.isObserver(this.Rx, record.arguments[0])) {\n                    this.linkSubscribeSource(record.arguments[0], record.subject);\n                    this.linkSinks(record.arguments[0]);\n                } else if (instrumentation_1.isObserver(this.Rx, record.returned)) {\n                    this.linkSubscribeSource(record.returned, record.subject);\n                    this.linkSinks(record.returned);\n                }\n            }\n        }\n    }, {\n        key: \"getEventReason\",\n        value: function getEventReason(record) {\n            // return [record.parent, record.parent && record.parent.parent]\n            //   .filter(r => r && isObserver(r.subject) && this.hasTag(r.subject))\n            //   .map(r => this.tag(r.subject).id)[0]\n            return;\n        }\n    }, {\n        key: \"addEvent\",\n        value: function addEvent(observer, event, value) {\n            if (typeof event === \"undefined\") {\n                return;\n            }\n            // Enrich higher order events\n            if (event.type === \"next\" && instrumentation_1.isObservable(this.Rx, value)) {\n                event.value = {\n                    id: this.tag(\"observable\", value).id,\n                    type: value.constructor.name\n                };\n            }\n            if (!observer.inflow || observer.inflow.length === 0) {\n                this.eventSequencer.next();\n            }\n            event.timing = this.getTiming();\n            observer.addEvent(event);\n        }\n    }, {\n        key: \"hasTag\",\n        value: function hasTag(input) {\n            return (typeof input === \"undefined\" ? \"undefined\" : _typeof(input)) === \"object\" && input !== null && typeof input[this.symbol] !== \"undefined\";\n        }\n    }, {\n        key: \"tag\",\n        value: function tag(role, input, record) {\n            if ((typeof input === \"undefined\" ? \"undefined\" : _typeof(input)) !== \"object\" || input === null) {\n                return undefined;\n            }\n            var symbol = this.symbol;\n            if (instrumentation_1.isSubject(this.Rx, input) && role === \"observer\") {\n                symbol = this.subSymbol;\n            }\n            if (input.hasOwnProperty(symbol) && typeof input[symbol] !== \"undefined\") {\n                return input[symbol];\n            }\n            if (instrumentation_1.isSubject(this.Rx, input)) {\n                if (role === \"observable\") {\n                    var tree = input[this.symbol] = new oct_1.ObservableTree(\"\" + this.nextId++, input.constructor.name, this.logger, this.getScheduler(input));\n                    this.linkSources(input);\n                    this.addo(tree);\n                    this.linkSubject(tree, input[this.subSymbol]);\n                    return tree;\n                } else if (role === \"observer\") {\n                    var _tree = input[this.subSymbol] = new oct_1.SubjectTree(\"\" + this.nextId++, input.constructor.name, this.logger, this.getScheduler(input));\n                    this.linkSinks(input);\n                    this.adds(_tree);\n                    this.linkSubject(input[this.symbol], _tree);\n                    return _tree;\n                }\n            }\n            if (instrumentation_1.isObservable(this.Rx, input)) {\n                /* this hack is neccessary since subscribeToResult does not call subscribe on ScalarObservables */\n                if (input && input.constructor && input.constructor.name === \"ScalarObservable\") {\n                    input._isScalar = false;\n                }\n                /* end of ScalarObservable hack */\n                var _tree2 = input[symbol] = new oct_1.ObservableTree(\"\" + this.nextId++, input.constructor.name, this.logger, this.getScheduler(input, record));\n                this.linkSources(input);\n                this.addo(_tree2);\n                return _tree2;\n            }\n            if (instrumentation_1.isObserver(this.Rx, input)) {\n                var _tree3 = input[symbol] = new oct_1.ObserverTree(\"\" + this.nextId++, input.constructor.name, this.logger);\n                this.linkSinks(input);\n                this.adds(_tree3);\n                return _tree3;\n            }\n            if (instrumentation_1.isScheduler(this.Rx, input)) {\n                var scheduler = input;\n                var clock = scheduler.now();\n                var type = schedulerType(this.Rx, input);\n                var info = new oct_1.SchedulerInfo(\"\" + this.nextId++, prelude_1.getPrototype(scheduler).constructor.name, type, clock, this.logger);\n                input[symbol] = info;\n                this.schedulers.push({ scheduler: scheduler, info: info });\n                return info;\n            }\n            return;\n        }\n    }, {\n        key: \"adds\",\n        value: function adds(tree) {\n            this.stree.push(tree);\n        }\n    }, {\n        key: \"addo\",\n        value: function addo(tree) {\n            this.otree.push(tree);\n        }\n    }, {\n        key: \"getScheduler\",\n        value: function getScheduler(input, record) {\n            if (instrumentation_1.isObservable(this.Rx, input) && _getScheduler(input, record)) {\n                return this.tag(\"scheduler\", _getScheduler(input, record));\n            }\n            return;\n        }\n    }, {\n        key: \"getTiming\",\n        value: function getTiming() {\n            var clocks = { tick: this.eventSequencer.get() };\n            if (this.scheduler) {\n                clocks[this.scheduler.info.id] = this.scheduler.scheduler.now();\n                return Object.assign({\n                    scheduler: this.scheduler.info.id,\n                    clocks: clocks\n                });\n            }\n            return {\n                clocks: clocks,\n                scheduler: \"tick\"\n            };\n        }\n    }, {\n        key: \"linkSources\",\n        value: function linkSources(observable) {\n            var _this2 = this;\n\n            var sources = [observable.source].concat(_toConsumableArray(observable._sources || [])).filter(instrumentation_1.isObservable).map(function (o) {\n                return _this2.tag(\"observable\", o);\n            });\n            if (sources.indexOf(this.tag(\"observable\", observable)) >= 0) {\n                console.log(\"Reference loop\", observable, this.call);\n            }\n            this.tag(\"observable\", observable).setSources(sources);\n        }\n    }, {\n        key: \"linkSinks\",\n        value: function linkSinks(observer) {\n            var _this3 = this;\n\n            if (instrumentation_1.isObservable(this.Rx, observer)) {\n                return;\n            }\n            var sinkOpt = [observer.destination].filter(function (o) {\n                return instrumentation_1.isObserver(_this3.Rx, o) || instrumentation_1.isSubject(_this3.Rx, o);\n            }).map(function (o) {\n                return _this3.tag(\"observer\", o);\n            });\n            this.tag(\"observer\", observer).setSink(sinkOpt);\n            var parentOpt = [observer.parent].filter(instrumentation_1.isObserver.bind(null, this.Rx)).map(function (o) {\n                return _this3.tag(\"observer\", o);\n            });\n            parentOpt.forEach(function (p) {\n                return _this3.tag(\"observer\", observer).setOuter(p);\n            });\n        }\n    }, {\n        key: \"linkSubscribeSource\",\n        value: function linkSubscribeSource(observer, observable) {\n            if (instrumentation_1.isSubject(this.Rx, observable)) {\n                var subjectAsObs = this.tag(\"observable\", observable);\n                var subject = this.tag(\"observer\", observable);\n                if (subjectAsObs.sources.length === 0) {\n                    subject.addSink([this.tag(\"observer\", observer)]);\n                    this.tag(\"observer\", observer).setObservable([subjectAsObs]);\n                    return;\n                }\n            }\n            var stree = this.tag(\"observer\", observer);\n            var otree = this.tag(\"observable\", observable);\n            if (typeof stree.observable === \"undefined\") {\n                stree.setObservable([otree]);\n            }\n        }\n        /**\n         * Create link representing the domain border crossing of the Subject\n         * @param a observable-side\n         * @param b observer-side\n         */\n\n    }, {\n        key: \"linkSubject\",\n        value: function linkSubject(a, b) {\n            if (typeof a !== \"undefined\" && typeof b !== \"undefined\" && typeof b.observable === \"undefined\") {\n                b.setObservable([a]);\n            }\n        }\n    }, {\n        key: \"formatArguments\",\n        value: function formatArguments() {\n            var _this4 = this;\n\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return args.map(function (arg) {\n                if (typeof arg === \"number\" || typeof arg === \"string\") {\n                    return { type: typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg), value: logger_1.formatArguments([arg]) };\n                }\n                if ((typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg)) === \"object\") {\n                    if (Array.isArray(arg)) {\n                        return { type: \"array\", value: logger_1.formatArguments(arg) };\n                    } else if (_this4.hasTag(arg)) {\n                        return { $ref: _this4.tag(undefined, arg).id, type: \"ref\", value: logger_1.formatObject(arg, 0) };\n                    } else {\n                        return { type: \"object\", value: logger_1.formatArguments([arg]) };\n                    }\n                }\n                if (typeof arg === \"function\") {\n                    return { type: \"function\", value: logger_1.formatArguments([arg]) };\n                }\n            });\n        }\n    }]);\n\n    return TreeCollector;\n}();\n\nexports.TreeCollector = TreeCollector;\nfunction printStack(record) {\n    if (typeof record === \"undefined\") {\n        return \"\";\n    }\n    return \"\\n\\t\" + (record.subject.constructor.name + \".\" + record.method + \"(\" + logger_1.formatArguments(record.arguments) + \")\") + (record.parent ? printStack(record.parent) : \"\");\n}\nfunction callStackDepth(record) {\n    return typeof record.parent === \"undefined\" ? 1 : 1 + callStackDepth(record.parent);\n}\nfunction generate(seed, next) {\n    if (typeof seed === \"undefined\" || seed === null) {\n        return [];\n    } else {\n        return [seed].concat(_toConsumableArray(generate(next(seed), next)));\n    }\n}\n\nvar Wire = function () {\n    // tslint:disable-next-line:no-constructor-vars\n    function Wire(call, from, to) {\n        _classCallCheck(this, Wire);\n\n        this.call = call;\n        this.from = from;\n        this.to = to;\n        this._depth = this.depth;\n    }\n\n    _createClass(Wire, [{\n        key: \"depth\",\n        get: function get() {\n            var r = function r(call) {\n                return typeof call.parent === \"undefined\" || callrecord_1.callRecordType(call.parent) !== \"setup\" ? 0 : r(call.parent) + 1;\n            };\n            return r(this.call);\n        }\n    }]);\n\n    return Wire;\n}();\n\nvar WireStart = function () {\n    // tslint:disable-next-line:no-constructor-vars\n    function WireStart(call, from) {\n        _classCallCheck(this, WireStart);\n\n        this.call = call;\n        this.from = from;\n    }\n\n    _createClass(WireStart, [{\n        key: \"to\",\n        value: function to(_to) {\n            return new Wire(this.call, this.from, _to);\n        }\n    }]);\n\n    return WireStart;\n}();\n\nfunction isSource(source, obs) {\n    return obs.source === source || Array.isArray(obs._sources) && obs._sources.indexOf(source) >= 0;\n}\nfunction hasSource(obs) {\n    return obs.source || Array.isArray(obs._sources) && obs._sources.length > 0;\n}\nfunction isFirstOpOntoSubject(record) {\n    return !record.parent || record.parent.subject !== record.subject;\n}\nfunction schedulerType(Rx, scheduler) {\n    if (scheduler instanceof Rx.VirtualTimeScheduler || scheduler instanceof Rx.TestScheduler) {\n        return \"virtual\";\n    } else if (scheduler === Rx.Scheduler.asap) {\n        return \"recursive\";\n    } else if (scheduler === Rx.Scheduler.async) {\n        return \"timeout\";\n    } else if (scheduler === Rx.Scheduler.animationFrame) {\n        return \"timeout\";\n    } else if (scheduler === Rx.Scheduler.queue) {\n        return \"recursive\";\n    }\n}\nfunction derivatedSubject(input) {\n    return input.source === input.destination;\n}\n\n/***/ }),\n\n/***/ 7:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar Logger = function () {\n    // tslint:disable-next-line:no-constructor-vars\n    function Logger(post) {\n        _classCallCheck(this, Logger);\n\n        this.post = post;\n    }\n\n    _createClass(Logger, [{\n        key: \"addNode\",\n        value: function addNode(id, type, scheduler) {\n            this.post({ id: id, type: type, scheduler: scheduler });\n        }\n    }, {\n        key: \"addMeta\",\n        value: function addMeta(id, meta) {\n            this.post({ id: id, meta: meta });\n        }\n    }, {\n        key: \"addEdge\",\n        value: function addEdge(v, w, type, meta) {\n            this.post({ v: v, w: w, type: type, meta: meta });\n        }\n    }, {\n        key: \"addScheduler\",\n        value: function addScheduler(id, scheduler) {\n            this.post({ id: id, scheduler: scheduler });\n        }\n    }, {\n        key: \"addContraction\",\n        value: function addContraction(id, nodes) {\n            this.post({ id: id, contract: nodes });\n        }\n    }, {\n        key: \"reset\",\n        value: function reset() {\n            this.post(\"reset\");\n        }\n    }]);\n\n    return Logger;\n}();\n\nexports.default = Logger;\nfunction formatObject(o) {\n    var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    if (o === null) {\n        return \"null\";\n    }\n    if (levels <= 0) {\n        return (o.constructor && o.constructor.name !== \"Object\" ? \"[\" + o.constructor.name + \"] \" : \"\") + \"{...}\";\n    }\n    var result = (o.constructor.name !== \"Object\" ? \"[\" + o.constructor.name + \"] \" : \"\") + \"{\";\n    var i = 0;\n    for (var key in o) {\n        if (o.hasOwnProperty(key) && key[0] !== \"_\") {\n            if (i > 0) {\n                result += \",\";\n            }\n            i++;\n            var padding = \"\";\n            for (var p = 0; p < depth; p++) {\n                padding += \"  \";\n            }\n            result += \"\\n\" + padding + \"\\\"\" + key + \"\\\": \" + _formatArguments([o[key]], levels - 1, depth + 1);\n        }\n    }\n    result += result[result.length - 1] === \"{\" ? \"}\" : \"\\n}\";\n    return result;\n}\nexports.formatObject = formatObject;\nfunction _formatArguments(args) {\n    var levels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    return [].map.call(args, function (a) {\n        switch (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) {\n            case \"undefined\":\n                return \"undefined\";\n            case \"object\":\n                if (Array.isArray(a)) {\n                    return \"[\" + _formatArguments(a, levels - 1, depth + 1) + \"]\";\n                } else {\n                    return formatObject(a, levels - 1, depth + 1);\n                }\n            case \"function\":\n                if (typeof a.__original === \"function\") {\n                    return a.__original.toString();\n                }\n                if (typeof a.__originalFunction === \"function\") {\n                    return a.__originalFunction.toString();\n                }\n                return a.toString();\n            case \"string\":\n                return \"\\\"\" + a.substring(0, 512) + \"\\\"\";\n            case \"boolean\":\n                return a.toString();\n            case \"number\":\n                return a;\n            default:\n                throw new TypeError(\"Invalid type \" + (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)));\n        }\n    }).join(\", \");\n}\nfunction formatArguments(args) {\n    return _formatArguments(args);\n}\nexports.formatArguments = formatArguments;\n\n/***/ }),\n\n/***/ 8:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* FlatMap extension of Array prototype */\nfunction flatMap(f) {\n    var _this = this;\n\n    return this.reduce(function (p, n, index) {\n        return p.concat(f(n, index, _this));\n    }, []);\n}\nexports.flatMap = flatMap;\nif (Object.defineProperty) {\n    Object.defineProperty(Array.prototype, \"flatMap\", {\n        configurable: false,\n        enumerable: false,\n        value: flatMap,\n        writable: false\n    });\n} else {\n    // Beware of dragons...\n    Array.prototype.flatMap = flatMap;\n}\n/* random */\nfunction endsWith(self, suffix) {\n    return self.indexOf(suffix, self.length - suffix.length) !== -1;\n}\nexports.endsWith = endsWith;\nfunction last(list) {\n    return list.length >= 1 ? list[list.length - 1] : undefined;\n}\nexports.last = last;\nfunction head(list) {\n    return list.length >= 1 ? list[0] : undefined;\n}\nexports.head = head;\nfunction getPrototype(input) {\n    return input.protoype || input.__proto__;\n}\nexports.getPrototype = getPrototype;\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// dist/worker-rx-5.x.x.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 130);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 299ce472bbf6fc5ab701","module.exports = Rx;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"Rx\"\n// module id = 1\n// module chunks = 0 1 2 3","let scheduler: Rx.TestScheduler = null\n\nlet _ = {\n  get next(): Function {\n    return Rx.ReactiveTest.onNext\n  },\n  get complete(): Function {\n    return Rx.ReactiveTest.onCompleted\n  }\n}\n\nlet experimentProto: any = {\n  get scheduler() {\n    if (scheduler === null) {\n      scheduler = new Rx.TestScheduler()\n      scheduler.advanceTo(0)\n    }\n    return scheduler\n  },\n  get bmi() {\n    return {\n      height$: this.scheduler.createHotObservable([1.76, 1.77, 1.78]\n        .map((v, i) => _.next(i * 100, v)).concat([_.complete(400)])),\n      weight$: this.scheduler.createHotObservable([70, 72, 76, 79, 78, 75]\n        .map((v, i) => _.next(i * 100, v)).concat([_.complete(700)])),\n    }\n  },\n  get lottery() {\n    let start = 2034\n    let year = 1000 * 3600 * 24 * 365.25\n    return {\n      newYear$: Rx.Observable\n        .interval(year, survey.scheduler)\n        .map(t => new Date(Date.UTC(t + start, 0, 1))),\n      veryOldServer: (date: string) => {\n        let unix = new Date(date).getTime() / 1000\n        if (unix > Math.pow(2, 31)) {\n          return Rx.Observable.throw(new Error(\"Crash!\"), this.scheduler)\n        } else {\n          return this.scheduler.createHotObservable(\n            _.next(0, { msg: \"calculating\" }),\n            _.next(10, { msg: \"Happy new year!\", winningTicket: Math.round(Math.random() * 10) }),\n            _.complete(20)\n          )\n        }\n      },\n    }\n  },\n  get imdb() {\n    let inputStream = (text: string) => {\n      let t = 0\n      let messages = []\n      // let random = new Array(11).fill(1).map(_ => Math.floor(Math.random() * 100))\n      let random = [21, 37, 69, 35, 8, 48, 99, 75, 32, 51, 52, 96, 55, 19, 14, 61, 89,\n        70, 44, 69, 21, 19, 87, 64, 52, 96, 12, 41, 33, 69, 28, 35, 23, 82, 94, 73, 79, 24,\n        15, 19, 22, 21, 48, 25, 64, 52, 59, 23, 8, 63, 97, 74, 18, 86, 97, 21, 64, 8, 66, 33,\n        0, 40, 53, 70, 72, 62, 54, 13, 88, 43, 94, 70, 96, 6, 91, 60, 77, 58, 12, 98, 8, 64,\n        96, 9, 28, 86, 45, 65, 94, 28, 55, 39, 34, 46, 2, 93, 17, 84, 3]\n      for (let i = 0; i <= text.length; i++) {\n        t += random.shift()\n        messages.push(_.next(t, text.slice(0, i)))\n      }\n      return this.scheduler.createHotObservable(...messages)\n    }\n    return {\n      _movies: [\n        \"Them\",\n        \"Lion King\",\n        \"Belle & The Beast\",\n        \"Avatar\",\n        \"Harry Potter\",\n        \"Guardians of the Galaxy\",\n        \"House of Cards\",\n        \"Spectre\",\n        \"Interstellar\",\n        \"Iron Man\",\n        \"Terminator Genisys\",\n        \"The Titanic\",\n        \"The Avengers\",\n      ],\n      findMoviesAsync: (term: string) => {\n        let result = this.imdb._movies.filter((movie: string) => movie.toLowerCase().indexOf(term.toLowerCase()) >= 0)\n        let t = 100 * result.length\n        return this.scheduler.createHotObservable(\n          _.next(t, result),\n          _.complete(t + 1)\n        )\n      },\n      inputStream,\n      johnsInput$: inputStream(\"the titanic\"),\n      render: () => { /* would append to DOM here */ },\n    }\n  },\n  get render() {\n    return () => { /* would append to DOM here */ }\n  },\n  get renderSomething() {\n    return () => { /* would append to DOM here */ }\n  },\n  get log() {\n    return () => { /* would write to console */ }\n  },\n  get showError() {\n    return () => { /* would display a warning here */ }\n  },\n  get noop() {\n    return () => { /* no operation */ }\n  },\n}\n\n// Make it global\ndeclare var experiment: any\ndeclare var survey: any\neval(\"var experiment = experimentProto\");\n(global as any).experiment = experimentProto;\neval(\"var survey = experimentProto\");\n(global as any).survey = experimentProto\n\n\n\n// WEBPACK FOOTER //\n// ./src/experiment/sample-data.ts","export type ToWorkerMessage = { type: \"run\", code: string } | { type: \"importScripts\", url: string }\n\nfunction formatError(e: Error): any {\n  return {\n    message: e.message,\n    name: e.name,\n    original: typeof (e as any).original !== \"undefined\" ? formatError((e as any).original) : undefined,\n    stack: e.stack.toString(),\n  }\n}\n\nlet scope = {}\n\n/** \n * Have single location for evil eval,\n * so we can infer it's stackTrace beforehand \n * and strip that from the errors coming from it \n */\nfunction scopedEval(code: string) {\n  // tslint:disable-next-line:only-arrow-functions\n  (function () {\n    // tslint:disable-next-line:no-eval\n    return eval(code)\n  }).call(scope)\n}\n\nfunction evalAndRepackageErrors(code: string): { type: \"result\", result: any } | { type: \"error\", error: any } {\n  try {\n    return { result: scopedEval(code), type: \"result\" }\n  } catch (e) {\n    // Infer eval location\n    try {\n      scopedEval(\"throw new Error('ERROR')\")\n    } catch (dummyError) {\n      // clean up error stack trace\n      let result = /\\n\\s+at Object.<anonymous> \\((.*)\\)/.exec(dummyError.stack)\n      if (result === null) {\n        return { error: e.stack, type: \"error\" }\n      }\n      let stack: string = e.stack.toString()\n      let index = stack.lastIndexOf(`at Object.<anonymous> (${result[1]})`)\n      stack = stack.substring(0, index)\n      stack = stack.split(`eval at <anonymous> (${result[1]}), `).join(\"\")\n      e.stack = stack\n    }\n    return { error: formatError(e), type: \"error\" }\n  }\n}\n\nexport function onWorkerMessage(instrument: () => void): ((e: MessageEvent) => void) {\n  return (e: MessageEvent) => {\n    let message = e.data as ToWorkerMessage\n    switch (message.type) {\n      case \"importScripts\":\n        importScripts(message.url)\n        instrument()\n        break\n      case \"run\":\n        // Execute user code\n        let result = evalAndRepackageErrors(message.code)\n        if (result.type === \"error\") {\n          (postMessage as (m: any) => void)({\n            error: result.error,\n            type: \"error\",\n          })\n        }\n        break\n      default: break\n    }\n  }\n}\n\nif (typeof postMessage === \"function\") {\n  (postMessage as Function)(\"ready\")\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/worker-utils.ts","importScripts(\"instrumentation/rxjs-5.x.x/Rx.js\")\nimport TreePoster from \"../../collector/treePoster\"\nimport \"../../experiment/sample-data\"\nimport { onWorkerMessage } from \"../worker-utils\"\nimport { TreeCollector } from \"./collector\"\nimport Instrumentation from \"./instrumentation\"\n\nonmessage = onWorkerMessage(() => {\n  let poster = new TreePoster(m => (postMessage as (m: any) => void)(m))\n  let collector = new TreeCollector(poster, Rx as any)\n  let instrumentation: Instrumentation = new Instrumentation(collector, Rx as any)\n  instrumentation.setup()\n  console.info(\"Ready for RxJS 5 instrumentation\");\n  (Rx as any).version = \"5.3.0\"\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-5.x.x/worker.ts","// tslint:disable:no-constructor-vars\n// tslint:disable:object-literal-key-quotes\nimport { ICallRecord, ICallStart } from \"../../collector/callrecord\"\nimport { RxCollector } from \"../../collector/ICollector\"\n\n// Allow either external scoped Rx or local imported Rx to be used\nimport * as RxType from \"rxjs\"\nimport { Scheduler } from \"rxjs/Scheduler\"\ndeclare let Rx: any\n\nexport let InstrumentedRx: typeof RxType = typeof Rx === \"undefined\" ? RxType : Rx\n\nlet i = 0\nexport default class Instrumentation {\n  private subjects: { [name: string]: any; }\n  private prototypes: any[] = []\n  private open: any[] = []\n  private calls: (ICallStart | ICallRecord)[] = []\n\n  constructor(private collector: RxCollector, private Rx: typeof RxType) {\n    this.collector = collector\n    this.subjects = {\n      \"Observable\": Rx.Observable.prototype,\n      \"Subscriber\": Rx.Subscriber.prototype,\n      \"ObservableStatic\": Rx.Observable,\n      \"SubjectStatic\": Rx.Subject,\n      \"Subject\": Rx.Subject.prototype,\n      \"Scheduler\": (Rx.Scheduler.async as any).__proto__.__proto__,\n    }\n  }\n\n  public setup(target?: any, targetName?: string): void {\n    if (typeof target !== \"undefined\") {\n      this.setupPrototype(target, targetName)\n    } else {\n      Object.keys(this.subjects)\n        .filter(name => typeof this.subjects[name] !== \"undefined\")\n        .forEach(name => this.setup(this.subjects[name], name))\n    }\n    /* TODO:\n     - schedulers\n     - constructors\n    */\n  }\n\n  public teardown(): void {\n    let properties: { key: string, target: any }[] = this.prototypes\n      .map(target => Object.keys(target).map(key => ({ key, target })))\n      .reduce((prev, next) => prev.concat(next), [])\n\n    // Methods\n    properties\n      .filter(({ key, target }) => typeof target[key] === \"function\")\n      .forEach(({ key, target }) => {\n        target[key] = this.deinstrument(target[key])\n      })\n\n    // Prototypes\n    this.prototypes\n      .filter(proto => \"__dynamicallyInstrumented\" in proto)\n      .forEach(proto => delete proto.__dynamicallyInstrumented)\n\n    this.prototypes = []\n  }\n\n  public callstacks = [] as ICallRecord[][]\n\n  public ignore = false\n\n  /* tslint:disable:only-arrow-functions */\n  /* tslint:disable:no-string-literal */\n  /* tslint:disable:no-string-literal */\n  public apply(\n    originalFn: Function,\n    target: any, thisArg: any, argumentsList: any[],\n    method: string,\n    subjectName: string,\n  ): any {\n    if (this.ignore) {\n      return originalFn.apply(target, argumentsList)\n    }\n\n    // find more\n    argumentsList\n      .filter(hasRxObservablePrototype)\n      .filter((v: any) => !isInstrumented(v))\n      .forEach((t: any) => this.setupPrototype(t))\n\n    let call: ICallStart = {\n      arguments: [].slice.call(argumentsList, 0),\n      childs: [],\n      id: i++,\n      method,\n      subject: thisArg,\n      subjectName,\n      tick: 0,\n      time: now(),\n    }\n\n    // Prepare\n    this.calls.push(call)\n    if (this.open.length > 0) {\n      call.parent = this.open[this.open.length - 1]\n      call.parent.childs.push(call)\n    }\n    this.open.push(call)\n\n    this.callstacks.push(this.open.slice(0))\n\n    // Actual method\n    this.ignore = true\n    let instanceLogger = this.collector.before(call, this.open.slice(0, -1))\n    this.ignore = false\n    let returned = target.apply(call.subject, [].map.call(\n      call.arguments,\n      this.wrap.bind(this)\n    ))\n\n    let end: ICallRecord = call as ICallRecord\n    end.returned = returned\n\n    this.ignore = true\n    instanceLogger.after(end)\n    this.ignore = false;\n\n    // find more\n    ([end.returned])\n      .filter(hasRxObservablePrototype)\n      .filter((v: any) => !isInstrumented(v))\n      .forEach((t: any) => this.setupPrototype(t))\n\n    // Cleanup\n    this.open.pop()\n    return end.returned\n  }\n\n  /* tslint:disable:only-arrow-functions */\n  /* tslint:disable:no-string-literal */\n  /* tslint:disable:no-string-literal */\n  public instrument(fn: Function, method: string, subjectName: string): Function {\n    let self = this\n    let instrumented = new Proxy(fn, {\n      apply: (target: any, thisArg: any, argumentsList: any[]) => {\n        return this.apply(fn, target, thisArg, argumentsList, method, subjectName)\n      },\n      construct: (target: { new (...args: any[]): any }, args) => {\n        console.warn(\"TODO, instrument constructor\", target, args)\n        return new target(...args)\n      },\n      get: (target: any, property: PropertyKey): any => {\n        if (property === \"__instrumentedBy\") { return self }\n        if (property === \"__originalFunction\") { return fn }\n        return (target as any)[property]\n      },\n      ownKeys: (target: any) => {\n        return Object.getOwnPropertyNames(target).concat([\"__instrumentedBy\", \"__originalFunction\"])\n      },\n    })\n    return instrumented\n  }\n\n  public deinstrument(fn: Function): Function {\n    return fn.__originalFunction && this.deinstrument(fn.__originalFunction) || fn\n  }\n\n  public setupPrototype(prototype: any, name?: string) {\n    if (typeof prototype === \"undefined\") {\n      return\n    }\n    prototype.__dynamicallyInstrumented = true\n    let methods = Object.keys(prototype)\n      .filter((key) => typeof prototype[key] === \"function\")\n      .filter(key => !isInstrumented(prototype[key], this))\n\n    if (methods.length) {\n      // store, preparing for teardown\n      this.prototypes.push(prototype)\n\n      methods.forEach(key => {\n        prototype[key] = this.instrument(prototype[key], key, name || prototype.constructor.name)\n      })\n    }\n  }\n\n  private wrap<T>(input: T): T {\n    if (isObservable(this.Rx, input) && !prototypeIsInstrumented((input as any).prototype)) {\n      this.setupPrototype((input as any).prototype, input.constructor.name)\n      return input as any\n    }\n    if (\n      isScheduler(this.Rx, input) && !isInstrumented((input as any).schedule) ||\n      isObserver(this.Rx, input) && !isInstrumented((input as any).next)\n    ) {\n      return new Proxy(input, {\n        get: (thisArg: any, name: string) => {\n          let original = thisArg[name]\n          if (name === \"__isInstrumentationWrapper\") { return true }\n          if (name === \"hasOwnProperty\") { return original }\n          if (typeof original === \"function\") {\n            return this.instrument(original, name, (input as any).constructor.name)\n          }\n          return original\n        },\n        ownKeys: (target: any) => {\n          return Object.getOwnPropertyNames(target).concat([\"__isInstrumentationWrapper\"])\n        },\n      })\n    }\n    if (typeof input === \"function\" && !isInstrumented(input, this)) {\n      return this.instrument(input, (input as any).name || \"lambda\", (input as any).name || \"lambda\") as any as T\n    }\n    return input\n  }\n}\n\nfunction now() {\n  return typeof performance !== \"undefined\" ? performance.now() : Date.now()\n}\n\n/* tslint:disable:interface-name */\nexport interface Function {\n  caller?: Function\n  __originalFunction?: Function | null\n  apply(subject: any, args: any[] | IArguments): any\n}\n\nfunction hasRxObservablePrototype(Rx: typeof RxType, input: any): boolean {\n  return typeof input === \"object\" && Rx.Observable.prototype.isPrototypeOf(input)\n}\n\nexport function isInstrumented(fn: Function, by?: Instrumentation): boolean {\n  if (typeof by === \"undefined\") {\n    return ((\n      typeof fn.__originalFunction === \"function\" ?\n        1 + (isInstrumented(fn.__originalFunction) as any) as number :\n        0)\n    ) as any as boolean\n  }\n  if ((fn as any).__instrumentedBy === by) { return true }\n  let orig = (fn as any).__originalFunction\n  return typeof orig === \"function\" && isInstrumented(orig, by)\n}\n\nfunction prototypeIsInstrumented(input: any): boolean {\n  return typeof input === \"object\" && input !== null && input.hasOwnProperty(\"__dynamicallyInstrumented\")\n}\n\nexport function isObservable<T>(Rx: typeof RxType, v: any): v is RxType.Observable<T> {\n  return typeof v === \"object\" && (\n    v instanceof Rx.Observable || v !== null && typeof v.subscribe === \"function\"\n  )\n}\nexport function isSubscription(Rx: typeof RxType, v: any): v is RxType.Subscription & any {\n  return typeof v === \"object\" && v instanceof Rx.Subscriber\n}\nexport function isObserver(Rx: typeof RxType, v: any): v is RxType.Subscriber<any> {\n  return typeof v === \"object\" &&\n    (v instanceof Rx.Subscriber || v !== null && typeof v.next === \"function\") &&\n    /* Prevent emptyObserver as a subscriber \n     * (since it is statically used everywhere,  effectively linking all streams...) \n     */\n    v.constructor !== Object\n}\nexport function isSubject(Rx: typeof RxType, v: any): v is RxType.Subject<any> {\n  return typeof v === \"object\" && (v instanceof Rx.Subject || v !== null && typeof v.next === \"function\" && typeof v.subscribe === \"function\")\n}\nexport function isScheduler(Rx: typeof RxType, v: any): v is Scheduler & any {\n  return typeof v === \"object\" && v !== null && \"now\" in v && \"schedule\" in v\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-5.x.x/instrumentation.ts","import { StackFrame } from \"./stackframe\"\n\nexport type ICallRecord = ICallStart & ICallEnd\n\nexport interface ICallStart {\n  id: number | string | null\n  subject: any\n  subjectName: string\n  method: string\n  arguments: any[]\n  stack?: StackFrame | string\n  time: number\n  parent?: ICallStart\n  childs: (ICallRecord | ICallStart)[]\n  tick: number\n}\n\nexport interface ICallEnd {\n  returned: any | null\n}\n\ntype CallRecordType = \"setup\" | \"subscribe\" | \"event\"\n\nexport function callRecordType(record: ICallStart) {\n  if (typeof record === \"undefined\" || typeof record.subject === \"undefined\") {\n    return undefined\n  }\n  if (record.subjectName === \"Observable\" ||\n    record.subjectName === \"Observable.prototype\" ||\n    record.subjectName === \"ObservableBase.prototype\" ||\n    record.subjectName &&\n    record.subjectName.indexOf(\"Observable\") >= 0\n  ) {\n    if (record.method === \"subscribe\" ||\n      record.method === \"_subscribe\" ||\n      record.method === \"__subscribe\" ||\n      record.method === \"_trySubscribe\"\n    ) {\n      return \"subscribe\"\n    }\n    return \"setup\"\n  } else {\n    return \"event\"\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/callrecord.ts","// tslint:disable:no-constructor-vars\nimport { ICallStart } from \"./callrecord\"\nimport { formatArguments } from \"./logger\"\n\nexport type IEventType = \"next\" | \"error\" | \"complete\" | \"subscribe\" | \"dispose\" | \"connect\"\n\nexport type IEvent = Next<any> | Subscribe | Complete | Error | Dispose | Connect\n\nexport type Timing = {\n  scheduler: string\n  clocks: { [id: string]: number }\n}\n\nexport class Event {\n  public static fromRecord(record: ICallStart, timing: Timing, source?: string): IEvent | null {\n    return Event.fromCall(record.method, record.arguments, timing, source)\n  }\n  public static fromCall(method: string, args: any[], timing: Timing, source?: string): IEvent {\n    switch (method) {\n      case \"next\":\n      case \"onNext\":\n        return new Next(timing, args[0], source)\n      case \"error\":\n      case \"onError\":\n      case \"fail\":\n        return new Error(timing, new ErrorInstance(args[0]), source)\n      case \"complete\":\n      case \"onCompleted\":\n        return new Complete(timing, source)\n      case \"connect\":\n        return new Connect(timing, source)\n      case \"subscribe\":\n      case \"_subscribe\":\n      case \"__subscribe\":\n        return new Subscribe(timing, source)\n      case \"dispose\":\n      case \"unsubscribe\":\n        return new Dispose(timing, source)\n      default: break\n      // console.log(\"Unknown event\", record)\n    }\n  }\n  public static fromJson(input: any): IEvent | null {\n    switch (input.type) {\n      case \"next\": return new Next(input.timing, input.value, input.source)\n      case \"error\": return new Error(input.timing, input.error, input.source)\n      case \"complete\": return new Complete(input.timing, input.source)\n      case \"subscribe\": return new Subscribe(input.timing, input.source)\n      case \"dispose\": return new Dispose(input.timing, input.source)\n      default: return null\n    }\n  }\n  constructor(public type: IEventType, public timing: Timing, public source?: string) { }\n}\n\nexport class Next<T> extends Event {\n  public value: string\n  public type: \"next\"\n  constructor(timing: Timing, value: T, source?: string) {\n    super(\"next\", timing, source)\n    this.value = formatArguments([value])\n  }\n}\n\nexport class ErrorInstance {\n  public name: string\n  public message: string\n  public stack: string\n  public constructor(someError: SyntaxError) {\n    this.name = someError.name\n    this.message = someError.message\n    this.stack = someError.stack\n  }\n}\n\nexport class Error extends Event {\n  public error: ErrorInstance\n  public type: \"error\"\n  constructor(timing: Timing, error: ErrorInstance, source?: string) {\n    super(\"error\", timing, source)\n    this.error = error\n  }\n}\n\nexport class Complete extends Event {\n  public type: \"complete\"\n  constructor(timing: Timing, source?: string) { super(\"complete\", timing, source) }\n}\n\nexport class Subscribe extends Event {\n  public type: \"subscribe\"\n  constructor(timing: Timing, source?: string) { super(\"subscribe\", timing, source) }\n}\n\nexport class Connect extends Event {\n  public type: \"connect\"\n  constructor(timing: Timing, source?: string) { super(\"connect\", timing, source) }\n}\n\nexport class Dispose extends Event {\n  public type: \"dispose\"\n  constructor(timing: Timing, source?: string) { super(\"dispose\", timing, source) }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/event.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","import { IEvent } from \"../collector/event\"\n\nexport type Id = string\n\nexport interface MethodCall {\n  method: string\n  args: IArguments\n}\n\nexport interface IObservableTree {\n  id: Id\n  names?: string[]\n  calls?: MethodCall[]\n  sources?: IObservableTree[]\n  scheduler?: ISchedulerInfo\n  setSources(sources: IObservableTree[]): IObservableTree\n  addMeta(meta: any): IObservableTree\n}\n\nexport interface IObserverTree {\n  id: Id\n  names?: string[]\n  observable: IObservableTree\n  sink?: IObserverTree\n  inflow?: IObserverTree[]\n  events: IEvent[]\n  setOuter(sinks: IObserverTree): IObserverTree\n  setSink(sinks: IObserverTree[]): IObserverTree\n  addInflow(inflow: IObserverTree): IObserverTree\n  setObservable(observable: IObservableTree[]): IObserverTree\n  addEvent(event: IEvent): IObserverTree\n}\n\n//                     O->O *-*    | O->S 1-1            | S->S *-*                \nexport type EdgeType = \"addSource\" | \"setObserverSource\" | \"addObserverDestination\" | \"addObserverOuter\"\nexport type NodeType = \"observable\" | \"subject\" | \"observer\"\n\nexport interface ITreeLogger {\n  addNode(id: Id, type: NodeType, timing?: ISchedulerInfo): void\n  addMeta(id: Id, meta: any): void\n  addEdge(v: Id, w: Id, type: EdgeType, meta?: any): void\n  addScheduler(id: Id, scheduler: ISchedulerInfo): void\n  addContraction(id: Id, nodes: Id[]): void\n}\n\nexport class ObservableTree implements IObservableTree {\n  public id: Id\n  public names?: string[]\n  public calls?: MethodCall[]\n  public sources?: IObservableTree[]\n  public scheduler?: ISchedulerInfo\n\n  public logger?: ITreeLogger\n  constructor(id: string, name?: string, logger?: ITreeLogger, scheduler?: ISchedulerInfo) {\n    this.id = id\n    this.scheduler = scheduler\n    if (name) { this.names = [name] }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"observable\", scheduler && Object.assign({}, scheduler))\n      logger.addMeta(id, { names: name })\n    }\n  }\n\n  public setSources(sources: IObservableTree[]): IObservableTree {\n    this.sources = sources\n    if (this.logger) {\n      sources.forEach(s => this.logger.addEdge(s.id, this.id, \"addSource\", { label: \"source\" }))\n    }\n    return this\n  }\n\n  public addMeta(meta: any): IObservableTree {\n    if (this.logger) {\n      this.logger.addMeta(this.id, meta)\n    }\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth < 100) {\n      return `ObservableTree(${this.id}, ${this.names}, ${\n        (this.sources || []).map(s => pad(inspect(s, depth + 2, opts), 2))\n        })`\n    }\n  }\n}\n\nexport class ObserverTree implements IObserverTree {\n  public id: Id\n  public names?: string[]\n  public observable: IObservableTree\n  public sink?: IObserverTree\n  public outer?: IObserverTree\n  public inflow?: IObserverTree[]\n  public events: IEvent[] = []\n  public scheduler?: ISchedulerInfo\n\n  public logger?: ITreeLogger\n  constructor(id: string, name?: string, logger?: ITreeLogger) {\n    this.id = id\n    if (name) { this.names = [name] }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"observer\")\n      logger.addMeta(id, { names: name })\n    }\n  }\n\n  public setSink(sinks: IObserverTree[]): IObserverTree {\n    if (this.sink === sinks[0]) {\n      return this\n    }\n    this.sink = sinks[0]\n    sinks.forEach(s => s.addInflow(this))\n    if (this.logger) {\n      sinks.forEach(s => this.logger.addEdge(this.id, s.id, \"addObserverDestination\", { label: \"destination\" }))\n    }\n    return this\n  }\n\n  public setOuter(outer: IObserverTree): IObserverTree {\n    this.outer = outer\n    outer.addInflow(this)\n    if (this.logger) {\n      this.logger.addEdge(this.id, outer.id, \"addObserverOuter\", { label: \"outer\" })\n    }\n    return this\n  }\n\n  public addInflow(inflow: IObserverTree) {\n    this.inflow = this.inflow || []\n    if (this.inflow.indexOf(inflow) >= 0) {\n      return this\n    }\n    this.inflow.push(inflow)\n    return this\n  }\n  public setObservable(observable: IObservableTree[]): IObserverTree {\n    if (this.observable) {\n      if (this.observable !== observable[0]) {\n        console.log(\"Adding second observable to \", this)\n        console.log(\"becoming\", observable)\n        console.log(\"was\", this.observable)\n        console.log(new Error().stack.split(\"\\n\").filter(l => l.indexOf(\"instrumentation.ts\") < 0).slice(0, 5).join(\"\\n\"))\n      } else {\n        return this\n      }\n    }\n    this.observable = observable[0]\n    if (this.logger) {\n      observable.forEach(o => this.logger.addEdge(o.id, this.id, \"setObserverSource\", { label: \"observable\" }))\n    }\n    return this\n  }\n\n  public addEvent(event: IEvent): IObserverTree {\n    if (this.logger) {\n      this.logger.addMeta(this.id, { events: event })\n    }\n    this.events.push(event)\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth > 30) {\n      return \"depth 30 reached\"\n    }\n    if (this.sink) {\n      return `ObserverTree(${this.id}, ${this.names}, \\n${pad(inspect(this.sink, depth + 1, opts), 1)}\\n)`\n    } else {\n      return `ObserverTree(${this.id}, ${this.names})`\n    }\n  }\n}\n\nfunction pad(str: string, depth: number): string {\n  if (depth <= 0 || !str) {\n    return str\n  }\n  return pad(str.split(\"\\n\").map(l => \"  \" + l).join(\"\\n\"), depth - 1)\n}\n\nfunction inspect(i: any, depth: number, opts: any): string {\n  if (i && i.inspect) {\n    return i.inspect(depth, opts)\n  } else if (i && i.toString) {\n    return i.toString()\n  } else {\n    return i\n  }\n}\n\nexport class SubjectTree implements ObservableTree, ObserverTree {\n  public id: Id\n  public names?: string[]\n  public args: IArguments\n  public inflow?: IObserverTree[]\n  public calls?: MethodCall[]\n  public sources?: IObservableTree[]\n  public observable: IObservableTree\n  public sink?: IObserverTree\n  public sinks?: IObserverTree[]\n  public events: IEvent[] = []\n  public scheduler?: ISchedulerInfo\n\n  // Mixin Observable & Observer methods\n  public setSink: (sinks: IObserverTree[], name?: string) => this\n  public setOuter: (sinks: IObserverTree) => this\n  public addInflow: (inflow: IObserverTree) => this\n  public setObservable: (observable: IObservableTree[]) => IObserverTree\n  public setSources: (sources: IObservableTree[]) => IObservableTree\n  public addMeta: (meta: any) => this\n  public addEvent: (event: IEvent) => IObserverTree\n  public logger?: ITreeLogger\n\n  constructor(id: string, name?: string, logger?: ITreeLogger, scheduler?: ISchedulerInfo) {\n    this.id = id\n    this.scheduler = scheduler\n    if (name) {\n      this.names = [name]\n    }\n    if (logger) {\n      this.logger = logger\n      logger.addNode(id, \"subject\", scheduler && Object.assign({}, scheduler))\n      logger.addMeta(id, { names: name })\n    }\n    this.observable = this\n  }\n\n  public addSink(sinks: IObserverTree[], name?: string) {\n    let prev = this.sinks || []\n    this.setSink(sinks, name)\n    this.sinks = prev.concat(sinks)\n    return this\n  }\n\n  public inspect(depth: number, opts: any) {\n    if (depth > 30) {\n      return \"Too deep\"\n    }\n    return `SubjectTree(${this.id}, ${this.names}, \\n${pad(inspect(this.sink, depth + 2, opts), 2)}\\n)`\n  }\n}\n\napplyMixins(SubjectTree, [ObservableTree, ObserverTree])\n\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      // Only mix non-defined's, causing implemented methods to act as overloads. \n      // Allows mixin to have a specialized constructor for example.\n      if (typeof derivedCtor.prototype[name] === \"undefined\") {\n        derivedCtor.prototype[name] = baseCtor.prototype[name]\n      }\n    })\n  })\n}\n\nexport type SchedulerType = \"immediate\" | \"recursive\" | \"timeout\" | \"virtual\"\n\nexport type ISchedulerInfo = {\n  id: string\n  name: string\n  type: SchedulerType\n  clock: number\n}\n\nexport class SchedulerInfo implements ISchedulerInfo {\n  public id: string\n  public name: string\n  public type: SchedulerType\n  public clock: number\n\n  constructor(\n    id: string, name: string,\n    type: SchedulerType,\n    clock: number, logger?: ITreeLogger\n  ) {\n    this.id = id\n    this.name = name\n    this.type = type\n    this.clock = clock\n    logger.addScheduler(this.id, this)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/oct/oct.ts","import { EdgeType, ISchedulerInfo, ITreeLogger, NodeType } from \"../oct/oct\"\n\nexport default class TreePoster implements ITreeLogger {\n  private post: (message: any) => void\n  constructor(cb?: (message: any) => void) {\n    if (typeof cb === \"function\") {\n      this.post = cb\n    } else if (typeof window === \"object\" && window.parent) {\n      this.post = m => window.parent.postMessage(m, window.location.origin)\n    } else {\n      this.post = m => { /* intentionally left blank */ }\n      console.error(\"Using Window.postMessage logger in non-browser environment\", new Error())\n    }\n  }\n  public addNode(id: string, type: NodeType, scheduler?: ISchedulerInfo): void {\n    this.post({ id, type, scheduler })\n  }\n  public addMeta(id: string, meta: any): void {\n    this.post({ id, meta })\n  }\n  public addEdge(v: string, w: string, type: EdgeType, meta?: any): void {\n    this.post({ v, w, type, meta })\n  }\n  public addScheduler(id: string, scheduler: ISchedulerInfo): void {\n    this.post({ id, scheduler })\n  }\n  public addContraction(id: string, nodes: string[]): void {\n    this.post({ id, contract: nodes })\n  }\n\n  public reset() {\n    this.post(\"reset\")\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/treePoster.ts","import { ICallRecord, ICallStart, callRecordType } from \"../../collector/callrecord\"\nimport { Event, IEvent, Timing } from \"../../collector/event\"\nimport { RxCollector } from \"../../collector/ICollector\"\nimport { formatArguments, formatObject } from \"../../collector/logger\"\nimport {\n  IObservableTree, IObserverTree, ISchedulerInfo, ITreeLogger,\n  ObservableTree, ObserverTree, SchedulerInfo, SchedulerType, SubjectTree,\n\n} from \"../../oct/oct\"\nimport { getPrototype } from \"../../prelude\"\nimport { isObservable, isObserver, isScheduler, isSubject } from \"./instrumentation\"\nimport * as RxType from \"rxjs\"\nimport { IScheduler } from \"rxjs/Scheduler\"\n\nlet debug = false\n\ntype Role = \"observable\" | \"observer\" | \"scheduler\"\n\nfunction getScheduler<T>(obs: RxType.Observable<T>, record?: ICallStart): IScheduler | undefined {\n  return (obs as any).scheduler ||\n    (obs as any)._scheduler ||\n    (obs as any).operator && (obs as any).operator.scheduler ||\n    record && ([].filter.call(record.arguments || [], isScheduler)[0])\n}\n\nclass SequenceTicker {\n  public last = 0\n  public used = false\n\n  public next(): void {\n    if (this.used) {\n      this.used = false\n      this.last++\n    }\n  }\n  public get(): number {\n    this.used = true\n    return this.last\n  }\n}\n\nexport class TreeCollector implements RxCollector {\n  public call: ICallRecord\n  public symbol: symbol\n  public subSymbol: symbol\n  public nextId = 1\n  public logger: ITreeLogger\n  private eventSequencer = new SequenceTicker()\n\n  private wireStarts: WireStart[] = []\n  private wires: Wire[] = []\n\n  public otree: IObservableTree[] = []\n  public stree: IObserverTree[] = []\n\n  private schedulers: { scheduler: IScheduler, info: ISchedulerInfo }[] = []\n  private scheduler?: { scheduler: IScheduler, info: ISchedulerInfo }\n\n  public constructor(logger: ITreeLogger, private Rx: typeof RxType) {\n    this.logger = logger\n    this.symbol = Symbol(\"tree\")\n    this.subSymbol = Symbol(\"tree2\")\n  }\n\n  public schedule(scheduler: IScheduler, method: string, action: Function, state: any) {\n    this.eventSequencer.next()\n  }\n\n  public before(record: ICallStart, parents?: ICallStart[]): this {\n    // tag all encountered Observables & Subscribers\n    [record.subject, ...record.arguments].forEach(this.tag.bind(this, undefined))\n\n    if (record.method === \"schedule\") {\n      this.schedule(record.subject, record.method, undefined, undefined)\n    }\n\n    // Record next/error/complete/dispose events\n    if (callRecordType(record) === \"event\" && isObserver(this.Rx, record.subject)) {\n      let event = Event.fromRecord(record, this.getTiming())\n      if (event) {\n        let observer = this.tag(\"observer\", record.subject)\n        this.addEvent(observer, event, record.arguments[0])\n      }\n    }\n    // Record subscribe-event\n    if (callRecordType(record) === \"subscribe\" && isObservable(this.Rx, record.subject) && isObserver(this.Rx, record.arguments[0])) {\n      let event = Event.fromRecord(record, this.getTiming())\n      if (event) {\n        let observer = this.tag(\"observer\", record.arguments[0], record)\n        this.addEvent(observer, event)\n      }\n    }\n    return this\n  }\n\n  public after(record: ICallRecord): void {\n    this.call = record;\n    // tag all encountered Observables & Subscribers\n    [record.returned].forEach(t => this.tag(undefined, t, record))\n\n    if (isObservable(this.Rx, record.returned)) {\n      this.linkSources(record.returned)\n\n      let shouldName = isFirstOpOntoSubject(record) && (\n        // b = a.map(lambda) => linked by source property\n        isSource(record.subject, record.returned) ||\n        // Observable.of() has record.subject == static Observable\n        !isObservable(this.Rx, record.subject) && !hasSource(record.returned)\n      )\n\n      if (shouldName) {\n        let tree = this.tag(\"observable\", record.returned)\n        tree.addMeta({\n          calls: {\n            args: this.formatArguments(...record.arguments),\n            method: record.method,\n            subject: `callRecord.subjectName ${\n            this.hasTag(record.subject) &&\n            this.tag(\"observable\", record.subject).id\n            }`,\n          },\n        })\n      }\n    }\n\n    if (callRecordType(record) === \"subscribe\") {\n      if (isObserver(this.Rx, record.arguments[0])) {\n        this.linkSubscribeSource(record.arguments[0], record.subject)\n        this.linkSinks(record.arguments[0])\n      } else if (isObserver(this.Rx, record.returned)) {\n        this.linkSubscribeSource(record.returned, record.subject)\n        this.linkSinks(record.returned)\n      }\n    }\n  }\n\n  public getEventReason(record: ICallStart): string | undefined {\n    // return [record.parent, record.parent && record.parent.parent]\n    //   .filter(r => r && isObserver(r.subject) && this.hasTag(r.subject))\n    //   .map(r => this.tag(r.subject).id)[0]\n    return\n  }\n\n  public addEvent(observer: IObserverTree, event: IEvent, value?: any) {\n    if (typeof event === \"undefined\") { return }\n    // Enrich higher order events\n    if (event.type === \"next\" && isObservable(this.Rx, value)) {\n      event.value = {\n        id: this.tag(\"observable\", value).id,\n        type: value.constructor.name,\n      } as any as string\n    }\n\n    if (!observer.inflow || observer.inflow.length === 0) {\n      this.eventSequencer.next()\n    }\n\n    event.timing = this.getTiming()\n    observer.addEvent(event)\n  }\n\n  private hasTag(input: any): boolean {\n    return typeof input === \"object\" && input !== null && typeof input[this.symbol] !== \"undefined\"\n  }\n\n  private tag(role: \"observable\", input: any, record?: ICallStart): IObservableTree\n  private tag(role: \"observer\", input: any, record?: ICallStart): IObserverTree\n  private tag(role: \"scheduler\", input: any, record?: ICallStart): ISchedulerInfo\n\n  private tag(role: Role | undefined, input: any, record?: ICallStart):\n    IObserverTree | IObservableTree | ISchedulerInfo | undefined {\n    if (typeof input !== \"object\" || input === null) {\n      return undefined\n    }\n\n    let symbol = this.symbol\n    if (isSubject(this.Rx, input) && role === \"observer\") {\n      symbol = this.subSymbol\n    }\n\n    if (input.hasOwnProperty(symbol) && typeof input[symbol] !== \"undefined\") {\n      return input[symbol]\n    }\n\n    if (isSubject(this.Rx, input)) {\n      if (role === \"observable\") {\n        let tree = (input as any)[this.symbol] = new ObservableTree(`${this.nextId++}`,\n          input.constructor.name, this.logger, this.getScheduler(input))\n        this.linkSources(input)\n        this.addo(tree)\n        this.linkSubject(tree, (input as any)[this.subSymbol])\n        return tree\n      } else if (role === \"observer\") {\n        let tree = (input as any)[this.subSymbol] = new SubjectTree(`${this.nextId++}`,\n          input.constructor.name, this.logger, this.getScheduler(input))\n        this.linkSinks(input)\n        this.adds(tree)\n        this.linkSubject((input as any)[this.symbol], tree)\n        return tree\n      }\n    }\n    if (isObservable(this.Rx, input)) {\n      /* this hack is neccessary since subscribeToResult does not call subscribe on ScalarObservables */\n      if (input && input.constructor && input.constructor.name === \"ScalarObservable\") {\n        input._isScalar = false\n      }\n      /* end of ScalarObservable hack */\n      let tree = (input as any)[symbol] = new ObservableTree(`${this.nextId++}`,\n        input.constructor.name, this.logger, this.getScheduler(input, record)\n      )\n      this.linkSources(input)\n      this.addo(tree)\n      return tree\n    }\n    if (isObserver(this.Rx, input)) {\n      let tree = (input as any)[symbol] = new ObserverTree(`${this.nextId++}`,\n        input.constructor.name, this.logger)\n      this.linkSinks(input)\n      this.adds(tree)\n      return tree\n    }\n    if (isScheduler(this.Rx, input)) {\n      let scheduler = input as IScheduler\n      let clock = scheduler.now()\n      let type = schedulerType(this.Rx, input)\n      let info = new SchedulerInfo(\n        `${this.nextId++}`, getPrototype(scheduler).constructor.name,\n        type, clock, this.logger\n      );\n      (input as any)[symbol] = info;\n      this.schedulers.push({ scheduler, info })\n      return info\n    }\n    return\n  }\n\n  private adds(tree: IObserverTree) {\n    this.stree.push(tree)\n  }\n\n  private addo(tree: IObservableTree) {\n    this.otree.push(tree)\n  }\n\n  private getScheduler<T>(input: RxType.Observable<T>, record?: ICallStart): ISchedulerInfo {\n    if (isObservable(this.Rx, input) && getScheduler(input, record)) {\n      return this.tag(\"scheduler\", getScheduler(input, record))\n    }\n    return\n  }\n\n  private getTiming(): Timing {\n    let clocks: { [id: string]: number } = { tick: this.eventSequencer.get() }\n    if (this.scheduler) {\n      clocks[this.scheduler.info.id] = this.scheduler.scheduler.now()\n      return Object.assign({\n        scheduler: this.scheduler.info.id,\n        clocks,\n      })\n    }\n    return {\n      clocks,\n      scheduler: \"tick\",\n    }\n  }\n\n  private linkSources<T>(observable: RxType.Observable<T>) {\n    let sources = [(observable as any).source, ...((observable as any)._sources || [])]\n      .filter(isObservable)\n      .map(o => this.tag(\"observable\", o))\n    if (sources.indexOf(this.tag(\"observable\", observable)) >= 0) {\n      console.log(\"Reference loop\", observable, this.call)\n    }\n    (this.tag(\"observable\", observable)).setSources(sources)\n  }\n\n  private linkSinks<T>(observer: RxType.Observer<T>) {\n    if (isObservable(this.Rx, observer)) {\n      return\n    }\n    let sinkOpt = [(observer as any).destination]\n      .filter(o => isObserver(this.Rx, o) || isSubject(this.Rx, o))\n      .map(o => this.tag(\"observer\", o))\n    this.tag(\"observer\", observer).setSink(sinkOpt)\n    let parentOpt = [(observer as any).parent]\n      .filter(isObserver.bind(null, this.Rx))\n      .map(o => this.tag(\"observer\", o))\n    parentOpt.forEach(p => (this.tag(\"observer\", observer)).setOuter(p))\n  }\n\n  private linkSubscribeSource<T>(observer: RxType.Observer<T>, observable: RxType.Observable<T>) {\n    if (isSubject(this.Rx, observable)) {\n      let subjectAsObs = this.tag(\"observable\", observable) as IObservableTree\n      let subject = this.tag(\"observer\", observable) as SubjectTree\n      if (subjectAsObs.sources.length === 0) {\n        subject.addSink([this.tag(\"observer\", observer)])\n        this.tag(\"observer\", observer).setObservable([subjectAsObs])\n        return\n      }\n    }\n    let stree = this.tag(\"observer\", observer)\n    let otree = this.tag(\"observable\", observable)\n    if (typeof stree.observable === \"undefined\") {\n      stree.setObservable([otree])\n    }\n  }\n\n  /**\n   * Create link representing the domain border crossing of the Subject\n   * @param a observable-side\n   * @param b observer-side\n   */\n  private linkSubject(a: IObservableTree, b: IObserverTree) {\n    if (typeof a !== \"undefined\" && typeof b !== \"undefined\" && typeof b.observable === \"undefined\") {\n      b.setObservable([a])\n    }\n  }\n\n  private formatArguments(...args: any[]): any {\n    return args.map(arg => {\n      if (typeof arg === \"number\" || typeof arg === \"string\") {\n        return { type: typeof arg, value: formatArguments([arg]) }\n      }\n      if (typeof arg === \"object\") {\n        if (Array.isArray(arg)) {\n          return { type: \"array\", value: formatArguments(arg) }\n        } else if (this.hasTag(arg)) {\n          return { $ref: this.tag(undefined, arg).id, type: \"ref\", value: formatObject(arg, 0) }\n        } else { return { type: \"object\", value: formatArguments([arg]) } }\n      }\n      if (typeof arg === \"function\") {\n        return { type: \"function\", value: formatArguments([arg]) }\n      }\n    })\n  }\n}\n\nfunction printStack(record?: ICallStart): string {\n  if (typeof record === \"undefined\") {\n    return \"\"\n  }\n  return \"\\n\\t\" + `${record.subject.constructor.name}.${record.method}(${formatArguments(record.arguments)})` +\n    (record.parent ? printStack(record.parent) : \"\")\n}\n\nfunction callStackDepth(record: ICallStart): number {\n  return typeof record.parent === \"undefined\" ? 1 : 1 + callStackDepth(record.parent)\n}\n\nfunction generate<T>(seed: T, next: (acc: T) => T | undefined | null): T[] {\n  if (typeof seed === \"undefined\" || seed === null) {\n    return []\n  } else {\n    return [seed, ...generate(next(seed), next)]\n  }\n}\n\nclass Wire {\n  // tslint:disable-next-line:no-constructor-vars\n  constructor(public call: ICallStart, public from: IObservableTree[], public to: IObservableTree[]) {\n    (this as any)._depth = this.depth\n  }\n\n  public get depth() {\n    let r: (call: ICallStart) => number = (call) =>\n      typeof call.parent === \"undefined\" ||\n        callRecordType(call.parent) !== \"setup\" ?\n        0 :\n        r(call.parent) + 1\n    return r(this.call)\n  }\n}\n\nclass WireStart {\n  // tslint:disable-next-line:no-constructor-vars\n  constructor(public call: ICallStart, public from: IObservableTree[]) { }\n  public to(to: IObservableTree[]) {\n    return new Wire(this.call, this.from, to)\n  }\n}\n\nfunction isSource<T, R>(source: RxType.Observable<T>, obs: RxType.Observable<R>): boolean {\n  return (obs as any).source === source ||\n    Array.isArray((obs as any)._sources) && (obs as any)._sources.indexOf(source) >= 0\n}\n\nfunction hasSource<T, R>(obs: RxType.Observable<R>): boolean {\n  return (obs as any).source ||\n    Array.isArray((obs as any)._sources) && (obs as any)._sources.length > 0\n}\n\nfunction isFirstOpOntoSubject(record: ICallRecord): boolean {\n  return !record.parent || record.parent.subject !== record.subject\n}\n\nfunction schedulerType(\n  Rx: typeof RxType, \n  scheduler: RxType.VirtualTimeScheduler |\n    RxType.TestScheduler |\n    typeof RxType.Scheduler.asap | typeof RxType.Scheduler.animationFrame |\n    typeof RxType.Scheduler.async |\n    typeof RxType.Scheduler.queue\n): SchedulerType {\n  if (scheduler instanceof Rx.VirtualTimeScheduler || scheduler instanceof Rx.TestScheduler) {\n    return \"virtual\"\n  } else if (scheduler === Rx.Scheduler.asap) {\n    return \"recursive\"\n  } else if (scheduler === Rx.Scheduler.async) {\n    return \"timeout\"\n  } else if (scheduler === Rx.Scheduler.animationFrame) {\n    return \"timeout\"\n  } else if (scheduler === Rx.Scheduler.queue) {\n    return \"recursive\"\n  }\n}\n\nfunction derivatedSubject<T>(input: RxType.Subject<T>) {\n  return (input as any).source === (input as any).destination\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/instrumentation/rxjs-5.x.x/collector.ts","import { EdgeType, ISchedulerInfo, ITreeLogger, NodeType } from \"../oct/oct\"\nimport { IEvent } from \"./event\"\n\nexport default class Logger implements ITreeLogger {\n  // tslint:disable-next-line:no-constructor-vars\n  constructor(private post: (m: any) => void) {}\n  public addNode(id: string, type: NodeType, scheduler?: ISchedulerInfo): void {\n    this.post({ id, type, scheduler })\n  }\n  public addMeta(id: string, meta: any): void {\n    this.post({ id, meta })\n  }\n  public addEdge(v: string, w: string, type: EdgeType, meta?: any): void {\n    this.post({ v, w, type, meta })\n  }\n  public addScheduler(id: string, scheduler: ISchedulerInfo): void {\n    this.post({ id, scheduler })\n  }\n  public addContraction(id: string, nodes: string[]): void {\n    this.post({ id, contract: nodes })\n  }\n  public reset() {\n    this.post(\"reset\")\n  }\n}\n\nexport function formatObject(o: any, levels: number = 2, depth: number = 0): string {\n  if (o === null) { return \"null\" }\n  if (levels <= 0) {\n    return `${\n      o.constructor && o.constructor.name !== \"Object\" ?\n        `[${o.constructor.name}] ` :\n        \"\"\n      }{...}`\n  }\n\n  let result = `${o.constructor.name !== \"Object\" ? `[${o.constructor.name}] ` : \"\"}{`\n  let i = 0\n  for (let key in o) {\n    if (o.hasOwnProperty(key) && key[0] !== \"_\") {\n      if (i > 0) { result += \",\" }\n      i++\n      let padding = \"\"\n      for (let p = 0; p < depth; p++) { padding += \"  \" }\n      result += `\\n${padding}\"${key}\": ${_formatArguments([o[key]], levels - 1, depth + 1)}`\n    }\n  }\n  result += result[result.length - 1] === \"{\" ? \"}\" : \"\\n}\"\n  return result\n}\n\nfunction _formatArguments(args: IArguments | any[], levels: number = 2, depth: number = 0): string {\n  return [].map.call(args, (a: any) => {\n    switch (typeof a) {\n      case \"undefined\": return \"undefined\"\n      case \"object\":\n        if (Array.isArray(a)) {\n          return `[${_formatArguments(a, levels - 1, depth + 1)}]`\n        } else {\n          return formatObject(a, levels - 1, depth + 1)\n        }\n      case \"function\":\n        if (typeof a.__original === \"function\") {\n          return a.__original.toString()\n        }\n        if (typeof a.__originalFunction === \"function\") {\n          return a.__originalFunction.toString()\n        }\n        return a.toString()\n      case \"string\":\n        return `\"${a.substring(0, 512)}\"`\n      case \"boolean\":\n        return a.toString()\n      case \"number\":\n        return a\n      default: throw new TypeError(`Invalid type ${typeof a}`)\n    }\n  }).join(\", \")\n}\n\nexport function formatArguments(args: IArguments | any[]): string {\n  return _formatArguments(args)\n}\n\nexport type Node = {\n  id: number\n  type: \"node\"\n  node: {\n    name: string\n  }\n}\nexport type Edge = {\n  type: \"edge\"\n  edge: {\n    v: number\n    w: number\n    label: SubscriptionLinkLabel | SubscriptionHigherOrderLinkLabel | ObservableTimingLabel,\n    reason: string\n  }\n  group?: number\n  groups?: number[]\n}\n\nexport type NodeLabel = {\n  group?: number\n  groups?: number[]\n  type: \"label\"\n  label: SubcriptionLabel | ObservableLabel | EventLabel\n  node: number\n}\n\nexport type ObservableTimingLabel = {\n  time: number\n  type: \"observable link\"\n}\n\nexport type SubcriptionLabel = {\n  id: number\n  type: \"subscription\"\n}\n\nexport type SubscriptionLinkLabel = {\n  type: \"subscription sink\"\n  v: number\n  w: number\n}\n\nexport type SubscriptionHigherOrderLinkLabel = {\n  type: \"higherOrderSubscription sink\",\n  id: number\n  parent: number\n}\n\nexport type EventLabel = {\n  event: IEvent\n  subscription: number\n  type: \"event\"\n}\n\nexport type ObservableLabel = {\n  args: any\n  method: string\n  type: \"observable\"\n}\n\nexport type Message = Node | Edge | NodeLabel\n\n\n\n// WEBPACK FOOTER //\n// ./src/collector/logger.ts","/* FlatMap extension of Array prototype */\nexport function flatMap<T, R>(this: T[], f: (t: T, index: number, all: T[]) => R[]): R[] {\n  return this.reduce((p: R[], n: T, index: number) => p.concat(f(n, index, this)), [])\n}\n\n// tslint:disable-next-line:no-namespace\ndeclare global {\n  interface Array<T> {\n    flatMap<R>(f: (t: T, index: number, all: T[]) => R[]): Array<R>\n  }\n}\n\nif (Object.defineProperty) {\n  Object.defineProperty(Array.prototype, \"flatMap\", {\n    configurable: false,\n    enumerable: false,\n    value: flatMap,\n    writable: false,\n  })\n} else {\n  // Beware of dragons...\n  Array.prototype.flatMap = flatMap\n}\n\n/* random */\nexport function endsWith(self: string, suffix: string): boolean {\n  return self.indexOf(suffix, self.length - suffix.length) !== -1\n}\n\nexport function last<T>(list: T[]): T {\n  return list.length >= 1 ? list[list.length - 1] : undefined\n}\n\nexport function head<T>(list: T[]): T {\n  return list.length >= 1 ? list[0] : undefined\n}\n\nexport function getPrototype(input: any): any {\n  return input.protoype || input.__proto__\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/prelude.ts"],"sourceRoot":""}