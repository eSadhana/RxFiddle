\section{RP Debugging practices}
\label{section-practices}

%\todo{alternative section titles: Evaluating motivation / collecting empirical evidence / case study}
To validate the need for better tools we must first understand what existing tools are used (RQ1).
We interview developers as we want to explore and understand the current practices, instead of using an experiment or survey to test a particular hypothesis.
A controlled experiment to verify some hypothesis formed from literature could fail to include any practices employed that we did not consider.
The questions were semi-structured. We first established a general understanding of the experience of the subjects.
Then we asked several open questions regarding use of RP, how subjects debug RP and test RP. Table \ref{interview-questions} lists the questions used as a guideline for the interviews.

\begin{table*}[]
\centering
\begin{tabular}{ll}
\hline
    & \textbf{Question}                                               \\ \hline
Q1  & Explain your (professional) experience.                         \\
Q2  & Assess your experience on a scale from beginner to expert.      \\
Q3  & Explain your (professional) reactive programming experience.    \\
Q4  & Assess your RP experience on a scale from beginner to expert.   \\
Q5  & Did you refactor or rework RP code?                             \\
Q6  & Did you and how did you test or verify the workings of RP code? \\
Q7  & Did you and how did you debug RP code?                          \\
Q8  & Did you and how did you use documentation on RP?                \\
Q9  & What difficulties did you experience with RP?                   \\
Q10 & What is your general approach to understand a piece of Rx?      \\ \hline
\end{tabular}
\caption{Interview questions}
\label{interview-questions}
\end{table*}

Five developers with professional programming experience ranging from 4 to 12 years where interviewed.
The first four developers work in Company A, which builds mostly reactive systems~\cite{boner2014reactive} using various RP solutions,
and developers range from a month to over a year of Rx experience. 
The fifth developer works in Company B, and is concerned with building and maintaining a large scale distributed server application that uses Rx to handle asynchronous events.

\subsection{Interviews}
In the following paragraphs we discuss the results of Q6-Q10 in detail. Not every subject answered each question in the same amount of detail, so we discuss the answers that provide meaningful insights in the current practice.

\paragraph{Testing}
Of the 4 subjects of Company A none performed tests specifically for Rx logic. One subject mentioned that they only test the business logic in their application and consider the Rx code as `glue' which either works or does not work, which he can validate by just running the application. In contrast the team at Company B extensively tests their application using the Rx' built-in test facilities like `marble tests' and the \code{TestScheduler}. Using tests, the subject confirms his believes about the behavior of the chain of operators, and test also help later on when refactoring the code.

\paragraph{Debugging}
All subjects independently mentioned using println-debugging in several forms (println, logging, console log).
One subject mentioned that while adding log statements is easy it required him to recompile the Typescript project which could take several minutes, 
which caused him to often rely on breakpoints using the Chrome debugger. However, to add more `context' to his debug sessions he added console log statements.
Another subject - with mostly RxScala experience - mentioned that he did not use breakpoints as those `are difficult to use with asynchronous computations'. 
Instead relying on what is printed he can `quickly reason what happens'.
A third subject used the NodeJS debugger but describes using it as `painful' as he stepped through the inners of Rx.
The fourth subject sometimes debugged by uncommenting the chain line by line, to investigate why some part of the code was not reached. Furthermore, he mentioned that it is sometimes not clear whether a subscription is made, and sometimes he needs to verify whether the subscription is made through logs inside the subscribe method of the Observable.
The subject from Company B notes that debugging using existing debuggers are unusable for inspecting the life-cycle of Observables (subscription and disposal) and that he created a custom \code{debug} operator, which prints these life-cycle events. Furthermore he notes that plain-text logging is helpful when executing a single Observable chain, but overview is easily lost when executing multiple chains concurrently.

\paragraph{Documentation}
Subjects give different reasons to visit the documentation, but the most common reason is to `find an operator for what I need'. They feel that there might be an operator that precisely matches their needs, however knowing all operators by heart is not common (the Rx's Observable API has 28 static methods and 114 instance methods), therefore subjects sometimes end up doing an extensive search for some specific operator. Another reason to visit the documentation is to comprehend how operators in existing code work, which one subject does by looking at the marble diagrams at \href{http://rxmarbles.com}{RxMarbles.com} and in the \href{https://github.com/Reactive-Extensions/RxJS/blob/master/doc/}{GitHub documentation}. Another subject retrieves this information mostly textually from \href{http://reactivex.io/rxjs}{ReactiveX.io} and \href{http://introtorx.com}{IntroToRx.com}~\cite{introtorx}. One subject complains that there are not enough examples in the documentation.

\paragraph{Difficulties experienced}
Two subjects mention that the IDE does not help, which one explains with `Rx is more about timing than about types', and `there is no indication that the output is what you expect'. Another subject said he is not always sure what happens if he executes a piece of code, mostly due to Observables sometimes being lazy.
Two subjects note that flows are clear and comprehensible in the scope of a class or function, but for application wide flows it becomes unclear. The subject that used mostly RxScala, mentions that creating micro services helps in this regard. 
One subject mentions that `you need to know a lot as a starting {\lbrack}rxjs{\rbrack} developer', giving the example of the many ways to cleanup and \code{unsubscribe}, which he did manually initially. He used logging to analyze, learn and overcome his inexperience. 

\paragraph{Approach to understanding}
Subjects first look which operators are used, and then at which (types of) values are in the data flow. One subject first forms an expectation of the resulting value types based on the Observables variable name and then reasons backwards through the operators to determine when and if values are filtered out. The subject of Company B runs the code, if possible, to observe the outcome of the stream, as this `shows the intentions of the original developer'. If it then remains unclear how the data is transformed, he adds his \code{debug}-operator or looks up operators in the documentation.  

\subsection{Literature and written work}
Developers can learn Rx through several sources such as the official documentation at \href{http://reactivex.io}{ReactiveX.io}, books, online courses and from the many blog posts available. The official documentation\footnote{
	\url{https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/testing.md}
} mentions the use of the \code{do}-operator to add tracing to the console. Five books we reviewed on different versions of Rx contained a debugging chapter with tips, such as adding the Rx version specific \code{do}-like operators~\cite{esposito2016reactive,rxjavabook2016}, or do not have a debugging chapter at all~\cite{introtorx, rxjavabook2015, rxswiftbook2017}. Esposito and Ciceri~\cite{esposito2016reactive} further explain how to best format the log statements and introduce ways to limit the logging by modifying the Observable through means of throttling and sampling. The RxJava book~\cite{rxjavabook2016} also contains tips to use the various \code{do} operators to integrate with existing metric tools. We note that all of these methods require changes to the code, requiring (possibly recompilation and) re-execution when a different part of the flow needs to be inspected.
To our knowledge the only article addressing issues of debugging Rx is by Staltz, one of the contributors of RxJS\footnote{\url{http://staltz.com/how-to-debug-rxjs-code.html}}, noting that conventional debuggers are not suitable for the higher level of abstraction of Observables. Staltz explains three current ways to debug Rx, being: (1) tracing to the console, (2) manually drawing the dependency graph, (3) manually drawing marble diagrams.

\subsection{Practices}
The available literature matches the results of the interviews: \code{printf}-debugging is commonly advised and used. While the conventional debugger works in some cases, this is mostly the case for the procedural logic that interleaves Rx logic. Automated tooling is suggested, but is not implemented. We see that developers use \code{printf}-debugging to learn the behavior of Observables, behavior meaning both their values flowing through and their (one or many) subscriptions. Furthermore, we identify different goals for Rx debugging:
\begin{enumerate}
\itemsep0em 
\item[(1)] finding bugs and issues in reactive behavior,
\item[(2)] comprehending behavior of operators in existing code,
\item[(3)] understanding dependencies between Observables and
\item[(4)] gaining high-level overview of the reactive structure.
\end{enumerate}