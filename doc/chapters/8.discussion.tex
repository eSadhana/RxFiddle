\section{Discussion}

\paragraph{Usability}
Experienced RP developers get more speedup from RxFiddle than inexperienced developers. A possible explanation for the differences in the results of the larger tasks T3 and T4, is the visualization. The debugger design might require more training than currently supplied. T4 requires switching between the multiple inputs of one operator to gain a full understanding of the bug, while for T3 the root cause of the error is directly visible. If we compare our debugger visualization to the visualization of learning tools, like RxMarbles~\cite{rxmarbles} or the soon to be released RxViz of Misha Moroshko~\cite{rxviz}, the main difference is that those show all inputs and outputs of a single operator concurrently, for comprehension of that one operator, while RxFiddle shows one input and one output per Marble Diagram of a single full flow through the whole graph. The choice to show a full flow allows developers to trace events from the start till end of the flow, but restricts us in showing only a single ancestor flow per node at each vertical position, as adding a third dimension would clutter the (currently 2D) visualization. For future research it would be interesting to compare the different ways Observable streams can be combined in Marble Diagrams and which visualization elements can be added to explicitly show causality and lineage for events and show durations for subscriptions.

\paragraph{Edge visualization}
In our graph visualization, the edges represent the dependencies and the path of the events. Nodes with multiple incoming edges \emph{merge} the events, however users could falsely think that all event data ends up in the outgoing path: besides for \textit{merging data} Rx also uses Observables \textit{for timing}, as durations (\code{window}), as stop conditions (\code{takeUntil}) and as toggles (\code{pausable}). Different visual representations for joining paths could be explored to distinguish between the use of an Observable for data or for timing.
