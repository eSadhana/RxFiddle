\section{Debugger Design}
In this section we describe the design of a visualizer for the ReactiveX (Rx) family of RP libraries to answer RQ2. We propose a visualizer consisting of two parts: a data flow graph and a marble diagram. The data flow graph provides high-level overview, showing how different flows are created and used, while the marble diagram offers a more in-depth look into one selected data flow showing the contents of the flows.

\subsection{Data Flow Graph}
\textbf{Simplified graphs.} When running an RP program Observables are created that depend on other Observables (their \textit{source}) and Observers are created to send their values to a defined set of Observers (their \textit{destination}). Figure \ref{chaincreate} shows these relations in a graph. For the simplest of programs the relations between the Observables ($O = {o_1, o_2, o_3}$) and those between Observers ($S = {s_1, s_2, s_3}$) share an equally shaped sub-graph after a reversal of the Observer-edges. To provide more overview we process the graph to merge the two Observable and Observer sequences together, simplifying it in the process, as in Figure \ref{fiddlesimple}. Higher order relations are retained as shown in \ref{fiddlehigher}.

\begin{figure}[ht]
	\centering
	\input{images/chainsimple}
	\caption{Simplified graph of Figure \ref{chaincreate}}
	\label{fiddlesimple}
\end{figure}

\begin{figure}[ht]
	\centering
	\input{images/fiddlehigher}
	\caption{Simplified graph of Figure \ref{chainhigher}}
	\label{fiddlehigher}
\end{figure}

\textbf{Layout} is used to add extra meaning to the graph. If multiple subscriptions on the same Observable are created, multiple flows are kept in the graph and they are layout together. This helps developers find related flows. Also it is easy to see when a Observable is reused many times, hinting a possible performance improvement by sharing the computation (Rx has special \code{share}-operators to multicast). The layout is based on StoryFlow~\cite{liu2013storyflow} which employs a hierarchical clustering before ordering the graph in a way to reduce crossings.

\textbf{Coloring} the nodes can be used to identify the same Observable in multiple places in the graph, as Observables can be reused in different places of the stream.

\subsection{Marble Diagram}
The term \textit{Marble Diagram} comes from the shape of the glyps in the images used to explain Rx in the official documentation. The diagrams contain one or more timelines containing the events that enter and leave Observables. Developers can see from the diagram how operators work by inspecting the difference between the timelines, where events might be skipped, added, transformed or delayed. Mapping time on the x-axis provides the insight that is missing when inspecting only a single time slice, like with traditional debuggers.

In contrast to the original diagrams we use dynamic diagrams which update live when new events occur and are stacked to show the data in the complete flow. This allows the developer to trace a value back through the flow, a debug operation which is impossible using a classic debugger. Handcrafted marble diagrams can use custom shapes and colors to represent events, but for the generic debugger we use only three shapes: next events are a green dot, errors a black cross, completes a vertical line, as shown in Figure~\ref{marblediagram}. For our generic debugger it is unfeasible to automatically decide which properties (content, shape and color) to apply to events, as the amount of events and distinguishing features might be unbounded. Instead the event values are shown upon hovering.

\begin{figure}[ht]
	\centering
	\input{images/marblediagram}
	\caption{Marble Diagram}
	\label{marblediagram}
\end{figure} 

\subsection{Architecture}
To support the visualization, we design a debugger architecture consisting of 2 components:

The \textbf{Host instrumentation} instruments the Rx library to emit useful execution events. Depending on the language and platform specific instrumentation is required. Output of the instrumentation is a platform and language independent graph much like Figure \ref{chainhigher}. By splitting the instrumentation the debugger can be used for the complete ReactiveX family of libraries by only reimplementing the first component. 

The \textbf{Visualizer} takes the initial graph and simplifies it into a Data Flow Graph. Then it layouts the Data Flow Graph and provides the debuggers User Interface. By separating the visualizer we can safely export generated graphs and visualize it post mortem for example for documentation purposes.

The components can run in their own environment. The instrumentation must run inside the host language, while the Visualizer can use a different language and platform.

\subsection{Implementation}
To validate the design and to provide an implementation to the developer community we created \url{RxFiddle.net}. The RxFiddle project is a reference implementation of 
our reactive debugger design. Besides the visualizer the website it also contains a code editor for JavaScript code with sharing functionality, for developers to share snippets with their peers. In this section we will explain different parts of the implementation. For RxFiddle we initially focussed on RxJS (JavaScript).

\textbf{Instrumentation}. With JavaScript being a dynamic language we use a combination of prototype patching and Proxies~\footnote{\url{https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/Proxy}} to instrument the RxJS library: the Observable and Observer prototypes are patched to return Proxies wrapping the API method calls. The instrumentation passes every method entry and method exit to the next step.

\textbf{Linking}. Here we distinguish between method calls from the different phases (Section \ref{nutshell}). From the assembly phase we detect Observables as target and arguments of a call and as return value. We add an edge between the call target \& call arguments and returned Observables, denoting the `source'-relation. Also we tag the returned Observable with the call frame information (time, method name, arguments). In the subscription phase we detect calls to the \code{subscribe}-method: the destination subscribers are passed as arguments and we save this relation as an edge to the graph. In the runtime phase we detect `next', `error' and `complete' calls on Observers and add these as meta data to the Observer nodes.

\textbf{Graph Loggers}. Next the graph mutations are streamed to the environment of the visualizer, where the graph is rebuild. Depending on the host language a different protocol is used: RxFiddle's code editor executes the code in a Worker\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/Worker}} and transmits over the postMessage protocol, while RxFiddle for Node transmits over WebSockets. Being able to support multiple protocols increases the possible use cases, ranging from 

\textbf{Visualizer}. The visualizer receives the current state in the form of a graph from the Logger. It then uses the Observers in the graph to create the Data Flow Graph and layouts the graph using StoryFlow, where Observables are used to create the hierarchies. To render the Marble Diagrams the flow to and from the selected Observer is gathered by recursively traversing up, respectively down, the graph.

RxFiddle is Open Source\footnote{\url{http://github.com/hermanbanken/RxFiddle}} and developers are encouraged to add support for more languages. Researchers could use the instrumentation to infer usage information from RP programs or explore new possibilities regarding the visualization.

\begin{table*}[t]
\centering
\caption{Instrumentation protocol}
\label{my-label}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
addObservable(id, sourceIds)                   & Adds a Observable node, with zero or more source Observable's                                                                                                                      \\ \hline
addObserver(id, observableId, destinationId)   & \begin{tabular}[c]{@{}l@{}}Add a Observer, observableId denotes the Observable it subscribed to, \\ optional destinationId adds an edge to the destination Observer\end{tabular}   \\ \hline
addOuterObserver(observerId, outerDestination) & \begin{tabular}[c]{@{}l@{}}Create a special edge between an existing Observer and the higher order \\ destination Observer\end{tabular}                                            \\ \hline
addEvent(observerId, type, optionalValue)      & \begin{tabular}[c]{@{}l@{}}Add an event to the Observer denoted by observerId, of type (next, error, complete), \\ optionally with a value (for next / error events).\end{tabular} \\ \hline
addMeta(id, metadata)                          & Add meta data such as the method call which created an Observable.                                                                                                                 \\ \hline
\end{tabular}%
}
\end{table*}

% multiline comment
\iffalse
\todov{
## design

visualization:
- 1. dependency graph
- 2. marble diagram

  motivation:
  - structure defined in code can be scattered
  - see high level structure (helps with composing)
  - see missing dependencies
  - see duplicate flow subscriptions (hurts performance)
  - zoom in to see internals of built in advanced op's
  - is basically automatic documentation

architecture of 3 components:
- 1. host instrumentation
- 2. analyzer: graphs from instrumentation output
- 3. visualizer

  motivation
  - independent instrumentation per platform
  - visualizer separated, so supports both 
    online (live) as offline (post mortem) viz
}
\fi

% multiline comment
\iffalse
\todov{
## implementation

5 stages:
- 1. instrumentation
- 2. linking / referencing / building a graph
- 3. sending the graph over from the client to the viz
- 4. building the graph on the other side
- 5. layout

explain independency of stages 3-5 on language & platform: 
can run with any Rx if stage 1 & 2 are implemented. 
Efforts done with RxJS 4, RxJS 5 and some limited 
work in RxJava.

validation with test set of operators, to be discussed 
either here or at evaluation.
}
\fi

