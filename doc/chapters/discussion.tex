\section{Discussion}
\subsection{Applicability}
The experiment consists of 2 small and 2 medium tasks, so the results of the experiment might not necessarily generalize to debugging RP in practice with larger systems. For larger tasks the effects of the debugger could be bigger and therefore be better measurable. Still we chose for these smaller tasks, for two reasons: in the limited time of the subjects they could answer only so many questions and designing larger tasks for the experiment would take many more iterations and time. With the limited amount of time available we still show that a significant speed-up can be achieved in some cases. We leave it for future work to extend the experiment to include larger systems.

\subsection{Scalability}
Debugging large reactive systems over longer periods of time can result in significantly larger Observable graphs and Marble Diagrams than currently evaluated. During tests of RxFiddle with larger applications like RxFiddle itself and an existing Angular application the graph became too large to render in a reasonable amount of time. Besides rendering performance, a potentially even bigger issue is with communicating large graphs to the developer. We propose several extensions to RxFiddle to remedy this issue: (1) pruning the graph of old flows to show only the active flows, (2) bundling flows that have the same structure and only rendering a single instance offering a picker into the flow of interest, (3) collapsing certain parts of the graph that are local to one source file or function, (4) adding search functionality to quickly identify flows by operator or data values, (5) support quick navigation between code \& graph.

Furthermore we think that while Marble Diagrams are useful for small to medium amount of events ($< 20$), both better performance and better functionality would be achieved by providing a different interface for high volume flows. Above a certain threshold of events this interface could be the default, offering features like filtering, watch expressions (to look deeper into the event's value), and advanced features like histograms \& FFT.

\subsection{Visualization}
Our implementation visualizes higher order flows as a combination of the original flow with incoming edges from the merged flows. While this visualization matches the behavior of merging streams together it does not map conceptually with some other use cases of higher order flows, for example using one Observable as stop condition for another Observable (\code{takeUntil}).

\subsection{Breakpoints}
Setting traditional breakpoints in a reactive program stops the system from being reactive, and therefore can change the behavior of the system. This was our reason not to deal with breakpoints in RxFiddle. However, the behavior of breakpoints is twofold: they allow us to modify the application state by interacting with the variables in scope, but they also provide a way to be notified of an event occurrence. While the first is arguably not desirable for reactive systems, the notification property might be a good addition to RxFiddle. BIGDEBUG~\cite{Gulzar2016}, a debugging solution for systems like Spark, introduces \textit{simulated breakpoints} for this purpose. When a simulated breakpoints hits the execution resumes immediately and the required lineage information of the breakpoint is collected in a new independent process. Implementing this for RxFiddle is a matter of creating the right UI as the required lineage data is already available.

