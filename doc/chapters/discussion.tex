\section{Discussion}
\subsection{Usability}
Experienced RP developers get more speedup from RxFiddle than inexperienced developers. This indicates that the debugger design might require more training than currently supplied. The visualization is not as easy to understand as we initially hoped. A possible explanation for the differences in the results of the larger tasks T3 and T4, is the visualization. T4 requires switching between merged Observables to gain a full view of the events, while the root cause of the error in T3 is directly visible. If we compare our visualization to the visualization of other tools like the soon to be released visualizer of Misha Moroshko\footnote{\url{https://twitter.com/moroshko/status/854529439262167040}}, the main difference is that RxFiddle shows a linear Marble Diagram view of a single flow or path through the graph, while other visualizers show a `multi-path diagram'. The choice to show a single path allows us to show long paths, but is restricting as showing multiple paths would create complicated visualizations which we deemed too cluttered to be usable. For future research it would be very interesting to compare the different ways Observable streams can be combined in Marble Diagrams and which visualization elements can be added to explicitly show the causality and lineage of events and show durations of subscriptions.

\subsection{Scalability}
Debugging large reactive systems over longer periods of time can result in significantly larger Observable graphs and Marble Diagrams than currently evaluated. During tests of RxFiddle with larger applications like RxFiddle itself and an existing Angular application the graph became too large to render in a reasonable amount of time. Besides rendering performance, a potentially even bigger issue is with communicating large graphs to the developer. We propose several extensions to RxFiddle to remedy this issue: (1) pruning the graph of old flows to show only the active flows, (2) bundling flows that have the same structure and only rendering a single instance offering a picker into the flow of interest, (3) collapsing certain parts of the graph that are local to one source file or function, (4) adding search functionality to quickly identify flows by operator or data values, (5) support quick navigation between code \& graph.

Furthermore we think that while Marble Diagrams are useful for small to medium amount of events ($< 20$), both better performance and better functionality would be achieved by providing a different interface for high volume flows. Above a certain threshold of events this interface could be the default, offering features like filtering, watch expressions (to look deeper into the event's value), and advanced features like histograms \& FFT.

\subsection{Visualization}
Our implementation visualizes higher order flows as a combination of the original flow with incoming edges from the merged flows. While this visualization matches the behavior of merging streams together it does not map conceptually with some other use cases of higher order flows, for example using one Observable as stop condition for another Observable (\code{takeUntil}).

\subsection{Breakpoints}
Setting traditional breakpoints in a reactive program stops the system from being reactive, and therefore can change the behavior of the system. This was our reason not to deal with breakpoints in RxFiddle. However, the behavior of breakpoints is twofold: they allow us to modify the application state by interacting with the variables in scope, but they also provide a way to be notified of an event occurrence. While the first is arguably not desirable for reactive systems, the notification property might be a good addition to RxFiddle. BIGDEBUG~\cite{Gulzar2016}, a debugging solution for systems like Spark, introduces \textit{simulated breakpoints} for this purpose. When a simulated breakpoints hits the execution resumes immediately and the required lineage information of the breakpoint is collected in a new independent process. Implementing this for RxFiddle is a matter of creating the right UI as the required lineage data is already available.

