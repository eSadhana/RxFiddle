\section{Introduction}
Software often needs to respond to external events and data flows. Consider software for example in interactive applications, for desktop, web and mobile phones, in graphics and in processing sensor data from phones or IoT-devices. Traditionally handling these asynchronous events or data flows was done using the Observer design pattern~\cite{johnson1995design} or \textit{callback functions}~\cite{gallaba2015don}. Using these patterns the data consuming system does not have to block waiting for responses, but instead receives a notification when data is available. While these patterns decouple the consumer from the producer of the data, they typically lead to dynamic registration, side effects in the consumers, and inversion of control~\cite{salvaneschi2014empirical}. Instead we can use Reactive Programming (RP) to express the complex reactive behavior of these applications. RP offers declarative and concise syntax for composing streams of data. As a result, RP programs are generally more comprehensible, compared to the Observer design pattern or using callbacks.

After receiving mostly academic interest for a long time in the form of FRP~\cite{elliott1997functional,elliott2009push,czaplicki2013asynchronous,maier2010deprecating}, recent years brought RP to the developer community in the form of Flapjax~\cite{meyerovich2009flapjax}, Elm~\cite{czaplicki2012elm}, Rx~\cite{meijer2010subject}, Angular (RxJS), Spring/Reactor and Akka Streams. Large companies like Netflix, Microsoft, and Google are using RP in production systems and donate development time to these frameworks and libraries. As a result many developers are now starting to use RP.

While reactive programs might be more declarative and concise, RP does not work well with traditional interactive debuggers, shipped with most IDE's. RP borrows from Functional Programming (FP) for it's abstractions, its laziness and advocating the use of `pure' (same input, same output) lambda functions. Those features contribute to an execution flow that is hidden inside the RP implementation library and non-linear execution of the users code. This results in not useful stack traces and frequently breakpoints don't help as relevant variables are not in scope. Furthermore, using a low level debugger makes it harder to see the high level relations and overview that the high-level RP abstraction provides.

Furthermore there is a large gap between developers new to RP and experienced RP developers, as recently discussed at the Rx Contributor Days\footnote{\label{foot:contribdays}http://contributordays.com/contributor-days/rxjs}. To ``think in the reactive way'' requires comprehension of the core concepts that RP offers. As debugging is a fundamental part of comprehension, any improvements made to ease the debugging experience and capabilities in this area might improve how RP is comprehended.

Debugging is an important part of the daily life of a programmer. However, compared to programming in general, there is a research gap regarding comprehension of RP and current debugging practices and debugging methods for RP. Given the discussed fundamental differences, knowledge about traditional imperative programming might not apply to RP. The impact of any improvements on the developer community can be substantial, as recent reactive front-end frameworks like Angular grow in usage, and increasingly many developers are exposed to some form of RP.

\subsection{Contributions}
Through interviews among professional developers, we confirm the current state of RP debugging tooling. We then design a reactive programming debugger that allows developers to see data flows in their reactive programs. We evaluate this debugger through an experiment.
We formulate the following research questions to steer the research:

\begin{description}
\item[RQ1] How do developers debug RP? \\
Before we design tools it is important to understand the problems arising in the the current state~\cite{singer2010examination}. Anecdotal evidence by a number of resources\footnoteref{foot:contribdays}\footnote{https://staltz.com/how-to-debug-rxjs-code.html}
suggests that the current state is non-optimal.

\item[RQ2] How can we design a tool that helps developers debug RP? \\
By examining the results of RQ1, the limitations of traditional debuggers and the opportunities that RP programs offer in terms of structure and explicit dependencies between data flows, we design an RP debugger.

\item[RQ3] Can specialized debuggers speed up comprehension \& debugging? \\
To validate the design and whether specialized tooling can improve the experience we measure the speed and correctness of comprehension in an experiment.

\end{description}
