\section{Introduction}
Software often needs to respond to external events and data flows. Consider software for example in interactive applications, for desktop, web and mobile phones, in graphics and in processing sensor data from phones or IoT-devices. We can use Reactive Programming (RP) to express the complex reactive behavior of these applications. RP offers declarative and concise syntax for composing streams of data. As a result programs are generally more comprehensible, when created using RP compared to an equal implementation using the Observer design pattern~\cite{johnson1995design, salvaneschi2014empirical}.

After receiving mostly academic interest for a long time in the form of FRP~\cite{elliott1997functional,elliott2009push,czaplicki2013asynchronous,maier2010deprecating} recent years brought RP to the developer community in the form of Flapjax~\cite{meyerovich2009flapjax}, Elm~\cite{czaplicki2012elm}, RxJS~\cite{meijer2010subject}, Angular (RxJS), React, Spring/Reactor and Akka Streams. Large companies like Netflix, Microsoft, Google and Facebook are betting on RP by working on these frameworks and libraries. As a result many developers are now starting to use RP.

%After researchers created research implementations of (Functional) Reactive Programming~\cite{elliott1997functional,cooper2006embedding,elliott2009push}  many production ready implementations are now available for commodity languages like JavaScript and Java.

%, compared to traditional programming approaches. As a result programs are generally more comprehensible, when created using RP compared to an equal implementation using the Observer design pattern~\cite{johnson1995design, salvaneschi2014empirical}.

While reactive programs might be more declarative and concise, RP does not work well with traditional interactive debuggers, shipped with most IDE's. RP borrows from Functional Programming (FP) for it's abstractions, its laziness and advocating the use of clean input/output (lambda) functions. All those features contribute to an execution flow that is mostly inside the RP implementation library, non-linear, resulting in not useful stack traces and frequently breakpoints don't help as relevant variables are not in scope. Furthermore, using a low level debugger makes it harder to see the high level relations and overview that the high-level RP abstraction provides.

\subsection{Motivation}
Understanding code is an important part of the daily life of a programmer. However, compared to programming in general, little is known about program comprehension and debugging practices for Reactive Programming. Existing knowledge about traditional imperative programs might not apply to RP. Many concepts of FP are borrowed by the RP libraries, about which Weck and Tichy say that ``higher-level abstractions like monads [...] can be a barrier for code comprehension"~\cite{weck2016visualizing}. Furthermore it is reiterated that there is a large gap between developers new to RP and experienced RP developers, at different occasions, including the recent Rx Contributor Days~\footnote{http://contributordays.com/contributor-days/rxjs}. To ``think in the reactive way'' requires comprehension of the core concepts that RP offers. As debugging is a fundamental part of comprehension, any improvements made to ease the debugging experience and capabilities in this area might improve how RP is comprehended.
The impact of any improvements on the developer community can be substantial, as recent reactive front-end frameworks like Angular and React grow in usage, and increasingly many developers are exposed to some form of RP. Doing something practically useful for this community is what lead us to create RxFiddle.

%In this paper we will first analyse
%
%Current debuggers are optimized for imperative programs, where statements are executed sequentially and control flow can be analyzed. 
%
%While the general behavior of programs becomes more comprehensible using RP, this does not necessarily hold in presence of complex operators, unintended behavior or faults. We define ‘debugging’ as examining the behavior of a program, and ‘debug-ability’ as a measure of debugging efficiency. To our knowledge no research exists which evaluates the debug-ability of reactive programming, and anecdotal evidence suggests existing tools are not sufficient[1].
%
%Traditionally faults are tracked down with the help of debugging: using breakpoints, logs and tests~\cite{zeller2009programs}). When debugging the execution of a sequential program the premises for control flow are known or computable using the current stack and heap, and the data flow can be followed by traversing down the stack trace. However, in RP events are triggered asynchronously, which resets the stack trace. The reset stack traces can not be traversed back to the previous event. Furthermore, this means previous stack frames containing data related to previous events are not accessible.
%
%This is especially challenging for more complex programs: while equal programs are easier to comprehend in RP style, more complex programs are also easily created, since RP also improves composability~\cite{maier2012deprecating}. These programs can be several degrees more complex in behavior than traditional applications.
%
%In summary, tracking down bugs becomes harder for two reasons:
%
%-   the search scope widens for larger applications
%
%-   existing tools are not sufficient for reactive programs.
%
%Specialized debuggers for reactive programming exist, although not as a result from academic research or with scientific validation. Examples are the Time Traveling Debugger (TTD) for Elm, a functional reactive programming (FRP) framework, and tools like RxVision and RxMarbles, which show that visualization is aids comprehension and debugging. Those tools fall short however: TTD is restricted to the Elm platform, RxVision is a mere proof of concept and restricted to the browser, and RxMarbles only visualizes a given set of operators, using fixed inputs.
%
%**Intended contributions.** In this thesis we will evaluate whether data or control flow graphs aid reactive program comprehension and debugging. Furthermore we present a tool which generates complete and interactive Marble Diagrams for full data flows, automatically, from sources and from running applications.

\subsection{Research Questions}
We formulate the following research questions to steer the research: 

\begin{description}
\item[RQ1] How do developers debug RP? \\
Before we design tools it is important to understand the problems arising in the the current state~\cite{singer2010examination}. Anecdotal evidence by a number of resources\footnote{http://contributordays.com/contributor-days/rxjs}\footnote{https://staltz.com/how-to-debug-rxjs-code.html}
suggests that the current state is non-optimal.

%	\begin{enumerate}
%		\item[RQ1.1] What strategies do developers use to comprehend RP?
%		\item[RQ1.2] What debug tools do developers use to comprehend \& debug RP?
%		\item[RQ1.3] {\color{orange}Do experienced developers debug RP faster?}
%	\end{enumerate}
%

\item[RQ2] How can we design a tool that helps developers debug RP? \\
Examining the limitations of traditional debuggers and the opportunities that RP programs offer in terms of structure and explicit dependencies between data flows, we design an RP debugger.

%	\begin{enumerate}
%		\item[RQ2.1] Can run-time behavior be extracted such that it is appropriate input to a visualizer?
%		\item[RQ2.2] Can Rx programs be represented as graphs?
%		\item[RQ2.3] Can Marble Diagrams effectively convey structures containing more than 1 operator?
%	\end{enumerate}

\item[RQ3] Can specialized debuggers speed up comprehension \& debugging? \\
To validate if specialized tooling can improve the experience we measure the speed and correctness of comprehension in both a controlled and in an online experiment.

%\end{enumerate}
\end{description}
