\subsection{Limitations}
\paragraph{Graph scalability}
Debugging large reactive systems over longer periods of time can result in significantly larger Observable graphs and Marble Diagrams than currently evaluated. During tests of RxFiddle with larger applications like RxFiddle itself and an existing Angular application the graph became too large to render in a reasonable amount of time. Besides rendering performance, a potentially even bigger issue is with communicating large graphs to the developer. We propose several extensions to RxFiddle to remedy this issue: (1) pruning the graph of old flows to show only the active flows, (2) bundling flows that have the same structure and only rendering a single instance offering a picker into the flow of interest, (3) collapsing certain parts of the graph that are local to one source file or function, (4) adding search functionality to quickly identify flows by operator or data values, (5) support navigation between code \& graph.

\paragraph{Marble Diagram scalability}
Furthermore we think that while Marble Diagrams are useful for small to medium amount of events ($< 20$), both better performance and better functionality would be achieved by providing a different interface for high volume flows. Above a certain threshold of events this high volume interface could be the default, offering features like filtering, watch expressions (to look deeper into the event's value), and advanced features like histograms \& FFT.

\paragraph{Breakpoints}
\ref{breakpoints}
Setting traditional breakpoints in a reactive program stops the system from being reactive, and therefore can change the behavior of the system. This was our reason not to deal with breakpoints in RxFiddle. However, the behavior of breakpoints is twofold: they allow us to modify the application state by interacting with the variables in scope, but they also provide a way to be notified of an event occurrence. While the first is arguably not desirable for reactive systems, the notification property might be a good addition to RxFiddle. BIGDEBUG~\cite{Gulzar2016}, a debugging solution for systems like Spark~\cite{zaharia2012resilient}, introduces \textit{simulated breakpoints} for this purpose. When a simulated breakpoints hits the execution resumes immediately and the required lineage information of the breakpoint is collected in a new independent process. Implementing this for RxFiddle is a matter of creating the right UI as the required lineage data is already available.
