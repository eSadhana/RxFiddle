\label{nutshell}
Reactive Programming (RP) is a declarative programming paradigm for working with streams of input data. 
According to the original definition\footnote{
``Reactive programs [..] maintain a continuous interaction with their environment, at a speed which is determined by the environment, not the program itself.''~\cite{berry1989real}
} a reactive program must interact with the environment `at a speed which is determined by the environment'.
This means that when a reactive program is run, it sets up a data pipeline and waits until input arrives when the environment changes.
Reactive Programming languages and libraries provide developers with the appropriate abstractions and methods to create such programs.

The programming paradigm of Reactive Programming is implemented by multiple languages and libraries. Many RP implementations share a notion of a collection that abstracts over \textit{time} (in contrast to \textit{space} like standard collections) be it \textit{Observable} (Rx~\cite{meijer2010subject}), Signal (Elm~\cite{czaplicki2012elm}), Signal/Event (REScala~\cite{salvaneschi2014rescala}) or Behavior/Event (FRP~\cite{elliott1997functional}). In this paper, we focus on the Rx formulation, but our work is applicable to other RP implementations to some extend. 

Understanding how we arrive at our visualization requires at least minimal understanding of Rx.
Rx introduces two basic types \textit{Observable} and \textit{Observer}. Observables define the data flow and produce the data while Observers receive the data, possibly moving the data further down the stream. Figure \ref{sample1} shows a very basic example of a in situ data flow in Rx. Initially an Observable is created, here using the static \code{of} method, then dependent Observables are created using the \code{map} and \code{filter} methods on the Observable instance. Finally we \code{subscribe} to start the data flow and send the data in the flow to the console.

\begin{figure*}[h!]
\centering

\begin{subfigure}[t]{\columnwidth}
	\inputminted[tabsize=2]{javascript}{listings/sample1.js}	
	\par\bigskip
	\caption{Rx code example}
	\label{sample1}
	\par\medskip
	\input{images/chaincreate}
	\caption{Rx graph example}
	\label{chaincreate}
\end{subfigure}
\begin{subfigure}[t]{\columnwidth}
	\inputminted[tabsize=2]{javascript}{listings/sample3.js}	
	\caption{Higher order flatMap operation}
	\label{sample3}
	\par\medskip
	\input{images/chainhigher}
	\caption{Higher order Rx graph example}
	\label{chainhigher}
\end{subfigure}

\caption{Samples of Rx Observables}

\end{figure*}

\paragraph{Assembly} It is important to note that Observables are lazy, initially they merely specify the blueprint of a data flow. 
Creating this specification we call the \textit{assembly} phase. In the code sample of Figure \ref{sample1} this are the calls to \code{of}, \code{map} and \code{filter}, creating respectively Observables $o_1$, $o_2$ and $o_3$ from Figure \ref{chaincreate}.

\paragraph{Subscription} Only when the \code{subscribe} method of an Observable is called the data flow is started by recursively subscribing, up the stream: \textit{Observer}s are created and subscribed to each Observable until the source Observables are subscribed and, consequently, started. We call this the \textit{subscription} phase. In Figure \ref{sample1} inside the single \code{subscribe} call Observer $s_1$ from Figure \ref{chaincreate} is created and passed to $o_3$, which in turn will recursively subscribe to $o_2$ with a new Observer $s_2$ with destination $s_1$, until the full chain is subscribed.

\paragraph{Runtime} When the source Observables are subscribed they can start emitting data, this is the \textit{runtime} phase. Depending on the nature of the Observable this might attach event listeners to UI elements, open network connections or start iterating over a list of elements. Data is pushed to $s_3$, to $s_2$ and finally to $s_1$ which calls \code{console.log} in Figure \ref{sample1}.

More complex programs feature operators that merge Observables\footnote{
	\code{concat}, \code{merge}, \code{combineLatest}, \code{zip}
}, split Observables\footnote{
	\code{partition}, or through sharing with \code{share} or \code{publish}
} or handle higher order Observables\footnote{
	\code{flatMap}, \code{mergeMap}, \code{concatMap}
}, resulting in more complex graphs. While merging and splitting happens on an Observable level (the \code{source} property still points to the one or more dependencies) higher order Observable flattening manifests only in Observer structure (there is no reference between the Observables). Figure \ref{chainhigher} show this with an (abbreviated) \code{inner} Observable that is subscribed twice (for both values $2$ and $3$, value 1 is skipped), resulting in two identical data flows over $o_1$. The data flow through $s_{4,n}$ and $s_{4_m}$ is pushed into $s_1$, flattening the data flow. 
