\section{Related Work}

\textbf{Dynamic Analysis.}
Although interactive debuggers are commonly used for debugging 
of the runtime behavior of programs, more specialized tools already exist: 
the study of program execution is called `dynamic analysis' which has 
received substantial attention in the research community,
as surveyed by Cornellissen et al.~\cite{cornelissen2009systematic}.
They categorise on different facets being the 
\textit{activity} [goal of analysis],
\textit{target} [kind of inspected program or system],
\textit{method} [visualization, metrics, online, querying, etc.],
\textit{evaluation} [preliminary, case study, quantitative, etc.].
In most cases dynamic analysis involves a \textit{post mortem} analysis, 
where first the program is run and then the trace data is analyzed to create a visualization.
Reiss mentions the compromises that have to be made to make an online analysis~\cite{reiss2006visualizing}: 
reduced tracing is required to not slow down the system (known as the observer-effect), 
fast analysis is required to lower the cost of getting to the visualization, to not discourage the users.
In our design we found similar compromises relevant for RP debugging.

% \todo{
% \begin{enumerate}
%  \item Cornelissen, TU Delft, survey on Program Compr. through Dynamic Analysis
%  		lists limitations: 
% 		   - incompleteness, only part of domain
% 			 - which scenarios to analyse
% 			 - scalability (wrt human cognitive load) 
% 		 	 - observer effect (multi-threaded, realtime) changes execution
% \end{enumerate}
% }

\textbf{Specialized debuggers.}
Most research into debugging focusses on procedural and 
imperative languages~\cite{cornelissen2009systematic}.
Other topics of interest are multi-threading and distributed systems and 
only few focus on other styles, like declarative programming~\cite{nilsson1998declarative}.
Debugging specifically for Reactive Programming was only first mentioned and tried by Salvaneshi et al. for REScala~\cite{salvaneschi2014empirical,salvaneschi2016debugging}.

\todo{
\begin{enumerate}
	\item Atlas (2014): rich graph representation, can be used to build call graphs, dataflow graphs, dependency graphs
%	\item RP debugging (2016, Guido): REScala, data flow graph, breakpoints
%	\item BIGDEBUG Spark debugging (2017): data flow graph, non-pausing simulated breakpoints, data provenance
\end{enumerate}
}

\textbf{Tracing \& Automated visualization for comprehension}
\todo{
\begin{enumerate}
 \item Lange 1995, Program Visualizer for C++
 \item story flow: visualize stories over time, comprehending relations, interactive visualization
 \item Weck \& Tichy, Visualizing Data-Flows in Functional Programs
 \item Srinivasan, ICPC16, ``Case Studies of Optimized Sequence Diagram for Program Comprehension", Texas A\&M Univerity
%  \item Misha Moroshko (Facebook) Rx visualization
\end{enumerate}
}