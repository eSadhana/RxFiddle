\section{Related Work}

\subsection{Debugging}
Debugging for general purpose languages revolves around 
attaching a debugger,
stepping through the code, 
attaching code or data breakpoints, 
navigating along different calls in the call stack and 
examining variables and results of expressions~\cite{Spinellis2017}.
However, existing research measuring how these different tasks are part of the developers work day found that 
while developers spend much time on comprehending code they do not spend much time inside the debugger~\cite{minelli2015know}.
Beller et al.~\cite{beller2017behavior} found that only 23\% of their subjects actively use the IDE's debugger,
with the most common action being adding breakpoints, followed by stepping through code.
The automated tooling of these studies did not measure different kinds of debugging other than using the IDE provided tools, 
however Beller's survey indicates that 71\% also uses printf statements for debugging.
No indication was given of any RP language and libraries used by the subjects in the study, 
but the observation that printf debugging is common matches our experience with debugging reactive programs.

% What comprises debugging?
% \item Maybe Zeller / Spinellis?

% \item Petrillo, ``Towards Understanding..." e.g. Swarm debugging
% \item Minelli (know what you did last summer)
% \item Moritz (watchdog 2.0)

\subsection{Debugging for Program Comprehension}
Both debugging and comprehension are processes in the work of programmers.
Initially comprehension was seen as a distinct step programmers had to make
prior to being able to debug programs~\cite{katz1987debugging}, 
but this distinction is criticized by Gilmore saying we must view 
``debugging as a design activity''~\cite{gilmore1991models}, 
part of creating and comprehending programs. 
Maalej et al.~\cite{Maalej2014} interviewed professional developers 
and found that developers require runtime information to understand a program,
and that debugging is frequently used to gather this runtime information.
This supports our view that `debugging' is not only used for fault localization,
but also for comprehension.

% \item Katz, distinct step
% \item Gilmore, comprehension + debugging == linked
% \item Maalej: professionals, avoid deep comprehension, sharing knowlegde

\textbf{Dynamic Analysis.}
Although interactive debuggers are commonly used for debugging 
of the runtime behavior of programs, more specialized tools already exist: 
the study of program execution is called `dynamic analysis' which has 
received substantial attention in the research community,
as surveyed by Cornellissen et al.~\cite{cornelissen2009systematic}.
They categorise on different facets being the 
\textit{activity} [goal of analysis],
\textit{target} [kind of inspected program or system],
\textit{method} [visualization, metrics, online, querying, etc.],
\textit{evaluation} [preliminary, case study, quantitative, etc.].
In most cases dynamic analysis involves a \textit{post mortem} analysis, 
where first the program is run and then the trace data is analyzed to create a visualization.
Reiss mentions the compromises that have to be made to make an online analysis~\cite{reiss2006visualizing}: 
reduced tracing is required to not slow down the system (known as the observer-effect), 
fast analysis is required to lower the cost of getting to the visualization, to not discourage the users.
In our design we found similar compromises relevant for RP debugging.

% \todo{
% \begin{enumerate}
%  \item Cornelissen, TU Delft, survey on Program Compr. through Dynamic Analysis
%  		lists limitations: 
% 		   - incompleteness, only part of domain
% 			 - which scenarios to analyse
% 			 - scalability (wrt human cognitive load) 
% 		 	 - observer effect (multi-threaded, realtime) changes execution
% \end{enumerate}
% }

\textbf{Specialized debuggers.}
Most research into debugging focusses on procedural and 
imperative languages~\cite{cornelissen2009systematic}.
Other topics of interest are multi-threading and distributed systems and 
only few focus on other styles, like declarative programming~\cite{nilsson1998declarative}.
Debugging specifically for Reactive Programming was only first mentioned and tried by Salvaneshi et al. for REScala~\cite{salvaneschi2014empirical,salvaneschi2016debugging}.

\todo{
\begin{enumerate}
	\item Atlas (2014): rich graph representation, can be used to build call graphs, dataflow graphs, dependency graphs
%	\item RP debugging (2016, Guido): REScala, data flow graph, breakpoints
%	\item BIGDEBUG Spark debugging (2017): data flow graph, non-pausing simulated breakpoints, data provenance
\end{enumerate}
}

\textbf{Tracing \& Automated visualization for comprehension}
\todo{
\begin{enumerate}
 \item Lange 1995, Program Visualizer for C++
 \item story flow: visualize stories over time, comprehending relations, interactive visualization
 \item Weck \& Tichy, Visualizing Data-Flows in Functional Programs
 \item Srinivasan, ICPC16, ``Case Studies of Optimized Sequence Diagram for Program Comprehension", Texas A\&M Univerity
%  \item Misha Moroshko (Facebook) Rx visualization
\end{enumerate}
}