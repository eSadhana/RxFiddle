\section{Debugger Design}
\label{section-design}
In this section we describe the design of a visualizer for the ReactiveX (Rx) family of RP libraries to answer RQ2. Given the findings of RQ1, the requirements for our visualizer are:
\begin{description}
\itemsep0em 
\item[REQ1] Provide overview of Observable flows
\item[REQ2] Provide detailed view inside flow
\end{description}

We propose a visualizer consisting of two parts: (1) a data flow graph and (2) a dynamic marble diagram. The data flow graph provides high-level overview, showing how different flows are created, combined and used, while the marble diagram offers a more in-depth look into a single selected data flow showing the contents (in terms of values and subscriptions) of the flows and can be used learn the behaviors and interplay of operators.

\subsection{Data Flow Graph}
\paragraph{Simplified graphs} When running an RP program, Observables are created that depend on other Observables (their \emph{source}) and Observers are created to send their values to a defined set of Observers (their \emph{destination}). Figure \ref{chaincreate} shows these relations in a graph. For the simplest of programs, the relations between the Observables ($O = {o_1, o_2, o_3}$) and those between Observers ($S = {s_1, s_2, s_3}$) share an equally shaped sub-graph after a reversal of the Observer-edges. To provide more overview, we process the graph to merge the two Observable and Observer sequences together, simplifying it in the process, as in Figure \ref{fiddlesimple}. Higher order relations are retained as shown in \ref{fiddlehigher}.

\begin{figure}[ht]
	\centering
	\input{images/chainsimple}
	\caption{Simplified graph of Figure \ref{chaincreate}}
	\label{fiddlesimple}
\end{figure}

\begin{figure}[ht]
	\centering
	\input{images/fiddlehigher}
	\caption{Simplified graph of Figure \ref{chainhigher}}
	\label{fiddlehigher}
\end{figure}

\paragraph{Layout} Layout is used to add extra meaning to the graph. If multiple subscriptions on the same Observable are created, multiple flows are kept in the graph and they are bundled together in the resulting layout. This is designed to help developers find related flows. Also it is easy to see that for example an Observable is reused many times, hinting a possible performance improvement by sharing the computation (Rx has special \code{share}-operators to multicast). The layout is based on StoryFlow~\cite{liu2013storyflow}, which employs a hierarchical clustering before ordering the graph in a way to reduce crossings. Where StoryFlow clusters on physical character location we cluster flows per Observable. Furthermore, StoryFlow supports interactivity in various layout stages of which we use the algorithms for \emph{straightening} and \emph{dragging} to support selecting a specific flow, which is then highlighted, straightened and positioned at the right in order to match the marble diagram, shown for the current highlighted flow.

\paragraph{Color} Coloring the nodes can be used to identify the same Observable in multiple places in the graph, as Observables can be reused in different places of the stream.

\subsection{Dynamic Marble Diagrams}
In contrast to the original diagrams (Section \ref{marblediagram}) we use dynamic diagrams which update live when new events occur and are stacked to show the data in the complete flow. This allows the developer to trace a value back through the flow, a debug operation which is impossible using a classic debugger. Handcrafted marble diagrams can use custom shapes and colors to represent events, but for the generic debugger we use only three shapes: next-events are a green dot, errors a black cross, completes a vertical line, as shown in Figure~\ref{screenshot-mergeAll}. For our generic debugger it is unfeasible to automatically decide which properties (content, shape and color) to apply to events, as the amount of events and distinguishing features might be unbounded. Instead the event values are shown upon hovering.

\subsection{Architecture}
To support the visualization, we design a debugger architecture consisting of 2 components:

The \textbf{Host instrumentation} instruments the Rx library to emit useful execution events. Depending on the language and platform, specific instrumentation is required. Output of the instrumentation is a platform and language independent graph like Figure \ref{chainhigher}. By splitting the instrumentation, the debugger can be used for the complete ReactiveX family of libraries by only reimplementing the first component. The communication protocol for the instrumentation is shown in Table \ref{protocol}. 

The \textbf{Visualizer} takes the initial graph and simplifies it into a Data Flow Graph. Then it lays out the Data Flow Graph and provides the debuggers User Interface. By separating the visualizer, we can safely export generated graphs and visualize them post mortem for example for documentation purposes.

The components can run in their own environment. The instrumentation must run inside the host language, while the Visualizer can use a different language and platform.

\begin{figure*}
\includegraphics[width=\textwidth]{{images/screenshot.mergeAll.crop}.png}
\caption{Screenshot of \href{http://rxfiddle.net/\#type=editor&code=Y29uc3Qgc291cmNlMSA9IFJ4Lk9ic2VydmFibGUKICAub2YoMSwgMiwgMywgNCkKCmNvbnN0IHNvdXJjZTIgPSBSeC5PYnNlcnZhYmxlCiAgLm9mKCJhIiwgImIiLCAiYyIsICJkIikKClJ4Lk9ic2VydmFibGUKICAub2Yoc291cmNlMSwgc291cmNlMikKICAubWVyZ2VBbGwoKQogIC5za2lwKDIpCiAgLnN1YnNjcmliZSgp}{RxFiddle.net}}
\label{screenshot-mergeAll}
\end{figure*}

\begin{table*}[t]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
addObservable(id, sourceIds)                   & Adds a Observable node, with zero or more source Observable's                                                                                                                      \\ \hline
addObserver(id, observableId, destinationId)   & \begin{tabular}[c]{@{}l@{}}Add a Observer, observableId denotes the Observable it subscribed to, \\ optional destinationId adds an edge to the destination Observer\end{tabular}   \\ \hline
addOuterObserver(observerId, outerDestination) & \begin{tabular}[c]{@{}l@{}}Create a special edge between an existing Observer and the higher order \\ destination Observer\end{tabular}                                            \\ \hline
addEvent(observerId, type, optionalValue)      & \begin{tabular}[c]{@{}l@{}}Add an event to the Observer denoted by observerId, of type (next, error, complete), \\ optionally with a value (for next / error events).\end{tabular} \\ \hline
addMeta(id, metadata)                          & Add meta data such as the method call which created an Observable.                                                                                                                 \\ \hline
\end{tabular}%
}
\caption{Instrumentation protocol}
\label{protocol}
\end{table*}

\subsection{Implementation}
To validate the design and to provide an implementation to the developer community we created \url{RxFiddle.net}. The RxFiddle project is a reference implementation of 
our reactive debugger design. Besides the visualizer, the website also contains a code editor for JavaScript code with sharing functionality, for developers to share snippets with their peers, as shown in Figure \ref{screenshot-mergeAll}. In this section we will explain different parts of the implementation. For RxFiddle, we initially focused on RxJS (JavaScript).

\paragraph{Instrumentation}
With JavaScript being a dynamic language, we use a combination of prototype patching and Proxies\footnote{\url{https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy}} to instrument the RxJS library: the Observable and Observer prototypes are patched to return Proxies wrapping the API method calls. The instrumentation passes every method entry and method exit to the Linking-step.

\paragraph{Linking}
Here, we distinguish between method calls from the different phases (Section \ref{nutshell}). From the assembly phase, we detect when Observables are used as target or arguments of a call or as return value, and create a graph node for each detected Observable. We add an edge between the call target \& call arguments and returned Observables, denoting the `source'-relation. Also, we tag the returned Observable with the call frame information (time, method name, arguments). In the subscription phase we detect calls to the \code{subscribe}-method: the destination Observers are passed as arguments, so we create the graph nodes and save the relation as an edge. In the runtime phase we detect `next', `error' and `complete' calls on Observers and add these as meta data to the Observer nodes.

\paragraph{Graph Loggers}
From the Linking-step the graph mutations are streamed to the environment of the visualizer, where the graph is rebuild. Depending on the host language a different protocol is used: RxFiddle's code editor executes the code in a Worker\footnote{\url{https://developer.mozilla.org/docs/Web/API/Worker}} and transmits events over the postMessage protocol, while RxFiddle for Node transmits over WebSockets. Being able to support multiple protocols increases the possible use cases, ranging from the code editor for small programs, to the Node plugin for server applications, to Chrome DevTool extensions\footnote{\url{https://developer.chrome.com/extensions/devtools}} for web applications.

\paragraph{Visualizer}
The visualizer receives the current state in the form of a graph from the Logger. It then uses the Observers in the graph to create the Data Flow Graph (DFG). 
To layout the DFG using StoryFlow~\cite{liu2013storyflow} we first rank the graph using depth first search, remove slack and reverse edges where necessary to create a directed acyclic graph. We then add dummy nodes to replaces long edges with edges spanning a single rank. Finally we order and align the nodes in the ranks assigning coordinates for the visualization. It is important that layout is fast, as it runs every time the DFG is changed. To render the Marble Diagrams the flow to and from the selected Observer is gathered by recursively traversing the graph in the direction of the edges, respectively the reversed direction.
