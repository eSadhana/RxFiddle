\section{Abstract} 
Traditional software engineering tooling falls short for modern programming 
techniques such as asynchronous programming and reactive programming. Like 
the Async Debuggers that are created for asynchronous programming we can create
special Reactive Debuggers specialized to debug the event flow through our programs.

In this work we aim to create a software development tool specialized for Reactive Programming
that both aids reactive program comprehension and supports debugging reactive programs. 
It does so by visualizing the structure of the data flow in a graph and giving insight in 
the state of the application through time in the form of so called Marble Diagrams.

By performing a case study / semi-structured interviews we assess whether our tool
improves program comprehension and debugability of reactive programs.

% Reactive Programming
% A short explainer about Reactive Programming might be in place. Reactive Programming
% is a programming paradigm specifically useful in domains where external events should
% trigger some computation 

%  Tools
% such as our code editors are made for writing sequentially executed code: a 
% linear list of statements, executed top to bottom. Asynchronous programs and
% reactive programs even more do not execute top to bottom, but instead wire up
% callback functions to be executed later.

% Code comprehension and debugging for sequential executing programs leans on
% the mental model where  

% Reactive Programming is gaining use in recent years. Due to the creation of 
% new implementations and the inclusion of those implementations in widely 
% known frameworks like AngularJS more developers are exposed to this new 
% programming paradigm. Reactive Programming offers a high level and pure way 
% to model the flow of events in our applications compared to the more laborous 
% Observer-pattern way of event handling. 

% Like any paradigm shift or new API it 
% takes developers time to learn and master the technology causing a 

% Existing software engineering tools were 
% not tailored to Reactive Programming and on different aspects the tooling 
% falls short.

% TBD

% Reactive programing voor Reactive applicaties

% Duidelijk opschrijven complex reactief gedrag.
% Reactive programmas beter te begrijpen, aldus Salvaneschi.

% Premissen voor uitvoer van code zijn gebeurtenissen,
% die voldoen aan eventueel opgegeven eisen.
% Bij traditionele control flow zijn de premissen beschikbaar,
% bij RP zijn de premissen nog niet beschikbaar.

\section{Introduction}%
\label{sec:intro} Software often needs to respond to external events and
data flows.  For example in interactive applications, for desktop, web
and mobile phones, in graphics and in processing sensor data from phones
or IoT-devices.  We can use Reactive Programming (RP) to express complex
reactive behaviour of these applications in a more declarative,
intuitive and consise manner than using traditional design patterns.
Programs are generally more comprehensible, requiring less programming
skills, when created using RP compared to an equal implementation using
the Observer design pattern~\cite{johnson1995design,
salvaneschi2014empirical}.

While the general behaviour of programs becomes more comprehensible
using RP, this does not necessarily hold in precense of complex
operators, unintened behaviour or faults.  We define `debugging' as
examining the behaviour of a program, and `debugability' as a measure of
debugging efficiency.  To our knownlegde no research exists which
evaluates the debugability of reactive programming, and anecdotal
evidence suggests existing tools are not sufficient%
\footnote{
\href{http://staltz.com/how-to-debug-rxjs-code.html}{staltz.com},
\href{http://stackoverflow.com/questions/38590346/how-to-debug-rxjs5}{stackoverflow.com},
\href{https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/testing.md\#debugging-your-rx-application}{RxJS doc},
\href{https://medium.com/@BrianDiPalma/thoughts-on-rxjs-cf3562e20d74\#.ebdrmmeym}{Medium.com},
\href{https://social.msdn.microsoft.com/Forums/en-US/a0215434-8ad6-45e1-9f21-ed2f14d7317a/a-simple-trace-method\?forum=rx}{Microsoft Rx forum},
\href{https://www.reddit.com/r/javascript/comments/4austh/why_isnt_rxjs_more_popular_are_there_bad_parts}{Reddit}
}.

Traditionally faults are tracked down with the help of debugging:  using
breakpoints, logs and tests~\cite{zeller2009programs}.  When debugging
the execution of a sequential program the premises for control flow are
known or computable using the current stack and heap, and the data flow
can be followed by traversing down the stack trace.  However, in RP
events are triggered asynchronously, which resets the stack trace.  The
reset stack traces can not be traversed back to the previous event.
Furthermore, this means previous stack frames containing data related to
previous events are not accessible.

This is especially challenging for more complex programs:  while equal
programs are easier to comprehend in RP style, more complex programs are
also easily created, since RP also improves composability~\cite{maier2012deprecating}.
These programs can be several degrees more complex in behaviour than
traditional applications.

In summary, tracking down bugs becomes harder for two reasons:

\begin{itemize}
    \item
        the search scope widens for larger applications
    \item
        existing tools are not sufficient for reactive programs.

\end{itemize}

Specialized debuggers for reactive programming exist, although not as a
result from academic research or with scientific validation.  Examples
are the Time Traveling Debugger (TTD) for Elm, a functional reactive
programming (FRP) framework, and tools like RxVision and RxMarbles,
which show that visualisation is aids comprehension and debugging. Those
tools fall short however:  TTD is restricted to the Elm platform,
RxVision is a mere proof of concept and restricted to the browser, and
RxMarbles only visualises a given set of operators, using fixed inputs.

\textbf{Intended contributions.} In this thesis we will evaluate whether
data or control flow graphs aid reactive program comprehension and
debugging.  Furthermore we present a tool which generates complete and
interactive Marble Diagrams for full data flows, automatically, from
sources and from running applications.

\section{Research Questions}%
\label{sec:questions} The main research question is:

\begin{quotation}
    \noindent
    Does visualising reactive programs help developers comprehend their
    code and ease the debugging of Observables?
\end{quotation}

\noindent
Several smaller questions must be answered to answer the main question:

\begin{enumerate}
    \item
        Structures:
        \begin{enumerate}
            \item
                Can Observable structures be represented in an abstract
                fashion?
            \item
                Can Observable structures be extracted from source code
                or bytecode?
            \item
                Can run-time behaviour of Observables be extracted such
                that it is appropriate input to a visualizer /
                simulation?
            \item
                Can `smart' (%
                \ref{sec:gen-data}) test input data for Observable
                structures be generated?
        \end{enumerate}

    \item
        Visualisation:
        \begin{enumerate}
            \item
                \label{qstn:marble} Can Marble Diagrams effectively
                convey structures containing more than 1 operator?
        \end{enumerate}

    \item
        Debugger Usability:
        \begin{enumerate}
            \item
                \label{qstn:println} Can our tool (fully) replace
                traditional print-debugging in practice?
            \item
                \label{qstn:autogen} Do developers use automated test
                data in practice?
            \item
                \label{qstn:experience} Does our tool improve the
                development experience when working with Rx?
        \end{enumerate}

\end{enumerate}

\section{User Tests}%
To evaluate our research questions we design a user test in which test
subjects must first comprehend existing reactive code and then fix bugs
which are inserted in reactive code.  To test the difference our
debugger makes the before-after groups will be separate test groups~\cite
{salvaneschi2014empirical}.  One group will only use existing debugging
in the form of tests and print line debugging, while the other group
gets access to the visualizing debugger.

The work of Salvaneschi et al.  and Quante et al.  will be used as a
baseline for the design of our user tests.  Where possible we will reuse
their methodology.  For example, Salvaneschi et al.  created a exam-like
test tool, used to automatically take user tests which includes time
measurements.

\section{Implementation}%
Before the user test takes place, we need to create the actual debugger.
It consists of 3 required parts and 2 optional extensions:

\begin{enumerate}
    \item
        Observable structure analysis:  static, capturing structure
    \item
        Observable runtime analysis:  dynamic, capturing events
    \item
        Visualisation of structure and events
    \item
        \textit{Optional.} Generating test input observables
    \item
        \textit{Optional.} Tainting, tracking data dependencies
\end{enumerate}

The scope for this thesis will be limited to Reactive Extensions (Rx)~\cite
{msdn_rx}, one of the libraries implementing Reactive Programming which
has implementations in almost every programming language.  Rx is
publicly used by Netflix and Microsoft, in high-scale production
applications, but more importantly:  it is very mature.  The
implementation of Rx dates back before 2010 and is very well thought
through while newer frameworks like Reactive Streams and Bacon.js lack
these backgrounds.  Rx is very stable and structured, simplifying the
implementation of the prototype.  When completed, it can then be easily
extended to many other Reactive Programming implementations.

\subsection{Observable structure analysis}%
The templates for the data flows, encapsulated in Observable in Rx, are
contained in code.  By analysing the source code or bytecode these
templates can be extracted.  Observables are created by calling several
factory methods on the Observable-class.  After creation they can be
passed as variables and can be transformed by applying operators which
generate a new, extended Observable structure.  Since Observables are (immutable)
value types they can be used multiple times as a basis to create new
structures, therefore possibly creating a tree of related Observable
structures.  This structure is the basis for the visualisation.

\subsection{Run-time analysis} By analysing the structure one can know
in advance through which operators possible future data will flow.
During run-time this propagation of data through operators can be
detected.  In Rx the methods onNext, onError and onComplete propagate
data, which can be instrumented to log the invocation to the
visualisation engine.  Every event then gets shown as a marble in the
correct Observable axis.

To instrument code several technologies are available, for Java:  For
example \href{http://asm.ow2.org}{ASM}~\cite{bruneton2002asm,
kuleshov2007using}, which offers very low level bytecode rewriting, or
\href{http://www.eclipse.org/aspectj/}{AspectJ}~\cite{kiczales2001overview}
which leverages AOP~\cite{kiczales1997aspect} to provide a high level
interface to add logic to existing methods.  Either of these libraries
will be used to setup the run-time analysis, depending on which enables
our requirements and is the easiest to implement.

\subsection{Visualisation}%
Automated analysis to extract information about program structure and
execution, and visualisation of the results are widely considered useful
for comprehension~\cite{weck2016visualizing,quante2008dynamic}.

The de-facto standard to visualise Observables is called a Marble
Diagram~\cite{c9_marblediagrams}.  The ReactiveX documentation~\cite{reactivex}
contains these diagrams, for single operators.  These diagrams really
complement the name of the operator and its description, allowing the
developer to work-out the nitty details and pick the right operator for
it's use.  They are however only generated per operator, and are not
combined for complete data flows, showing the full flow through many
operators.  The diagrams in the documentation originate from RxJava and
are drawn in \href{https://www.omnigroup.com/omnigraffle} {Omnigraffle}.

While the diagrams in the official documentation are static, some
efforts exist to generate these diagrams automatically.  \href{http://RxMarbles.com}
{RxMarbles.com} is a website which allows the user to drag and reorder
events in for almost all Observable operators, live updating the
corresponding diagram.  \href{https://github.com/jaredly/rxvision}{RxVision}
on the other hand visualises full structures.  It offers a code editor
where one can type JavaScript using RxJs and RxVision will visualise the
structure created in the editor.  RxVision injects code into the RxJS
source which extracts the structure, subscriptions and flowing data.
While RxVision is a great step in the right direction, it does not
integrate into development environments as of September 2016:  it
requires the code to be placed in the online editor.

At some time Microsoft offered a ``Marble Diagram Generator" and \href{http://mnajder.blogspot.nl/2010/03/rxsandbox-v1.html}
{RxSandbox}, which were Windows applications which - looking at Google'd
images - had a catalogue of standard operators and a sandbox to generate
custom diagrams.  However, the source of these tools is not available
and the download links are broken.

\subsection{Generating data}%
\label{sec:gen-data} Testing tools like QuickCheck~\cite{quickcheck}
automate test generation by producing arbitrary input, and by finding
test cases that falsify the test conditions.  When a falsification is
found QuickCheck tries to simplify the test data, pruning data which
does not attribute to the tests failure.  An equally advanced test tool
for data flows would be interesting, and is an interesting further
research topic.  Generating data however can be interesting.
Visualising the behaviour of Observables without running the actual
program, based solely on the data flow structure and generated data
could provide valuable insight.  Learning from QuickCheck, reducing to
pivotal data can show the various edge cases of how a data flow can
evaluate while keeping the amount of cases to be considered (and
interpreted by humans) at a minimum.

\subsection{Tainting}%
When looking at the values bubbling through an Observable structure,
values might be produced which are not directly relatable to their
sources.  With pointwise transformations the developer can trace each
output back to a single point of input.  However, operations that fold
over time might both use new and reuse older values.  The relation
between these variables might not be clear over time.  One existing
solution to track dependencies between variables is called tainting~\cite
{bell2015dynamic}:  by applying a taint to a variable, dependent
variables either get the same taint or a mixture of all the taints of
it's dependencies.  Implementations of tainting like Phosphor~\cite{bell2014phosphor}
can be evaluated and might be interesting to integrate.

\section{Planning}

\subsection{Scheme}%
A preliminary planning is defined in \autoref{table:planning}.

\begin{table}[h]
    \label{table:planning}
    \centering
    \begin{tabular}{@{}ll@{}}
        \textbf{What}               & \textbf{When}           \\ 
        \hline
        Start of project, at Ordina & 12th of September, 2016 \\ 
        Research Proposal ready     & 25th of September, 2016 \\ 
        \hline
        Test prototype 1            & 2nd of December, 2016   \\ 
        User test 1                 & 5th of December, 2016   \\ 
        \hline
        Test prototype 2            & 20th of Januari, 2017   \\ 
        User test 2                 & 23th of Januari, 2017   \\ 
        \hline
        Draft of final report       & 15th of March, 2017     \\ 
        \hline
        Thesis Defense              & 15th of April, 2017     \\ 
    \end{tabular}
\end{table}

\subsection{Contact}

\begin{table}[h]
    \centering
    \begin{tabular}{@{}l@{}}
        \textbf{Student}                \\ 
        \hline
        Herman Banken                   \\ 
        Balthasar van der Polweg, Delft \\ 
        06 - 38 94 37 30                \\ 
        hermanbanken@gmail.com          \\ 
    \end{tabular}
\end{table}

\begin{table}[h]
    \centering
    \begin{tabular}{@{}lll@{}}
        \textbf{Ordina}                 & \textbf{University}     & \textbf{University}     \\ 
        \hline
        Joost de Vries                  & Georgios Gousios        & Prof.dr. H.J.M. Meijer  \\ 
        Ringwade 1, Nieuwegein          & EWI HB08.xxx            & EWI HB08.060 / SV       \\ %06 - 12 89 56 76         & -                   & -                        \\
         
        Joost.de.Vries@ordina.nl        & gousiosg@gmail.com      & H.J.M.Meijer@tudelft.nl \\ 
    \end{tabular}
\end{table}

\subsection{Supervision details}%
The thesis project will take place mainly at Ordina, and partly at the
Delft Technical University.  Ordina provides a working place, computer
for the thesis, as well as sparring partners in the form of other
students and colleagues of Joost from Code Star and SMART on the same
floor.

\noindent
To discuss the progress several meetings are scheduled:
\begin{enumerate}
    \item
        Weekly meetings with the company supervisor Joost de Vries.
    \item
        Weekly meetings with Georgios Gousios in Delft, or over video
        chat.
    \item
        Bi-Weekly meetings with Erik Meijer over video chat.
\end{enumerate}

\noindent
Furthermore some 'user' (developer) tests will need to be executed,
\begin{itemize}
    \item
        to learn existing workflows;
    \item
        to compare existing workflows to new proposed workflows;
    \item
        to provide input on the usability of the tools;
    \item
        or to measure satisfaction with the new tools
\end{itemize}
for which it would also be very convenient if some employees of Ordina
could volunteer.

\subsection{Risk analysis} The project is subject to several risks,
discussed here.

The first risks are internal to the project.  The scope described in
\autoref{sec:intro} and~%
\ref{sec:questions} is quite challenging.  The visualisation part could
be a thesis topic on it's own.  However, due to previous and available
work in projects like RxVision and RxMarbles, the time required for
implementation is at least limited.  The existing visualisation of
RxVision might prove to be not ideal, and RxMarbles is not as complete
as RxVision, so some additional work might be required to create an
optimal visualisation.  This would be perfecting the tool however, and
does not need be part of the academic thesis.

Secondly the project needs a case study and user test to fully test the
effectiveness of the debug methodology.  User studies are a risk since
the organisation of the test event depends on many people.  By doing the
thesis at Ordina this risk is at least limited, as there are many
developers present, on location, of which only a subset needs to be
available.

External risks are other courses that need to be finished.  As of
September 2016 only 7 ECTS need to be completed, not regarding the 45
ECTS of the thesis itself.  I'm currently still working on `IN4306
Literature Study' (10 ECTS) on a somewhat related but more general
subject of `Reactive Programming'.  The remaining work is limited, but -
at the very latest - needs to be completed before the defense.  The
literature study will not take up time from the thesis, as I plan to do
this in the weekend and evenings.

Finally, a risk is the time of the people involved, especially professor
Meijer.  Meijer works a full-time job at Facebook, as of September 2016,
and his professorship is only part-time.  To remedy this risk an
additional supervisor in the person of Georgios Gousios was contacted.
Georgios will function as the default university contact, while Meijer
will provide valuable input where possible.

\subsection{User tests and prototypes} The research question in general,
and specifically subquestions %
\ref{qstn:marble}, %
\ref{qstn:println}, %
\ref{qstn:autogen} and %
\ref{qstn:experience} touch the man-machine-interaction and psychology
sides of Computer Science.  The appropriate way to answer these
questions would be (one or more) case studies and user tests.

The planning mentions the completion of two prototypes and subsequent
user tests.  The final feature-set of these prototypes can not yet be
determined, but a preliminary specification is given here.

\subsubsection{User tests}%
To evaluate questions %
\ref{qstn:println} and %
\ref{qstn:experience} the tool needs to be working on all levels of the
implementation.  Both the gathering of data as visualisation need to
work.  Not every feature of Rx needs to be supported, but to test the
experience at least common use cases - that developers can relate to -
should be fully debuggable.  As this requires the bulk of work, these
questions will be addressed in the second test.

Question%
\ref{qstn:marble} can be tested using the visualisation part only.
Building on the existing \href{http://rxmarbles.com}{RxMarbles.com} the
visualisation will be created for some scripted examples.  A user test
can then verify that the visualisation is comprehensible and clear.  To
test the debugging usability of the visualisation a bug can be
introduced in code, and the corresponding visualisation should then be
used to localise the bug.  The visualisation part is the only
requirement for the test, so this question will be addressed in the
first test.

The last question%
\ref{qstn:autogen} is self-contained, and builds upon the visualiser.
Depending on the progress made, the implementation of auto-generation of
tests can be considered or postponed.  Preferably this feature would be
part of prototype 1, to better distribute the tests.

\subsubsection{Prototypes} The list of features for the prototypes then
becomes:

\begin{enumerate}
    \item[Prototype 1]
        \begin{enumerate}
            \item
                Visualiser for Observable sequence with multiple
                subsequent operations
            \item
                Interactive input sequences
            \item
                Live updating events in subsequent sequences
            \item
                Optionally, `smart' test event generation
        \end{enumerate}
    \item[Prototype 2]
        \begin{enumerate}
            \item
                Static analysis collector for structures in code
            \item
                Runtime analysis collector for events in Observable
                sequences
            \item
                Interface to select `root' Observable:  which Observable
                to use as starting point for the visualisation
            \item
                Interface to switch between runtime events and (interactive/generated)
                test events
            \item
                `Smart' test event generation, if not done in prototype
                1.
        \end{enumerate}
\end{enumerate}

\bibliography{papers/references}
{}
\bibliographystyle{plain}
